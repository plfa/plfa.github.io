<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>BigStep: Big-step semantics of untyped lambda calculus | Programming Language Foundations in Agda</title><meta name="generator" content="Jekyll v3.9.0"><meta property="og:title" content="BigStep: Big-step semantics of untyped lambda calculus"><meta property="og:locale" content="en_US"><meta name="description" content="Programming Language Foundations in Agda"><meta property="og:description" content="Programming Language Foundations in Agda"><link rel="canonical" href="https://plfa.github.io/20.07/BigStep/"><meta property="og:url" content="https://plfa.github.io/20.07/BigStep/"><meta property="og:site_name" content="Programming Language Foundations in Agda"><script type="application/ld+json">{"url":"https://plfa.github.io/20.07/BigStep/","headline":"BigStep: Big-step semantics of untyped lambda calculus","description":"Programming Language Foundations in Agda","@type":"WebPage","@context":"https://schema.org"}</script><link rel="stylesheet" href="/20.07/assets/main.css"></head><body><header class="site-header" role="banner"><div class="wrapper"><a class="site-title" href="/20.07/">Programming Language Foundations in Agda</a><nav class="site-nav"><span class="menu-icon"><svg viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/></svg></span><div class="trigger"><a class="page-link" href="/20.07/">The Book</a> <a class="page-link" href="/20.07/Announcements/">Announcements</a> <a class="page-link" href="/20.07/GettingStarted/">Getting Started</a> <a class="page-link" href="/20.07/Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><header class="post-header"><h1 class="post-title">BigStep: Big-step semantics of untyped lambda calculus</h1></header><p style="text-align:center"><a alt="Previous chapter" href="/20.07/Confluence/">Prev</a> &bullet; <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev-20.07/src/plfa/part2/BigStep.lagda.md">Source</a> &bullet; <a alt="Next chapter" href="/20.07/Denotational/">Next</a></p><div class="post-content"><pre class="Agda"><a id="174" class="Keyword">module</a> <a id="181" href="/20.07/BigStep/" class="Module">plfa.part2.BigStep</a> <a id="200" class="Keyword">where</a>
</pre><h2 id="introduction">Introduction</h2><p>The call-by-name evaluation strategy is a deterministic method for computing the value of a program in the lambda calculus. That is, call-by-name produces a value if and only if beta reduction can reduce the program to a lambda abstraction. In this chapter we define call-by-name evaluation and prove the forward direction of this if-and-only-if. The backward direction is traditionally proved via Curry-Feys standardisation, which is quite complex. We give a sketch of that proof, due to Plotkin, but postpone the proof in Agda until after we have developed a denotational semantics for the lambda calculus, at which point the proof is an easy corollary of properties of the denotational semantics.</p><p>We present the call-by-name strategy as a relation between an input term and an output value. Such a relation is often called a <em>big-step semantics</em>, written <code class="language-plaintext highlighter-rouge">M ⇓ V</code>, as it relates the input term <code class="language-plaintext highlighter-rouge">M</code> directly to the final result <code class="language-plaintext highlighter-rouge">V</code>, in contrast to the small-step reduction relation, <code class="language-plaintext highlighter-rouge">M —→ M′</code>, that maps <code class="language-plaintext highlighter-rouge">M</code> to another term <code class="language-plaintext highlighter-rouge">M′</code> in which a single sub-computation has been completed.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="1332" class="Keyword">open</a> <a id="1337" class="Keyword">import</a> <a id="1344" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="1384" class="Keyword">using</a> <a id="1390" class="Symbol">(</a><a id="1391" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="1394" class="Symbol">;</a> <a id="1396" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1400" class="Symbol">;</a> <a id="1402" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#984" class="Function">trans</a><a id="1407" class="Symbol">;</a> <a id="1409" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a><a id="1412" class="Symbol">;</a> <a id="1414" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a><a id="1422" class="Symbol">)</a>
<a id="1424" class="Keyword">open</a> <a id="1429" class="Keyword">import</a> <a id="1436" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html" class="Module">Data.Product</a> <a id="1449" class="Keyword">using</a> <a id="1455" class="Symbol">(</a><a id="1456" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">_×_</a><a id="1459" class="Symbol">;</a> <a id="1461" href="Agda.Builtin.Sigma.html#139" class="Record">Σ</a><a id="1462" class="Symbol">;</a> <a id="1464" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ-syntax</a><a id="1472" class="Symbol">;</a> <a id="1474" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1364" class="Function">∃</a><a id="1475" class="Symbol">;</a> <a id="1477" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">∃-syntax</a><a id="1485" class="Symbol">;</a> <a id="1487" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a><a id="1492" class="Symbol">;</a> <a id="1494" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a><a id="1499" class="Symbol">)</a>
  <a id="1503" class="Keyword">renaming</a> <a id="1512" class="Symbol">(</a><a id="1513" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a> <a id="1517" class="Symbol">to</a> <a id="1520" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="1525" class="Symbol">)</a>
<a id="1527" class="Keyword">open</a> <a id="1532" class="Keyword">import</a> <a id="1539" href="https://agda.github.io/agda-stdlib/v1.1/Function.html" class="Module">Function</a> <a id="1548" class="Keyword">using</a> <a id="1554" class="Symbol">(</a><a id="1555" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">_∘_</a><a id="1558" class="Symbol">)</a>
<a id="1560" class="Keyword">open</a> <a id="1565" class="Keyword">import</a> <a id="1572" href="/20.07/Untyped/" class="Module">plfa.part2.Untyped</a>
  <a id="1593" class="Keyword">using</a> <a id="1599" class="Symbol">(</a><a id="1600" href="/20.07/Untyped/#3153" class="Datatype">Context</a><a id="1607" class="Symbol">;</a> <a id="1609" href="/20.07/Untyped/#4294" class="Datatype Operator">_⊢_</a><a id="1612" class="Symbol">;</a> <a id="1614" href="/20.07/Untyped/#3521" class="Datatype Operator">_∋_</a><a id="1617" class="Symbol">;</a> <a id="1619" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="1620" class="Symbol">;</a> <a id="1622" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a><a id="1623" class="Symbol">;</a> <a id="1625" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">_,_</a><a id="1628" class="Symbol">;</a> <a id="1630" href="/20.07/Untyped/#3557" class="InductiveConstructor">Z</a><a id="1631" class="Symbol">;</a> <a id="1633" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S_</a><a id="1635" class="Symbol">;</a> <a id="1637" href="/20.07/Untyped/#4330" class="InductiveConstructor Operator">`_</a><a id="1639" class="Symbol">;</a> <a id="1641" href="/20.07/Untyped/#5111" class="Function Operator">#_</a><a id="1643" class="Symbol">;</a> <a id="1645" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ_</a><a id="1647" class="Symbol">;</a> <a id="1649" href="/20.07/Untyped/#4442" class="InductiveConstructor Operator">_·_</a><a id="1652" class="Symbol">;</a>
  <a id="1656" href="/20.07/Untyped/#6963" class="Function">subst</a><a id="1661" class="Symbol">;</a> <a id="1663" href="/20.07/Untyped/#7375" class="Function">subst-zero</a><a id="1673" class="Symbol">;</a> <a id="1675" href="/20.07/Untyped/#6671" class="Function">exts</a><a id="1679" class="Symbol">;</a> <a id="1681" href="/20.07/Untyped/#6235" class="Function">rename</a><a id="1687" class="Symbol">;</a> <a id="1689" href="/20.07/Untyped/#10178" class="InductiveConstructor">β</a><a id="1690" class="Symbol">;</a> <a id="1692" href="/20.07/Untyped/#9998" class="InductiveConstructor">ξ₁</a><a id="1694" class="Symbol">;</a> <a id="1696" href="/20.07/Untyped/#10088" class="InductiveConstructor">ξ₂</a><a id="1698" class="Symbol">;</a> <a id="1700" href="/20.07/Untyped/#10286" class="InductiveConstructor">ζ</a><a id="1701" class="Symbol">;</a> <a id="1703" href="/20.07/Untyped/#9948" class="Datatype Operator">_—→_</a><a id="1707" class="Symbol">;</a> <a id="1709" href="/20.07/Untyped/#11068" class="Datatype Operator">_—↠_</a><a id="1713" class="Symbol">;</a> <a id="1715" href="/20.07/Untyped/#11174" class="InductiveConstructor Operator">_—→⟨_⟩_</a><a id="1722" class="Symbol">;</a> <a id="1724" href="/20.07/Untyped/#11118" class="InductiveConstructor Operator">_∎</a><a id="1726" class="Symbol">;</a>
  <a id="1730" href="/20.07/Untyped/#21721" class="Function">—↠-trans</a><a id="1738" class="Symbol">;</a> <a id="1740" href="/20.07/Untyped/#22905" class="Function">appL-cong</a><a id="1749" class="Symbol">)</a>
<a id="1751" class="Keyword">open</a> <a id="1756" class="Keyword">import</a> <a id="1763" href="/20.07/Substitution/" class="Module">plfa.part2.Substitution</a> <a id="1787" class="Keyword">using</a> <a id="1793" class="Symbol">(</a><a id="1794" href="/20.07/Substitution/#2405" class="Function">Subst</a><a id="1799" class="Symbol">;</a> <a id="1801" href="/20.07/Substitution/#3046" class="Function">ids</a><a id="1804" class="Symbol">)</a>
</pre><h2 id="environments">Environments</h2><p>To handle variables and function application, there is the choice between using substitution, as in <code class="language-plaintext highlighter-rouge">—→</code>, or to use an <em>environment</em>. An environment in call-by-name is a map from variables to closures, that is, to terms paired with their environments. We choose to use environments instead of substitution because the point of the call-by-name strategy is to be closer to an implementation of the language. Also, the denotational semantics introduced in later chapters uses environments and the proof of adequacy is made easier by aligning these choices.</p><p>We define environments and closures as follows.</p><pre class="Agda"><a id="ClosEnv"></a><a id="2437" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2445" class="Symbol">:</a> <a id="2447" href="/20.07/Untyped/#3153" class="Datatype">Context</a> <a id="2455" class="Symbol">→</a> <a id="2457" class="PrimitiveType">Set</a>

<a id="2462" class="Keyword">data</a> <a id="Clos"></a><a id="2467" href="/20.07/BigStep/#2467" class="Datatype">Clos</a> <a id="2472" class="Symbol">:</a> <a id="2474" class="PrimitiveType">Set</a> <a id="2478" class="Keyword">where</a>
  <a id="Clos.clos"></a><a id="2486" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="2491" class="Symbol">:</a> <a id="2493" class="Symbol">∀{</a><a id="2495" href="/20.07/BigStep/#2495" class="Bound">Γ</a><a id="2496" class="Symbol">}</a> <a id="2498" class="Symbol">→</a> <a id="2500" class="Symbol">(</a><a id="2501" href="/20.07/BigStep/#2501" class="Bound">M</a> <a id="2503" class="Symbol">:</a> <a id="2505" href="/20.07/BigStep/#2495" class="Bound">Γ</a> <a id="2507" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="2509" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="2510" class="Symbol">)</a> <a id="2512" class="Symbol">→</a> <a id="2514" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2522" href="/20.07/BigStep/#2495" class="Bound">Γ</a> <a id="2524" class="Symbol">→</a> <a id="2526" href="/20.07/BigStep/#2467" class="Datatype">Clos</a>

<a id="2532" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2540" href="/20.07/BigStep/#2540" class="Bound">Γ</a> <a id="2542" class="Symbol">=</a> <a id="2544" class="Symbol">∀</a> <a id="2546" class="Symbol">(</a><a id="2547" href="/20.07/BigStep/#2547" class="Bound">x</a> <a id="2549" class="Symbol">:</a> <a id="2551" href="/20.07/BigStep/#2540" class="Bound">Γ</a> <a id="2553" href="/20.07/Untyped/#3521" class="Datatype Operator">∋</a> <a id="2555" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="2556" class="Symbol">)</a> <a id="2558" class="Symbol">→</a> <a id="2560" href="/20.07/BigStep/#2467" class="Datatype">Clos</a>
</pre><p>As usual, we have the empty environment, and we can extend an environment.</p><pre class="Agda"><a id="∅&#39;"></a><a id="2650" href="/20.07/BigStep/#2650" class="Function">∅&#39;</a> <a id="2653" class="Symbol">:</a> <a id="2655" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2663" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a>
<a id="2665" href="/20.07/BigStep/#2650" class="Function">∅&#39;</a> <a id="2668" class="Symbol">()</a>

<a id="_,&#39;_"></a><a id="2672" href="/20.07/BigStep/#2672" class="Function Operator">_,&#39;_</a> <a id="2677" class="Symbol">:</a> <a id="2679" class="Symbol">∀</a> <a id="2681" class="Symbol">{</a><a id="2682" href="/20.07/BigStep/#2682" class="Bound">Γ</a><a id="2683" class="Symbol">}</a> <a id="2685" class="Symbol">→</a> <a id="2687" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2695" href="/20.07/BigStep/#2682" class="Bound">Γ</a> <a id="2697" class="Symbol">→</a> <a id="2699" href="/20.07/BigStep/#2467" class="Datatype">Clos</a> <a id="2704" class="Symbol">→</a> <a id="2706" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2714" class="Symbol">(</a><a id="2715" href="/20.07/BigStep/#2682" class="Bound">Γ</a> <a id="2717" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="2719" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="2720" class="Symbol">)</a>
<a id="2722" class="Symbol">(</a><a id="2723" href="/20.07/BigStep/#2723" class="Bound">γ</a> <a id="2725" href="/20.07/BigStep/#2672" class="Function Operator">,&#39;</a> <a id="2728" href="/20.07/BigStep/#2728" class="Bound">c</a><a id="2729" class="Symbol">)</a> <a id="2731" href="/20.07/Untyped/#3557" class="InductiveConstructor">Z</a> <a id="2733" class="Symbol">=</a> <a id="2735" href="/20.07/BigStep/#2728" class="Bound">c</a>
<a id="2737" class="Symbol">(</a><a id="2738" href="/20.07/BigStep/#2738" class="Bound">γ</a> <a id="2740" href="/20.07/BigStep/#2672" class="Function Operator">,&#39;</a> <a id="2743" href="/20.07/BigStep/#2743" class="Bound">c</a><a id="2744" class="Symbol">)</a> <a id="2746" class="Symbol">(</a><a id="2747" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S</a> <a id="2749" href="/20.07/BigStep/#2749" class="Bound">x</a><a id="2750" class="Symbol">)</a> <a id="2752" class="Symbol">=</a> <a id="2754" href="/20.07/BigStep/#2738" class="Bound">γ</a> <a id="2756" href="/20.07/BigStep/#2749" class="Bound">x</a>
</pre><h2 id="big-step-evaluation">Big-step evaluation</h2><p>The big-step semantics is represented as a ternary relation, written <code class="language-plaintext highlighter-rouge">γ ⊢ M ⇓ V</code>, where <code class="language-plaintext highlighter-rouge">γ</code> is the environment, <code class="language-plaintext highlighter-rouge">M</code> is the input term, and <code class="language-plaintext highlighter-rouge">V</code> is the result value. A <em>value</em> is a closure whose term is a lambda abstraction.</p><pre class="Agda"><a id="3016" class="Keyword">data</a> <a id="_⊢_⇓_"></a><a id="3021" href="/20.07/BigStep/#3021" class="Datatype Operator">_⊢_⇓_</a> <a id="3027" class="Symbol">:</a> <a id="3029" class="Symbol">∀{</a><a id="3031" href="/20.07/BigStep/#3031" class="Bound">Γ</a><a id="3032" class="Symbol">}</a> <a id="3034" class="Symbol">→</a> <a id="3036" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3044" href="/20.07/BigStep/#3031" class="Bound">Γ</a> <a id="3046" class="Symbol">→</a> <a id="3048" class="Symbol">(</a><a id="3049" href="/20.07/BigStep/#3031" class="Bound">Γ</a> <a id="3051" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3053" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3054" class="Symbol">)</a> <a id="3056" class="Symbol">→</a> <a id="3058" href="/20.07/BigStep/#2467" class="Datatype">Clos</a> <a id="3063" class="Symbol">→</a> <a id="3065" class="PrimitiveType">Set</a> <a id="3069" class="Keyword">where</a>

  <a id="_⊢_⇓_.⇓-var"></a><a id="3078" href="/20.07/BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="3084" class="Symbol">:</a> <a id="3086" class="Symbol">∀{</a><a id="3088" href="/20.07/BigStep/#3088" class="Bound">Γ</a><a id="3089" class="Symbol">}{</a><a id="3091" href="/20.07/BigStep/#3091" class="Bound">γ</a> <a id="3093" class="Symbol">:</a> <a id="3095" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3103" href="/20.07/BigStep/#3088" class="Bound">Γ</a><a id="3104" class="Symbol">}{</a><a id="3106" href="/20.07/BigStep/#3106" class="Bound">x</a> <a id="3108" class="Symbol">:</a> <a id="3110" href="/20.07/BigStep/#3088" class="Bound">Γ</a> <a id="3112" href="/20.07/Untyped/#3521" class="Datatype Operator">∋</a> <a id="3114" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3115" class="Symbol">}{</a><a id="3117" href="/20.07/BigStep/#3117" class="Bound">Δ</a><a id="3118" class="Symbol">}{</a><a id="3120" href="/20.07/BigStep/#3120" class="Bound">δ</a> <a id="3122" class="Symbol">:</a> <a id="3124" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3132" href="/20.07/BigStep/#3117" class="Bound">Δ</a><a id="3133" class="Symbol">}{</a><a id="3135" href="/20.07/BigStep/#3135" class="Bound">M</a> <a id="3137" class="Symbol">:</a> <a id="3139" href="/20.07/BigStep/#3117" class="Bound">Δ</a> <a id="3141" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3143" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3144" class="Symbol">}{</a><a id="3146" href="/20.07/BigStep/#3146" class="Bound">V</a><a id="3147" class="Symbol">}</a>
    <a id="3153" class="Symbol">→</a> <a id="3155" href="/20.07/BigStep/#3091" class="Bound">γ</a> <a id="3157" href="/20.07/BigStep/#3106" class="Bound">x</a> <a id="3159" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3161" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3166" href="/20.07/BigStep/#3135" class="Bound">M</a> <a id="3168" href="/20.07/BigStep/#3120" class="Bound">δ</a>
    <a id="3174" class="Symbol">→</a> <a id="3176" href="/20.07/BigStep/#3120" class="Bound">δ</a> <a id="3178" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3180" href="/20.07/BigStep/#3135" class="Bound">M</a> <a id="3182" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3184" href="/20.07/BigStep/#3146" class="Bound">V</a>
      <a id="3192" class="Comment">-----------</a>
    <a id="3208" class="Symbol">→</a> <a id="3210" href="/20.07/BigStep/#3091" class="Bound">γ</a> <a id="3212" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3214" href="/20.07/Untyped/#4330" class="InductiveConstructor Operator">`</a> <a id="3216" href="/20.07/BigStep/#3106" class="Bound">x</a> <a id="3218" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3220" href="/20.07/BigStep/#3146" class="Bound">V</a>

  <a id="_⊢_⇓_.⇓-lam"></a><a id="3225" href="/20.07/BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="3231" class="Symbol">:</a> <a id="3233" class="Symbol">∀{</a><a id="3235" href="/20.07/BigStep/#3235" class="Bound">Γ</a><a id="3236" class="Symbol">}{</a><a id="3238" href="/20.07/BigStep/#3238" class="Bound">γ</a> <a id="3240" class="Symbol">:</a> <a id="3242" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3250" href="/20.07/BigStep/#3235" class="Bound">Γ</a><a id="3251" class="Symbol">}{</a><a id="3253" href="/20.07/BigStep/#3253" class="Bound">M</a> <a id="3255" class="Symbol">:</a> <a id="3257" href="/20.07/BigStep/#3235" class="Bound">Γ</a> <a id="3259" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="3261" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="3263" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3265" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3266" class="Symbol">}</a>
    <a id="3272" class="Symbol">→</a> <a id="3274" href="/20.07/BigStep/#3238" class="Bound">γ</a> <a id="3276" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3278" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="3280" href="/20.07/BigStep/#3253" class="Bound">M</a> <a id="3282" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3284" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3289" class="Symbol">(</a><a id="3290" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="3292" href="/20.07/BigStep/#3253" class="Bound">M</a><a id="3293" class="Symbol">)</a> <a id="3295" href="/20.07/BigStep/#3238" class="Bound">γ</a>

  <a id="_⊢_⇓_.⇓-app"></a><a id="3300" href="/20.07/BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="3306" class="Symbol">:</a> <a id="3308" class="Symbol">∀{</a><a id="3310" href="/20.07/BigStep/#3310" class="Bound">Γ</a><a id="3311" class="Symbol">}{</a><a id="3313" href="/20.07/BigStep/#3313" class="Bound">γ</a> <a id="3315" class="Symbol">:</a> <a id="3317" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3325" href="/20.07/BigStep/#3310" class="Bound">Γ</a><a id="3326" class="Symbol">}{</a><a id="3328" href="/20.07/BigStep/#3328" class="Bound">L</a> <a id="3330" href="/20.07/BigStep/#3330" class="Bound">M</a> <a id="3332" class="Symbol">:</a> <a id="3334" href="/20.07/BigStep/#3310" class="Bound">Γ</a> <a id="3336" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3338" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3339" class="Symbol">}{</a><a id="3341" href="/20.07/BigStep/#3341" class="Bound">Δ</a><a id="3342" class="Symbol">}{</a><a id="3344" href="/20.07/BigStep/#3344" class="Bound">δ</a> <a id="3346" class="Symbol">:</a> <a id="3348" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3356" href="/20.07/BigStep/#3341" class="Bound">Δ</a><a id="3357" class="Symbol">}{</a><a id="3359" href="/20.07/BigStep/#3359" class="Bound">N</a> <a id="3361" class="Symbol">:</a> <a id="3363" href="/20.07/BigStep/#3341" class="Bound">Δ</a> <a id="3365" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="3367" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="3369" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3371" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3372" class="Symbol">}{</a><a id="3374" href="/20.07/BigStep/#3374" class="Bound">V</a><a id="3375" class="Symbol">}</a>
    <a id="3381" class="Symbol">→</a> <a id="3383" href="/20.07/BigStep/#3313" class="Bound">γ</a> <a id="3385" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3387" href="/20.07/BigStep/#3328" class="Bound">L</a> <a id="3389" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3391" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3396" class="Symbol">(</a><a id="3397" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="3399" href="/20.07/BigStep/#3359" class="Bound">N</a><a id="3400" class="Symbol">)</a> <a id="3402" href="/20.07/BigStep/#3344" class="Bound">δ</a>   <a id="3406" class="Symbol">→</a>   <a id="3410" class="Symbol">(</a><a id="3411" href="/20.07/BigStep/#3344" class="Bound">δ</a> <a id="3413" href="/20.07/BigStep/#2672" class="Function Operator">,&#39;</a> <a id="3416" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3421" href="/20.07/BigStep/#3330" class="Bound">M</a> <a id="3423" href="/20.07/BigStep/#3313" class="Bound">γ</a><a id="3424" class="Symbol">)</a> <a id="3426" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3428" href="/20.07/BigStep/#3359" class="Bound">N</a> <a id="3430" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3432" href="/20.07/BigStep/#3374" class="Bound">V</a>
      <a id="3440" class="Comment">---------------------------------------------------</a>
    <a id="3496" class="Symbol">→</a> <a id="3498" href="/20.07/BigStep/#3313" class="Bound">γ</a> <a id="3500" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3502" href="/20.07/BigStep/#3328" class="Bound">L</a> <a id="3504" href="/20.07/Untyped/#4442" class="InductiveConstructor Operator">·</a> <a id="3506" href="/20.07/BigStep/#3330" class="Bound">M</a> <a id="3508" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3510" href="/20.07/BigStep/#3374" class="Bound">V</a>
</pre><ul><li><p>The <code class="language-plaintext highlighter-rouge">⇓-var</code> rule evaluates a variable by finding the associated closure in the environment and then evaluating the closure.</p></li><li><p>The <code class="language-plaintext highlighter-rouge">⇓-lam</code> rule turns a lambda abstraction into a closure by packaging it up with its environment.</p></li><li><p>The <code class="language-plaintext highlighter-rouge">⇓-app</code> rule performs function application by first evaluating the term <code class="language-plaintext highlighter-rouge">L</code> in operator position. If that produces a closure containing a lambda abstraction <code class="language-plaintext highlighter-rouge">ƛ N</code>, then we evaluate the body <code class="language-plaintext highlighter-rouge">N</code> in an environment extended with the argument <code class="language-plaintext highlighter-rouge">M</code>. Note that <code class="language-plaintext highlighter-rouge">M</code> is not evaluated in rule <code class="language-plaintext highlighter-rouge">⇓-app</code> because this is call-by-name and not call-by-value.</p></li></ul><h4 id="exercise-big-step-eg-practice">Exercise <code class="language-plaintext highlighter-rouge">big-step-eg</code> (practice)</h4><p>Show that <code class="language-plaintext highlighter-rouge">(ƛ ƛ # 1) · ((ƛ # 0 · # 0) · (ƛ # 0 · # 0))</code> terminates under big-step call-by-name evaluation.</p><pre class="Agda"><a id="4264" class="Comment">-- Your code goes here</a>
</pre><h2 id="the-big-step-semantics-is-deterministic">The big-step semantics is deterministic</h2><p>If the big-step relation evaluates a term <code class="language-plaintext highlighter-rouge">M</code> to both <code class="language-plaintext highlighter-rouge">V</code> and <code class="language-plaintext highlighter-rouge">V′</code>, then <code class="language-plaintext highlighter-rouge">V</code> and <code class="language-plaintext highlighter-rouge">V′</code> must be identical. In other words, the call-by-name relation is a partial function. The proof is a straightforward induction on the two big-step derivations.</p><pre class="Agda"><a id="⇓-determ"></a><a id="4586" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4595" class="Symbol">:</a> <a id="4597" class="Symbol">∀{</a><a id="4599" href="/20.07/BigStep/#4599" class="Bound">Γ</a><a id="4600" class="Symbol">}{</a><a id="4602" href="/20.07/BigStep/#4602" class="Bound">γ</a> <a id="4604" class="Symbol">:</a> <a id="4606" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="4614" href="/20.07/BigStep/#4599" class="Bound">Γ</a><a id="4615" class="Symbol">}{</a><a id="4617" href="/20.07/BigStep/#4617" class="Bound">M</a> <a id="4619" class="Symbol">:</a> <a id="4621" href="/20.07/BigStep/#4599" class="Bound">Γ</a> <a id="4623" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="4625" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="4626" class="Symbol">}{</a><a id="4628" href="/20.07/BigStep/#4628" class="Bound">V</a> <a id="4630" href="/20.07/BigStep/#4630" class="Bound">V&#39;</a> <a id="4633" class="Symbol">:</a> <a id="4635" href="/20.07/BigStep/#2467" class="Datatype">Clos</a><a id="4639" class="Symbol">}</a>
  <a id="4643" class="Symbol">→</a> <a id="4645" href="/20.07/BigStep/#4602" class="Bound">γ</a> <a id="4647" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="4649" href="/20.07/BigStep/#4617" class="Bound">M</a> <a id="4651" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="4653" href="/20.07/BigStep/#4628" class="Bound">V</a> <a id="4655" class="Symbol">→</a> <a id="4657" href="/20.07/BigStep/#4602" class="Bound">γ</a> <a id="4659" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="4661" href="/20.07/BigStep/#4617" class="Bound">M</a> <a id="4663" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="4665" href="/20.07/BigStep/#4630" class="Bound">V&#39;</a>
  <a id="4670" class="Symbol">→</a> <a id="4672" href="/20.07/BigStep/#4628" class="Bound">V</a> <a id="4674" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4676" href="/20.07/BigStep/#4630" class="Bound">V&#39;</a>
<a id="4679" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4688" class="Symbol">(</a><a id="4689" href="/20.07/BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="4695" href="/20.07/BigStep/#4695" class="Bound">eq1</a> <a id="4699" href="/20.07/BigStep/#4699" class="Bound">mc</a><a id="4701" class="Symbol">)</a> <a id="4703" class="Symbol">(</a><a id="4704" href="/20.07/BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="4710" href="/20.07/BigStep/#4710" class="Bound">eq2</a> <a id="4714" href="/20.07/BigStep/#4714" class="Bound">mc&#39;</a><a id="4717" class="Symbol">)</a>
    <a id="4723" class="Keyword">with</a> <a id="4728" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#984" class="Function">trans</a> <a id="4734" class="Symbol">(</a><a id="4735" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="4739" href="/20.07/BigStep/#4695" class="Bound">eq1</a><a id="4742" class="Symbol">)</a> <a id="4744" href="/20.07/BigStep/#4710" class="Bound">eq2</a>
<a id="4748" class="Symbol">...</a> <a id="4752" class="Symbol">|</a> <a id="4754" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="4759" class="Symbol">=</a> <a id="4761" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4770" class="Bound">mc</a> <a id="4773" class="Bound">mc&#39;</a>
<a id="4777" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4786" href="/20.07/BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="4792" href="/20.07/BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="4798" class="Symbol">=</a> <a id="4800" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="4805" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4814" class="Symbol">(</a><a id="4815" href="/20.07/BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="4821" href="/20.07/BigStep/#4821" class="Bound">mc</a> <a id="4824" href="/20.07/BigStep/#4824" class="Bound">mc₁</a><a id="4827" class="Symbol">)</a> <a id="4829" class="Symbol">(</a><a id="4830" href="/20.07/BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="4836" href="/20.07/BigStep/#4836" class="Bound">mc&#39;</a> <a id="4840" href="/20.07/BigStep/#4840" class="Bound">mc&#39;&#39;</a><a id="4844" class="Symbol">)</a>
    <a id="4850" class="Keyword">with</a> <a id="4855" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4864" href="/20.07/BigStep/#4821" class="Bound">mc</a> <a id="4867" href="/20.07/BigStep/#4836" class="Bound">mc&#39;</a>
<a id="4871" class="Symbol">...</a> <a id="4875" class="Symbol">|</a> <a id="4877" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="4882" class="Symbol">=</a> <a id="4884" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4893" class="Bound">mc₁</a> <a id="4897" class="Bound">mc&#39;&#39;</a>
</pre><h2 id="big-step-evaluation-implies-beta-reduction-to-a-lambda">Big-step evaluation implies beta reduction to a lambda</h2><p>If big-step evaluation produces a value, then the input term can reduce to a lambda abstraction by beta reduction:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ∅' ⊢ M ⇓ clos (ƛ N′) δ
  -----------------------------
→ Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N)
</code></pre></div></div><p>The proof is by induction on the big-step derivation. As is often necessary, one must generalize the statement to get the induction to go through. In the case for <code class="language-plaintext highlighter-rouge">⇓-app</code> (function application), the argument is added to the environment, so the environment becomes non-empty. The corresponding β reduction substitutes the argument into the body of the lambda abstraction. So we generalize the lemma to allow an arbitrary environment <code class="language-plaintext highlighter-rouge">γ</code> and we add a premise that relates the environment <code class="language-plaintext highlighter-rouge">γ</code> to an equivalent substitution <code class="language-plaintext highlighter-rouge">σ</code>.</p><p>The case for <code class="language-plaintext highlighter-rouge">⇓-app</code> also requires that we strengthen the conclusion. In the case for <code class="language-plaintext highlighter-rouge">⇓-app</code> we have <code class="language-plaintext highlighter-rouge">γ ⊢ L ⇓ clos (λ N) δ</code> and the induction hypothesis gives us <code class="language-plaintext highlighter-rouge">L —↠ ƛ N′</code>, but we need to know that <code class="language-plaintext highlighter-rouge">N</code> and <code class="language-plaintext highlighter-rouge">N′</code> are equivalent. In particular, that <code class="language-plaintext highlighter-rouge">N′ ≡ subst τ N</code> where <code class="language-plaintext highlighter-rouge">τ</code> is the substitution that is equivalent to <code class="language-plaintext highlighter-rouge">δ</code>. Therefore we expand the conclusion of the statement, stating that the results are equivalent.</p><p>We make the two notions of equivalence precise by defining the following two mutually-recursive predicates <code class="language-plaintext highlighter-rouge">V ≈ M</code> and <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>.</p><pre class="Agda"><a id="_≈_"></a><a id="6265" href="/20.07/BigStep/#6265" class="Function Operator">_≈_</a> <a id="6269" class="Symbol">:</a> <a id="6271" href="/20.07/BigStep/#2467" class="Datatype">Clos</a> <a id="6276" class="Symbol">→</a> <a id="6278" class="Symbol">(</a><a id="6279" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="6281" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="6283" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="6284" class="Symbol">)</a> <a id="6286" class="Symbol">→</a> <a id="6288" class="PrimitiveType">Set</a>
<a id="_≈ₑ_"></a><a id="6292" href="/20.07/BigStep/#6292" class="Function Operator">_≈ₑ_</a> <a id="6297" class="Symbol">:</a> <a id="6299" class="Symbol">∀{</a><a id="6301" href="/20.07/BigStep/#6301" class="Bound">Γ</a><a id="6302" class="Symbol">}</a> <a id="6304" class="Symbol">→</a> <a id="6306" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="6314" href="/20.07/BigStep/#6301" class="Bound">Γ</a> <a id="6316" class="Symbol">→</a> <a id="6318" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="6324" href="/20.07/BigStep/#6301" class="Bound">Γ</a> <a id="6326" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="6328" class="Symbol">→</a> <a id="6330" class="PrimitiveType">Set</a>

<a id="6335" class="Symbol">(</a><a id="6336" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="6341" class="Symbol">{</a><a id="6342" href="/20.07/BigStep/#6342" class="Bound">Γ</a><a id="6343" class="Symbol">}</a> <a id="6345" href="/20.07/BigStep/#6345" class="Bound">M</a> <a id="6347" href="/20.07/BigStep/#6347" class="Bound">γ</a><a id="6348" class="Symbol">)</a> <a id="6350" href="/20.07/BigStep/#6265" class="Function Operator">≈</a> <a id="6352" href="/20.07/BigStep/#6352" class="Bound">N</a> <a id="6354" class="Symbol">=</a> <a id="6356" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="6359" href="/20.07/BigStep/#6359" class="Bound">σ</a> <a id="6361" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="6363" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="6369" href="/20.07/BigStep/#6342" class="Bound">Γ</a> <a id="6371" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="6373" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="6375" href="/20.07/BigStep/#6347" class="Bound">γ</a> <a id="6377" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6380" href="/20.07/BigStep/#6359" class="Bound">σ</a> <a id="6382" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">×</a> <a id="6384" class="Symbol">(</a><a id="6385" href="/20.07/BigStep/#6352" class="Bound">N</a> <a id="6387" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="6389" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="6395" href="/20.07/BigStep/#6359" class="Bound">σ</a> <a id="6397" href="/20.07/BigStep/#6345" class="Bound">M</a><a id="6398" class="Symbol">)</a>

<a id="6401" href="/20.07/BigStep/#6401" class="Bound">γ</a> <a id="6403" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6406" href="/20.07/BigStep/#6406" class="Bound">σ</a> <a id="6408" class="Symbol">=</a> <a id="6410" class="Symbol">∀{</a><a id="6412" href="/20.07/BigStep/#6412" class="Bound">x</a><a id="6413" class="Symbol">}</a> <a id="6415" class="Symbol">→</a> <a id="6417" class="Symbol">(</a><a id="6418" href="/20.07/BigStep/#6401" class="Bound">γ</a> <a id="6420" href="/20.07/BigStep/#6412" class="Bound">x</a><a id="6421" class="Symbol">)</a> <a id="6423" href="/20.07/BigStep/#6265" class="Function Operator">≈</a> <a id="6425" class="Symbol">(</a><a id="6426" href="/20.07/BigStep/#6406" class="Bound">σ</a> <a id="6428" href="/20.07/BigStep/#6412" class="Bound">x</a><a id="6429" class="Symbol">)</a>
</pre><p>We can now state the main lemma:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If γ ⊢ M ⇓ V  and  γ ≈ₑ σ,
then  subst σ M —↠ N  and  V ≈ N  for some N.
</code></pre></div></div><p>Before starting the proof, we establish a couple lemmas about equivalent environments and substitutions.</p><p>The empty environment is equivalent to the identity substitution <code class="language-plaintext highlighter-rouge">ids</code>, which we import from Chapter <a href="/20.07/Substitution/">Substitution</a>.</p><pre class="Agda"><a id="≈ₑ-id"></a><a id="6814" href="/20.07/BigStep/#6814" class="Function">≈ₑ-id</a> <a id="6820" class="Symbol">:</a> <a id="6822" href="/20.07/BigStep/#2650" class="Function">∅&#39;</a> <a id="6825" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6828" href="/20.07/Substitution/#3046" class="Function">ids</a>
<a id="6832" href="/20.07/BigStep/#6814" class="Function">≈ₑ-id</a> <a id="6838" class="Symbol">{()}</a>
</pre><p>Of course, applying the identity substitution to a term returns the same term.</p><pre class="Agda"><a id="sub-id"></a><a id="6932" href="/20.07/BigStep/#6932" class="Function">sub-id</a> <a id="6939" class="Symbol">:</a> <a id="6941" class="Symbol">∀{</a><a id="6943" href="/20.07/BigStep/#6943" class="Bound">Γ</a><a id="6944" class="Symbol">}</a> <a id="6946" class="Symbol">{</a><a id="6947" href="/20.07/BigStep/#6947" class="Bound">A</a><a id="6948" class="Symbol">}</a> <a id="6950" class="Symbol">{</a><a id="6951" href="/20.07/BigStep/#6951" class="Bound">M</a> <a id="6953" class="Symbol">:</a> <a id="6955" href="/20.07/BigStep/#6943" class="Bound">Γ</a> <a id="6957" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="6959" href="/20.07/BigStep/#6947" class="Bound">A</a><a id="6960" class="Symbol">}</a> <a id="6962" class="Symbol">→</a> <a id="6964" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="6970" href="/20.07/Substitution/#3046" class="Function">ids</a> <a id="6974" href="/20.07/BigStep/#6951" class="Bound">M</a> <a id="6976" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="6978" href="/20.07/BigStep/#6951" class="Bound">M</a>
<a id="6980" href="/20.07/BigStep/#6932" class="Function">sub-id</a> <a id="6987" class="Symbol">=</a> <a id="6989" href="/20.07/Substitution/#16936" class="Function">plfa.part2.Substitution.sub-id</a>
</pre><p>We define an auxilliary function for extending a substitution.</p><pre class="Agda"><a id="ext-subst"></a><a id="7094" href="/20.07/BigStep/#7094" class="Function">ext-subst</a> <a id="7104" class="Symbol">:</a> <a id="7106" class="Symbol">∀{</a><a id="7108" href="/20.07/BigStep/#7108" class="Bound">Γ</a> <a id="7110" href="/20.07/BigStep/#7110" class="Bound">Δ</a><a id="7111" class="Symbol">}</a> <a id="7113" class="Symbol">→</a> <a id="7115" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="7121" href="/20.07/BigStep/#7108" class="Bound">Γ</a> <a id="7123" href="/20.07/BigStep/#7110" class="Bound">Δ</a> <a id="7125" class="Symbol">→</a> <a id="7127" href="/20.07/BigStep/#7110" class="Bound">Δ</a> <a id="7129" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="7131" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="7133" class="Symbol">→</a> <a id="7135" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="7141" class="Symbol">(</a><a id="7142" href="/20.07/BigStep/#7108" class="Bound">Γ</a> <a id="7144" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="7146" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="7147" class="Symbol">)</a> <a id="7149" href="/20.07/BigStep/#7110" class="Bound">Δ</a>
<a id="7151" href="/20.07/BigStep/#7094" class="Function">ext-subst</a><a id="7160" class="Symbol">{</a><a id="7161" href="/20.07/BigStep/#7161" class="Bound">Γ</a><a id="7162" class="Symbol">}{</a><a id="7164" href="/20.07/BigStep/#7164" class="Bound">Δ</a><a id="7165" class="Symbol">}</a> <a id="7167" href="/20.07/BigStep/#7167" class="Bound">σ</a> <a id="7169" href="/20.07/BigStep/#7169" class="Bound">N</a> <a id="7171" class="Symbol">{</a><a id="7172" href="/20.07/BigStep/#7172" class="Bound">A</a><a id="7173" class="Symbol">}</a> <a id="7175" class="Symbol">=</a> <a id="7177" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="7183" class="Symbol">(</a><a id="7184" href="/20.07/Untyped/#7375" class="Function">subst-zero</a> <a id="7195" href="/20.07/BigStep/#7169" class="Bound">N</a><a id="7196" class="Symbol">)</a> <a id="7198" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="7200" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="7205" href="/20.07/BigStep/#7167" class="Bound">σ</a>
</pre><p>The next lemma we need to prove states that if you start with an equivalent environment and substitution <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>, extending them with an equivalent closure and term <code class="language-plaintext highlighter-rouge">c ≈ N</code> produces an equivalent environment and substitution: <code class="language-plaintext highlighter-rouge">(γ ,' V) ≈ₑ (ext-subst σ N)</code>, or equivalently, <code class="language-plaintext highlighter-rouge">(γ ,' V) x ≈ₑ (ext-subst σ N) x</code> for any variable <code class="language-plaintext highlighter-rouge">x</code>. The proof will be by induction on <code class="language-plaintext highlighter-rouge">x</code> and for the induction step we need the following lemma, which states that applying the composition of <code class="language-plaintext highlighter-rouge">exts σ</code> and <code class="language-plaintext highlighter-rouge">subst-zero</code> to <code class="language-plaintext highlighter-rouge">S x</code> is the same as just <code class="language-plaintext highlighter-rouge">σ x</code>, which is a corollary of a theorem in Chapter <a href="/20.07/Substitution/">Substitution</a>.</p><pre class="Agda"><a id="subst-zero-exts"></a><a id="7845" href="/20.07/BigStep/#7845" class="Function">subst-zero-exts</a> <a id="7861" class="Symbol">:</a> <a id="7863" class="Symbol">∀{</a><a id="7865" href="/20.07/BigStep/#7865" class="Bound">Γ</a> <a id="7867" href="/20.07/BigStep/#7867" class="Bound">Δ</a><a id="7868" class="Symbol">}{</a><a id="7870" href="/20.07/BigStep/#7870" class="Bound">σ</a> <a id="7872" class="Symbol">:</a> <a id="7874" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="7880" href="/20.07/BigStep/#7865" class="Bound">Γ</a> <a id="7882" href="/20.07/BigStep/#7867" class="Bound">Δ</a><a id="7883" class="Symbol">}{</a><a id="7885" href="/20.07/BigStep/#7885" class="Bound">B</a><a id="7886" class="Symbol">}{</a><a id="7888" href="/20.07/BigStep/#7888" class="Bound">M</a> <a id="7890" class="Symbol">:</a> <a id="7892" href="/20.07/BigStep/#7867" class="Bound">Δ</a> <a id="7894" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="7896" href="/20.07/BigStep/#7885" class="Bound">B</a><a id="7897" class="Symbol">}{</a><a id="7899" href="/20.07/BigStep/#7899" class="Bound">x</a> <a id="7901" class="Symbol">:</a> <a id="7903" href="/20.07/BigStep/#7865" class="Bound">Γ</a> <a id="7905" href="/20.07/Untyped/#3521" class="Datatype Operator">∋</a> <a id="7907" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="7908" class="Symbol">}</a>
  <a id="7912" class="Symbol">→</a> <a id="7914" class="Symbol">(</a><a id="7915" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="7921" class="Symbol">(</a><a id="7922" href="/20.07/Untyped/#7375" class="Function">subst-zero</a> <a id="7933" href="/20.07/BigStep/#7888" class="Bound">M</a><a id="7934" class="Symbol">)</a> <a id="7936" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="7938" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="7943" href="/20.07/BigStep/#7870" class="Bound">σ</a><a id="7944" class="Symbol">)</a> <a id="7946" class="Symbol">(</a><a id="7947" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S</a> <a id="7949" href="/20.07/BigStep/#7899" class="Bound">x</a><a id="7950" class="Symbol">)</a> <a id="7952" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="7954" href="/20.07/BigStep/#7870" class="Bound">σ</a> <a id="7956" href="/20.07/BigStep/#7899" class="Bound">x</a>
<a id="7958" href="/20.07/BigStep/#7845" class="Function">subst-zero-exts</a> <a id="7974" class="Symbol">{</a><a id="7975" href="/20.07/BigStep/#7975" class="Bound">Γ</a><a id="7976" class="Symbol">}{</a><a id="7978" href="/20.07/BigStep/#7978" class="Bound">Δ</a><a id="7979" class="Symbol">}{</a><a id="7981" href="/20.07/BigStep/#7981" class="Bound">σ</a><a id="7982" class="Symbol">}{</a><a id="7984" href="/20.07/BigStep/#7984" class="Bound">B</a><a id="7985" class="Symbol">}{</a><a id="7987" href="/20.07/BigStep/#7987" class="Bound">M</a><a id="7988" class="Symbol">}{</a><a id="7990" href="/20.07/BigStep/#7990" class="Bound">x</a><a id="7991" class="Symbol">}</a> <a id="7993" class="Symbol">=</a>
   <a id="7998" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="8007" class="Symbol">(</a><a id="8008" href="/20.07/Substitution/#25138" class="Function">plfa.part2.Substitution.subst-zero-exts-cons</a><a id="8052" class="Symbol">{</a><a id="8053" class="Argument">σ</a> <a id="8055" class="Symbol">=</a> <a id="8057" href="/20.07/BigStep/#7981" class="Bound">σ</a><a id="8058" class="Symbol">})</a> <a id="8061" class="Symbol">(</a><a id="8062" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S</a> <a id="8064" href="/20.07/BigStep/#7990" class="Bound">x</a><a id="8065" class="Symbol">)</a>
</pre><p>So the proof of <code class="language-plaintext highlighter-rouge">≈ₑ-ext</code> is as follows.</p><pre class="Agda"><a id="≈ₑ-ext"></a><a id="8117" href="/20.07/BigStep/#8117" class="Function">≈ₑ-ext</a> <a id="8124" class="Symbol">:</a> <a id="8126" class="Symbol">∀</a> <a id="8128" class="Symbol">{</a><a id="8129" href="/20.07/BigStep/#8129" class="Bound">Γ</a><a id="8130" class="Symbol">}</a> <a id="8132" class="Symbol">{</a><a id="8133" href="/20.07/BigStep/#8133" class="Bound">γ</a> <a id="8135" class="Symbol">:</a> <a id="8137" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="8145" href="/20.07/BigStep/#8129" class="Bound">Γ</a><a id="8146" class="Symbol">}</a> <a id="8148" class="Symbol">{</a><a id="8149" href="/20.07/BigStep/#8149" class="Bound">σ</a> <a id="8151" class="Symbol">:</a> <a id="8153" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="8159" href="/20.07/BigStep/#8129" class="Bound">Γ</a> <a id="8161" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a><a id="8162" class="Symbol">}</a> <a id="8164" class="Symbol">{</a><a id="8165" href="/20.07/BigStep/#8165" class="Bound">V</a><a id="8166" class="Symbol">}</a> <a id="8168" class="Symbol">{</a><a id="8169" href="/20.07/BigStep/#8169" class="Bound">N</a> <a id="8171" class="Symbol">:</a> <a id="8173" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="8175" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="8177" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="8178" class="Symbol">}</a>
  <a id="8182" class="Symbol">→</a> <a id="8184" href="/20.07/BigStep/#8133" class="Bound">γ</a> <a id="8186" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="8189" href="/20.07/BigStep/#8149" class="Bound">σ</a>  <a id="8192" class="Symbol">→</a>  <a id="8195" href="/20.07/BigStep/#8165" class="Bound">V</a> <a id="8197" href="/20.07/BigStep/#6265" class="Function Operator">≈</a> <a id="8199" href="/20.07/BigStep/#8169" class="Bound">N</a>
    <a id="8205" class="Comment">--------------------------</a>
  <a id="8234" class="Symbol">→</a> <a id="8236" class="Symbol">(</a><a id="8237" href="/20.07/BigStep/#8133" class="Bound">γ</a> <a id="8239" href="/20.07/BigStep/#2672" class="Function Operator">,&#39;</a> <a id="8242" href="/20.07/BigStep/#8165" class="Bound">V</a><a id="8243" class="Symbol">)</a> <a id="8245" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="8248" class="Symbol">(</a><a id="8249" href="/20.07/BigStep/#7094" class="Function">ext-subst</a> <a id="8259" href="/20.07/BigStep/#8149" class="Bound">σ</a> <a id="8261" href="/20.07/BigStep/#8169" class="Bound">N</a><a id="8262" class="Symbol">)</a>
<a id="8264" href="/20.07/BigStep/#8117" class="Function">≈ₑ-ext</a> <a id="8271" class="Symbol">{</a><a id="8272" href="/20.07/BigStep/#8272" class="Bound">Γ</a><a id="8273" class="Symbol">}</a> <a id="8275" class="Symbol">{</a><a id="8276" href="/20.07/BigStep/#8276" class="Bound">γ</a><a id="8277" class="Symbol">}</a> <a id="8279" class="Symbol">{</a><a id="8280" href="/20.07/BigStep/#8280" class="Bound">σ</a><a id="8281" class="Symbol">}</a> <a id="8283" class="Symbol">{</a><a id="8284" href="/20.07/BigStep/#8284" class="Bound">V</a><a id="8285" class="Symbol">}</a> <a id="8287" class="Symbol">{</a><a id="8288" href="/20.07/BigStep/#8288" class="Bound">N</a><a id="8289" class="Symbol">}</a> <a id="8291" href="/20.07/BigStep/#8291" class="Bound">γ≈ₑσ</a> <a id="8296" href="/20.07/BigStep/#8296" class="Bound">V≈N</a> <a id="8300" class="Symbol">{</a><a id="8301" href="/20.07/Untyped/#3557" class="InductiveConstructor">Z</a><a id="8302" class="Symbol">}</a> <a id="8304" class="Symbol">=</a> <a id="8306" href="/20.07/BigStep/#8296" class="Bound">V≈N</a>
<a id="8310" href="/20.07/BigStep/#8117" class="Function">≈ₑ-ext</a> <a id="8317" class="Symbol">{</a><a id="8318" href="/20.07/BigStep/#8318" class="Bound">Γ</a><a id="8319" class="Symbol">}</a> <a id="8321" class="Symbol">{</a><a id="8322" href="/20.07/BigStep/#8322" class="Bound">γ</a><a id="8323" class="Symbol">}</a> <a id="8325" class="Symbol">{</a><a id="8326" href="/20.07/BigStep/#8326" class="Bound">σ</a><a id="8327" class="Symbol">}</a> <a id="8329" class="Symbol">{</a><a id="8330" href="/20.07/BigStep/#8330" class="Bound">V</a><a id="8331" class="Symbol">}</a> <a id="8333" class="Symbol">{</a><a id="8334" href="/20.07/BigStep/#8334" class="Bound">N</a><a id="8335" class="Symbol">}</a> <a id="8337" href="/20.07/BigStep/#8337" class="Bound">γ≈ₑσ</a> <a id="8342" href="/20.07/BigStep/#8342" class="Bound">V≈N</a> <a id="8346" class="Symbol">{</a><a id="8347" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S</a> <a id="8349" href="/20.07/BigStep/#8349" class="Bound">x</a><a id="8350" class="Symbol">}</a>
  <a id="8354" class="Keyword">rewrite</a> <a id="8362" href="/20.07/BigStep/#7845" class="Function">subst-zero-exts</a> <a id="8378" class="Symbol">{</a><a id="8379" class="Argument">σ</a> <a id="8381" class="Symbol">=</a> <a id="8383" href="/20.07/BigStep/#8326" class="Bound">σ</a><a id="8384" class="Symbol">}{</a><a id="8386" class="Argument">M</a> <a id="8388" class="Symbol">=</a> <a id="8390" href="/20.07/BigStep/#8334" class="Bound">N</a><a id="8391" class="Symbol">}{</a><a id="8393" href="/20.07/BigStep/#8349" class="Bound">x</a><a id="8394" class="Symbol">}</a> <a id="8396" class="Symbol">=</a> <a id="8398" href="/20.07/BigStep/#8337" class="Bound">γ≈ₑσ</a>
</pre><p>We proceed by induction on the input variable.</p><ul><li><p>If it is <code class="language-plaintext highlighter-rouge">Z</code>, then we immediately conclude using the premise <code class="language-plaintext highlighter-rouge">V ≈ N</code>.</p></li><li><p>If it is <code class="language-plaintext highlighter-rouge">S x</code>, then we rewrite using the <code class="language-plaintext highlighter-rouge">subst-zero-exts</code> lemma and use the premise <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code> to conclude.</p></li></ul><p>To prove the main lemma, we need another technical lemma about substitution. Applying one substitution after another is the same as composing the two substitutions and then applying them.</p><pre class="Agda"><a id="sub-sub"></a><a id="8840" href="/20.07/BigStep/#8840" class="Function">sub-sub</a> <a id="8848" class="Symbol">:</a> <a id="8850" class="Symbol">∀{</a><a id="8852" href="/20.07/BigStep/#8852" class="Bound">Γ</a> <a id="8854" href="/20.07/BigStep/#8854" class="Bound">Δ</a> <a id="8856" href="/20.07/BigStep/#8856" class="Bound">Σ</a><a id="8857" class="Symbol">}{</a><a id="8859" href="/20.07/BigStep/#8859" class="Bound">A</a><a id="8860" class="Symbol">}{</a><a id="8862" href="/20.07/BigStep/#8862" class="Bound">M</a> <a id="8864" class="Symbol">:</a> <a id="8866" href="/20.07/BigStep/#8852" class="Bound">Γ</a> <a id="8868" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="8870" href="/20.07/BigStep/#8859" class="Bound">A</a><a id="8871" class="Symbol">}</a> <a id="8873" class="Symbol">{</a><a id="8874" href="/20.07/BigStep/#8874" class="Bound">σ₁</a> <a id="8877" class="Symbol">:</a> <a id="8879" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="8885" href="/20.07/BigStep/#8852" class="Bound">Γ</a> <a id="8887" href="/20.07/BigStep/#8854" class="Bound">Δ</a><a id="8888" class="Symbol">}{</a><a id="8890" href="/20.07/BigStep/#8890" class="Bound">σ₂</a> <a id="8893" class="Symbol">:</a> <a id="8895" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="8901" href="/20.07/BigStep/#8854" class="Bound">Δ</a> <a id="8903" href="/20.07/BigStep/#8856" class="Bound">Σ</a><a id="8904" class="Symbol">}</a>
  <a id="8908" class="Symbol">→</a> <a id="8910" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="8916" href="/20.07/BigStep/#8890" class="Bound">σ₂</a> <a id="8919" class="Symbol">(</a><a id="8920" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="8926" href="/20.07/BigStep/#8874" class="Bound">σ₁</a> <a id="8929" href="/20.07/BigStep/#8862" class="Bound">M</a><a id="8930" class="Symbol">)</a> <a id="8932" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8934" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="8940" class="Symbol">(</a><a id="8941" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="8947" href="/20.07/BigStep/#8890" class="Bound">σ₂</a> <a id="8950" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="8952" href="/20.07/BigStep/#8874" class="Bound">σ₁</a><a id="8954" class="Symbol">)</a> <a id="8956" href="/20.07/BigStep/#8862" class="Bound">M</a>
<a id="8958" href="/20.07/BigStep/#8840" class="Function">sub-sub</a> <a id="8966" class="Symbol">{</a><a id="8967" class="Argument">M</a> <a id="8969" class="Symbol">=</a> <a id="8971" href="/20.07/BigStep/#8971" class="Bound">M</a><a id="8972" class="Symbol">}</a> <a id="8974" class="Symbol">=</a> <a id="8976" href="/20.07/Substitution/#22915" class="Function">plfa.part2.Substitution.sub-sub</a> <a id="9008" class="Symbol">{</a><a id="9009" class="Argument">M</a> <a id="9011" class="Symbol">=</a> <a id="9013" href="/20.07/BigStep/#8971" class="Bound">M</a><a id="9014" class="Symbol">}</a>
</pre><p>We arive at the main lemma: if <code class="language-plaintext highlighter-rouge">M</code> big steps to a closure <code class="language-plaintext highlighter-rouge">V</code> in environment <code class="language-plaintext highlighter-rouge">γ</code>, and if <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>, then <code class="language-plaintext highlighter-rouge">subst σ M</code> reduces to some term <code class="language-plaintext highlighter-rouge">N</code> that is equivalent to <code class="language-plaintext highlighter-rouge">V</code>. We describe the proof below.</p><pre class="Agda"><a id="⇓→—↠×≈"></a><a id="9223" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a> <a id="9230" class="Symbol">:</a> <a id="9232" class="Symbol">∀{</a><a id="9234" href="/20.07/BigStep/#9234" class="Bound">Γ</a><a id="9235" class="Symbol">}{</a><a id="9237" href="/20.07/BigStep/#9237" class="Bound">γ</a> <a id="9239" class="Symbol">:</a> <a id="9241" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="9249" href="/20.07/BigStep/#9234" class="Bound">Γ</a><a id="9250" class="Symbol">}{</a><a id="9252" href="/20.07/BigStep/#9252" class="Bound">σ</a> <a id="9254" class="Symbol">:</a> <a id="9256" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="9262" href="/20.07/BigStep/#9234" class="Bound">Γ</a> <a id="9264" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a><a id="9265" class="Symbol">}{</a><a id="9267" href="/20.07/BigStep/#9267" class="Bound">M</a> <a id="9269" class="Symbol">:</a> <a id="9271" href="/20.07/BigStep/#9234" class="Bound">Γ</a> <a id="9273" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="9275" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="9276" class="Symbol">}{</a><a id="9278" href="/20.07/BigStep/#9278" class="Bound">V</a> <a id="9280" class="Symbol">:</a> <a id="9282" href="/20.07/BigStep/#2467" class="Datatype">Clos</a><a id="9286" class="Symbol">}</a>
       <a id="9295" class="Symbol">→</a> <a id="9297" href="/20.07/BigStep/#9237" class="Bound">γ</a> <a id="9299" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="9301" href="/20.07/BigStep/#9267" class="Bound">M</a> <a id="9303" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="9305" href="/20.07/BigStep/#9278" class="Bound">V</a>  <a id="9308" class="Symbol">→</a>  <a id="9311" href="/20.07/BigStep/#9237" class="Bound">γ</a> <a id="9313" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="9316" href="/20.07/BigStep/#9252" class="Bound">σ</a>
         <a id="9327" class="Comment">---------------------------------------</a>
       <a id="9374" class="Symbol">→</a> <a id="9376" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="9379" href="/20.07/BigStep/#9379" class="Bound">N</a> <a id="9381" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="9383" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="9385" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="9387" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="9389" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="9391" class="Symbol">(</a><a id="9392" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="9398" href="/20.07/BigStep/#9252" class="Bound">σ</a> <a id="9400" href="/20.07/BigStep/#9267" class="Bound">M</a> <a id="9402" href="/20.07/Untyped/#11068" class="Datatype Operator">—↠</a> <a id="9405" href="/20.07/BigStep/#9379" class="Bound">N</a><a id="9406" class="Symbol">)</a> <a id="9408" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">×</a> <a id="9410" href="/20.07/BigStep/#9278" class="Bound">V</a> <a id="9412" href="/20.07/BigStep/#6265" class="Function Operator">≈</a> <a id="9414" href="/20.07/BigStep/#9379" class="Bound">N</a>
<a id="9416" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a> <a id="9423" class="Symbol">{</a><a id="9424" class="Argument">γ</a> <a id="9426" class="Symbol">=</a> <a id="9428" href="/20.07/BigStep/#9428" class="Bound">γ</a><a id="9429" class="Symbol">}</a> <a id="9431" class="Symbol">(</a><a id="9432" href="/20.07/BigStep/#3078" class="InductiveConstructor">⇓-var</a><a id="9437" class="Symbol">{</a><a id="9438" class="Argument">x</a> <a id="9440" class="Symbol">=</a> <a id="9442" href="/20.07/BigStep/#9442" class="Bound">x</a><a id="9443" class="Symbol">}</a> <a id="9445" href="/20.07/BigStep/#9445" class="Bound">γx≡Lδ</a> <a id="9451" href="/20.07/BigStep/#9451" class="Bound">δ⊢L⇓V</a><a id="9456" class="Symbol">)</a> <a id="9458" href="/20.07/BigStep/#9458" class="Bound">γ≈ₑσ</a>
    <a id="9467" class="Keyword">with</a> <a id="9472" href="/20.07/BigStep/#9428" class="Bound">γ</a> <a id="9474" href="/20.07/BigStep/#9442" class="Bound">x</a> <a id="9476" class="Symbol">|</a> <a id="9478" href="/20.07/BigStep/#9458" class="Bound">γ≈ₑσ</a> <a id="9483" class="Symbol">{</a><a id="9484" href="/20.07/BigStep/#9442" class="Bound">x</a><a id="9485" class="Symbol">}</a> <a id="9487" class="Symbol">|</a> <a id="9489" href="/20.07/BigStep/#9445" class="Bound">γx≡Lδ</a>
<a id="9495" class="Symbol">...</a> <a id="9499" class="Symbol">|</a> <a id="9501" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="9506" href="/20.07/BigStep/#9506" class="Bound">L</a> <a id="9508" href="/20.07/BigStep/#9508" class="Bound">δ</a> <a id="9510" class="Symbol">|</a> <a id="9512" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9514" href="/20.07/BigStep/#9514" class="Bound">τ</a> <a id="9516" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9518" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9520" href="/20.07/BigStep/#9520" class="Bound">δ≈ₑτ</a> <a id="9525" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9527" href="/20.07/BigStep/#9527" class="Bound">σx≡τL</a> <a id="9533" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9535" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9537" class="Symbol">|</a> <a id="9539" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
      <a id="9550" class="Keyword">with</a> <a id="9555" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a><a id="9561" class="Symbol">{</a><a id="9562" class="Argument">σ</a> <a id="9564" class="Symbol">=</a> <a id="9566" href="/20.07/BigStep/#9514" class="Bound">τ</a><a id="9567" class="Symbol">}</a> <a id="9569" class="Bound">δ⊢L⇓V</a> <a id="9575" href="/20.07/BigStep/#9520" class="Bound">δ≈ₑτ</a>
<a id="9580" class="Symbol">...</a>   <a id="9586" class="Symbol">|</a> <a id="9588" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9590" href="/20.07/BigStep/#9590" class="Bound">N</a> <a id="9592" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9594" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9596" href="/20.07/BigStep/#9596" class="Bound">τL—↠N</a> <a id="9602" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9604" href="/20.07/BigStep/#9604" class="Bound">V≈N</a> <a id="9608" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9610" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9612" class="Keyword">rewrite</a> <a id="9620" class="Bound">σx≡τL</a> <a id="9626" class="Symbol">=</a>
        <a id="9636" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9638" href="/20.07/BigStep/#9590" class="Bound">N</a> <a id="9640" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9642" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9644" href="/20.07/BigStep/#9596" class="Bound">τL—↠N</a> <a id="9650" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9652" href="/20.07/BigStep/#9604" class="Bound">V≈N</a> <a id="9656" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9658" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
<a id="9660" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a> <a id="9667" class="Symbol">{</a><a id="9668" class="Argument">σ</a> <a id="9670" class="Symbol">=</a> <a id="9672" href="/20.07/BigStep/#9672" class="Bound">σ</a><a id="9673" class="Symbol">}</a> <a id="9675" class="Symbol">{</a><a id="9676" class="Argument">V</a> <a id="9678" class="Symbol">=</a> <a id="9680" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="9685" class="Symbol">(</a><a id="9686" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="9688" href="/20.07/BigStep/#9688" class="Bound">N</a><a id="9689" class="Symbol">)</a> <a id="9691" href="/20.07/BigStep/#9691" class="Bound">γ</a><a id="9692" class="Symbol">}</a> <a id="9694" class="Symbol">(</a><a id="9695" href="/20.07/BigStep/#3225" class="InductiveConstructor">⇓-lam</a><a id="9700" class="Symbol">)</a> <a id="9702" href="/20.07/BigStep/#9702" class="Bound">γ≈ₑσ</a> <a id="9707" class="Symbol">=</a>
    <a id="9713" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9715" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="9721" href="/20.07/BigStep/#9672" class="Bound">σ</a> <a id="9723" class="Symbol">(</a><a id="9724" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="9726" href="/20.07/BigStep/#9688" class="Bound">N</a><a id="9727" class="Symbol">)</a> <a id="9729" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9731" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9733" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="9739" href="/20.07/BigStep/#9672" class="Bound">σ</a> <a id="9741" class="Symbol">(</a><a id="9742" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="9744" href="/20.07/BigStep/#9688" class="Bound">N</a><a id="9745" class="Symbol">)</a> <a id="9747" href="/20.07/Untyped/#11118" class="InductiveConstructor Operator">∎</a> <a id="9749" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9751" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9753" href="/20.07/BigStep/#9672" class="Bound">σ</a> <a id="9755" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9757" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9759" href="/20.07/BigStep/#9702" class="Bound">γ≈ₑσ</a> <a id="9764" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9766" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="9771" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9773" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9775" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9777" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
<a id="9779" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a><a id="9785" class="Symbol">{</a><a id="9786" href="/20.07/BigStep/#9786" class="Bound">Γ</a><a id="9787" class="Symbol">}{</a><a id="9789" href="/20.07/BigStep/#9789" class="Bound">γ</a><a id="9790" class="Symbol">}</a> <a id="9792" class="Symbol">{</a><a id="9793" class="Argument">σ</a> <a id="9795" class="Symbol">=</a> <a id="9797" href="/20.07/BigStep/#9797" class="Bound">σ</a><a id="9798" class="Symbol">}</a> <a id="9800" class="Symbol">{</a><a id="9801" href="/20.07/BigStep/#9801" class="Bound">L</a> <a id="9803" href="/20.07/Untyped/#4442" class="InductiveConstructor Operator">·</a> <a id="9805" href="/20.07/BigStep/#9805" class="Bound">M</a><a id="9806" class="Symbol">}</a> <a id="9808" class="Symbol">{</a><a id="9809" href="/20.07/BigStep/#9809" class="Bound">V</a><a id="9810" class="Symbol">}</a> <a id="9812" class="Symbol">(</a><a id="9813" href="/20.07/BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="9819" class="Symbol">{</a><a id="9820" class="Argument">N</a> <a id="9822" class="Symbol">=</a> <a id="9824" href="/20.07/BigStep/#9824" class="Bound">N</a><a id="9825" class="Symbol">}</a> <a id="9827" href="/20.07/BigStep/#9827" class="Bound">L⇓ƛNδ</a> <a id="9833" href="/20.07/BigStep/#9833" class="Bound">N⇓V</a><a id="9836" class="Symbol">)</a> <a id="9838" href="/20.07/BigStep/#9838" class="Bound">γ≈ₑσ</a>
    <a id="9847" class="Keyword">with</a> <a id="9852" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a><a id="9858" class="Symbol">{</a><a id="9859" class="Argument">σ</a> <a id="9861" class="Symbol">=</a> <a id="9863" href="/20.07/BigStep/#9797" class="Bound">σ</a><a id="9864" class="Symbol">}</a> <a id="9866" href="/20.07/BigStep/#9827" class="Bound">L⇓ƛNδ</a> <a id="9872" href="/20.07/BigStep/#9838" class="Bound">γ≈ₑσ</a>
<a id="9877" class="Symbol">...</a> <a id="9881" class="Symbol">|</a> <a id="9883" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9885" class="Symbol">_</a> <a id="9887" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9889" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9891" href="/20.07/BigStep/#9891" class="Bound">σL—↠ƛτN</a> <a id="9899" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9901" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9903" href="/20.07/BigStep/#9903" class="Bound">τ</a> <a id="9905" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9907" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9909" href="/20.07/BigStep/#9909" class="Bound">δ≈ₑτ</a> <a id="9914" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9916" href="/20.07/BigStep/#9916" class="Bound">≡ƛτN</a> <a id="9921" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9923" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9925" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9927" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9929" class="Keyword">rewrite</a> <a id="9937" href="/20.07/BigStep/#9916" class="Bound">≡ƛτN</a>
      <a id="9949" class="Keyword">with</a> <a id="9954" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a> <a id="9961" class="Symbol">{</a><a id="9962" class="Argument">σ</a> <a id="9964" class="Symbol">=</a> <a id="9966" href="/20.07/BigStep/#7094" class="Function">ext-subst</a> <a id="9976" href="/20.07/BigStep/#9903" class="Bound">τ</a> <a id="9978" class="Symbol">(</a><a id="9979" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="9985" class="Bound">σ</a> <a id="9987" class="Bound">M</a><a id="9988" class="Symbol">)}</a> <a id="9991" class="Bound">N⇓V</a>
             <a id="10008" class="Symbol">(λ</a> <a id="10011" class="Symbol">{</a><a id="10012" href="/20.07/BigStep/#10012" class="Bound">x</a><a id="10013" class="Symbol">}</a> <a id="10015" class="Symbol">→</a> <a id="10017" href="/20.07/BigStep/#8117" class="Function">≈ₑ-ext</a><a id="10023" class="Symbol">{</a><a id="10024" class="Argument">σ</a> <a id="10026" class="Symbol">=</a> <a id="10028" href="/20.07/BigStep/#9903" class="Bound">τ</a><a id="10029" class="Symbol">}</a> <a id="10031" href="/20.07/BigStep/#9909" class="Bound">δ≈ₑτ</a> <a id="10036" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10038" class="Bound">σ</a> <a id="10040" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10042" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10044" class="Bound">γ≈ₑσ</a> <a id="10049" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10051" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="10056" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10058" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10060" class="Symbol">{</a><a id="10061" href="/20.07/BigStep/#10012" class="Bound">x</a><a id="10062" class="Symbol">})</a>
           <a id="10076" class="Symbol">|</a> <a id="10078" href="/20.07/Untyped/#10178" class="InductiveConstructor">β</a><a id="10079" class="Symbol">{</a><a id="10080" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a><a id="10081" class="Symbol">}{</a><a id="10083" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10089" class="Symbol">(</a><a id="10090" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="10095" href="/20.07/BigStep/#9903" class="Bound">τ</a><a id="10096" class="Symbol">)</a> <a id="10098" class="Bound">N</a><a id="10099" class="Symbol">}{</a><a id="10101" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10107" class="Bound">σ</a> <a id="10109" class="Bound">M</a><a id="10110" class="Symbol">}</a>
<a id="10112" class="Symbol">...</a>   <a id="10118" class="Symbol">|</a> <a id="10120" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10122" href="/20.07/BigStep/#10122" class="Bound">N&#39;</a> <a id="10125" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10127" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10129" href="/20.07/BigStep/#10129" class="Bound">—↠N&#39;</a> <a id="10134" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10136" href="/20.07/BigStep/#10136" class="Bound">V≈N&#39;</a> <a id="10141" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10143" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10145" class="Symbol">|</a> <a id="10147" href="/20.07/BigStep/#10147" class="Bound">ƛτN·σM—→</a>
        <a id="10164" class="Keyword">rewrite</a> <a id="10172" href="/20.07/BigStep/#8840" class="Function">sub-sub</a><a id="10179" class="Symbol">{</a><a id="10180" class="Argument">M</a> <a id="10182" class="Symbol">=</a> <a id="10184" class="Bound">N</a><a id="10185" class="Symbol">}{</a><a id="10187" class="Argument">σ₁</a> <a id="10190" class="Symbol">=</a> <a id="10192" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="10197" class="Bound">τ</a><a id="10198" class="Symbol">}{</a><a id="10200" class="Argument">σ₂</a> <a id="10203" class="Symbol">=</a> <a id="10205" href="/20.07/Untyped/#7375" class="Function">subst-zero</a> <a id="10216" class="Symbol">(</a><a id="10217" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10223" class="Bound">σ</a> <a id="10225" class="Bound">M</a><a id="10226" class="Symbol">)}</a> <a id="10229" class="Symbol">=</a>
        <a id="10239" class="Keyword">let</a> <a id="10243" href="/20.07/BigStep/#10243" class="Bound">rs</a> <a id="10246" class="Symbol">=</a> <a id="10248" class="Symbol">(</a><a id="10249" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="10251" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10257" class="Symbol">(</a><a id="10258" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="10263" class="Bound">τ</a><a id="10264" class="Symbol">)</a> <a id="10266" class="Bound">N</a><a id="10267" class="Symbol">)</a> <a id="10269" href="/20.07/Untyped/#4442" class="InductiveConstructor Operator">·</a> <a id="10271" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10277" class="Bound">σ</a> <a id="10279" class="Bound">M</a> <a id="10281" href="/20.07/Untyped/#11174" class="InductiveConstructor Operator">—→⟨</a> <a id="10285" href="/20.07/BigStep/#10147" class="Bound">ƛτN·σM—→</a> <a id="10294" href="/20.07/Untyped/#11174" class="InductiveConstructor Operator">⟩</a> <a id="10296" href="/20.07/BigStep/#10129" class="Bound">—↠N&#39;</a> <a id="10301" class="Keyword">in</a>
        <a id="10312" class="Keyword">let</a> <a id="10316" href="/20.07/BigStep/#10316" class="Bound">g</a> <a id="10318" class="Symbol">=</a> <a id="10320" href="/20.07/Untyped/#21721" class="Function">—↠-trans</a> <a id="10329" class="Symbol">(</a><a id="10330" href="/20.07/Untyped/#22905" class="Function">appL-cong</a> <a id="10340" class="Bound">σL—↠ƛτN</a><a id="10347" class="Symbol">)</a> <a id="10349" href="/20.07/BigStep/#10243" class="Bound">rs</a> <a id="10352" class="Keyword">in</a>
        <a id="10363" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10365" href="/20.07/BigStep/#10122" class="Bound">N&#39;</a> <a id="10368" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10370" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10372" href="/20.07/BigStep/#10316" class="Bound">g</a> <a id="10374" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10376" href="/20.07/BigStep/#10136" class="Bound">V≈N&#39;</a> <a id="10381" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10383" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
</pre><p>The proof is by induction on <code class="language-plaintext highlighter-rouge">γ ⊢ M ⇓ V</code>. We have three cases to consider.</p><ul><li><p>Case <code class="language-plaintext highlighter-rouge">⇓-var</code>. So we have <code class="language-plaintext highlighter-rouge">γ x ≡ clos L δ</code> and <code class="language-plaintext highlighter-rouge">δ ⊢ L ⇓ V</code>. We need to show that <code class="language-plaintext highlighter-rouge">subst σ x —↠ N</code> and <code class="language-plaintext highlighter-rouge">V ≈ N</code> for some <code class="language-plaintext highlighter-rouge">N</code>. The premise <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code> tells us that <code class="language-plaintext highlighter-rouge">γ x ≈ σ x</code>, so <code class="language-plaintext highlighter-rouge">clos L δ ≈ σ x</code>. By the definition of <code class="language-plaintext highlighter-rouge">≈</code>, there exists a <code class="language-plaintext highlighter-rouge">τ</code> such that <code class="language-plaintext highlighter-rouge">δ ≈ₑ τ</code> and <code class="language-plaintext highlighter-rouge">σ x ≡ subst τ L</code>. Using <code class="language-plaintext highlighter-rouge">δ ⊢ L ⇓ V</code> and <code class="language-plaintext highlighter-rouge">δ ≈ₑ τ</code>, the induction hypothesis gives us <code class="language-plaintext highlighter-rouge">subst τ L —↠ N</code> and <code class="language-plaintext highlighter-rouge">V ≈ N</code> for some <code class="language-plaintext highlighter-rouge">N</code>. So we have shown that <code class="language-plaintext highlighter-rouge">subst σ x —↠ N</code> and <code class="language-plaintext highlighter-rouge">V ≈ N</code> for some <code class="language-plaintext highlighter-rouge">N</code>.</p></li><li><p>Case <code class="language-plaintext highlighter-rouge">⇓-lam</code>. We immediately have <code class="language-plaintext highlighter-rouge">subst σ (ƛ N) —↠ subst σ (ƛ N)</code> and <code class="language-plaintext highlighter-rouge">clos (subst σ (ƛ N)) γ ≈ subst σ (ƛ N)</code>.</p></li><li><p>Case <code class="language-plaintext highlighter-rouge">⇓-app</code>. Using <code class="language-plaintext highlighter-rouge">γ ⊢ L ⇓ clos N δ</code> and <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>, the induction hypothesis gives us</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L —↠ ƛ subst (exts τ) N                                     (1)
</code></pre></div></div><p>and <code class="language-plaintext highlighter-rouge">δ ≈ₑ τ</code> for some <code class="language-plaintext highlighter-rouge">τ</code>. From <code class="language-plaintext highlighter-rouge">γ≈ₑσ</code> we have <code class="language-plaintext highlighter-rouge">clos M γ ≈ subst σ M</code>. Then with <code class="language-plaintext highlighter-rouge">(δ ,' clos M γ) ⊢ N ⇓ V</code>, the induction hypothesis gives us <code class="language-plaintext highlighter-rouge">V ≈ N'</code> and</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst (subst (subst-zero (subst σ M)) ∘ (exts τ)) N —↠ N'         (2)
</code></pre></div></div><p>Meanwhile, by <code class="language-plaintext highlighter-rouge">β</code>, we have</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst-zero (subst σ M)) (subst (exts τ) N)
</code></pre></div></div><p>which is the same as the following, by <code class="language-plaintext highlighter-rouge">sub-sub</code>.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst (subst-zero (subst σ M)) ∘ exts τ) N              (3)
</code></pre></div></div><p>Using (3) and (2) we have</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M —↠ N'                             (4)
</code></pre></div></div><p>From (1) we have</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L · subst σ M —↠ (ƛ subst (exts τ) N) · subst σ M
</code></pre></div></div><p>which we combine with (4) to conclude that</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L · subst σ M —↠ N'
</code></pre></div></div></li></ul><p>With the main lemma complete, we establish the forward direction of the equivalence between the big-step semantics and beta reduction.</p><pre class="Agda"><a id="cbn→reduce"></a><a id="12205" href="/20.07/BigStep/#12205" class="Function">cbn→reduce</a> <a id="12216" class="Symbol">:</a>  <a id="12219" class="Symbol">∀{</a><a id="12221" href="/20.07/BigStep/#12221" class="Bound">M</a> <a id="12223" class="Symbol">:</a> <a id="12225" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="12227" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="12229" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="12230" class="Symbol">}{</a><a id="12232" href="/20.07/BigStep/#12232" class="Bound">Δ</a><a id="12233" class="Symbol">}{</a><a id="12235" href="/20.07/BigStep/#12235" class="Bound">δ</a> <a id="12237" class="Symbol">:</a> <a id="12239" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="12247" href="/20.07/BigStep/#12232" class="Bound">Δ</a><a id="12248" class="Symbol">}{</a><a id="12250" href="/20.07/BigStep/#12250" class="Bound">N′</a> <a id="12253" class="Symbol">:</a> <a id="12255" href="/20.07/BigStep/#12232" class="Bound">Δ</a> <a id="12257" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="12259" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="12261" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="12263" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="12264" class="Symbol">}</a>
  <a id="12268" class="Symbol">→</a> <a id="12270" href="/20.07/BigStep/#2650" class="Function">∅&#39;</a> <a id="12273" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="12275" href="/20.07/BigStep/#12221" class="Bound">M</a> <a id="12277" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="12279" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="12284" class="Symbol">(</a><a id="12285" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="12287" href="/20.07/BigStep/#12250" class="Bound">N′</a><a id="12289" class="Symbol">)</a> <a id="12291" href="/20.07/BigStep/#12235" class="Bound">δ</a>
    <a id="12297" class="Comment">-----------------------------</a>
  <a id="12329" class="Symbol">→</a> <a id="12331" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="12334" href="/20.07/BigStep/#12334" class="Bound">N</a> <a id="12336" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="12338" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="12340" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="12342" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="12344" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="12346" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="12348" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="12350" class="Symbol">(</a><a id="12351" href="/20.07/BigStep/#12221" class="Bound">M</a> <a id="12353" href="/20.07/Untyped/#11068" class="Datatype Operator">—↠</a> <a id="12356" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="12358" href="/20.07/BigStep/#12334" class="Bound">N</a><a id="12359" class="Symbol">)</a>
<a id="12361" href="/20.07/BigStep/#12205" class="Function">cbn→reduce</a> <a id="12372" class="Symbol">{</a><a id="12373" href="/20.07/BigStep/#12373" class="Bound">M</a><a id="12374" class="Symbol">}{</a><a id="12376" href="/20.07/BigStep/#12376" class="Bound">Δ</a><a id="12377" class="Symbol">}{</a><a id="12379" href="/20.07/BigStep/#12379" class="Bound">δ</a><a id="12380" class="Symbol">}{</a><a id="12382" href="/20.07/BigStep/#12382" class="Bound">N′</a><a id="12384" class="Symbol">}</a> <a id="12386" href="/20.07/BigStep/#12386" class="Bound">M⇓c</a>
    <a id="12394" class="Keyword">with</a> <a id="12399" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a><a id="12405" class="Symbol">{</a><a id="12406" class="Argument">σ</a> <a id="12408" class="Symbol">=</a> <a id="12410" href="/20.07/Substitution/#3046" class="Function">ids</a><a id="12413" class="Symbol">}</a> <a id="12415" href="/20.07/BigStep/#12386" class="Bound">M⇓c</a> <a id="12419" href="/20.07/BigStep/#6814" class="Function">≈ₑ-id</a>
<a id="12425" class="Symbol">...</a> <a id="12429" class="Symbol">|</a> <a id="12431" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12433" href="/20.07/BigStep/#12433" class="Bound">N</a> <a id="12435" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12437" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12439" href="/20.07/BigStep/#12439" class="Bound">rs</a> <a id="12442" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12444" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12446" href="/20.07/BigStep/#12446" class="Bound">σ</a> <a id="12448" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12450" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12452" href="/20.07/BigStep/#12452" class="Bound">h</a> <a id="12454" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12456" href="/20.07/BigStep/#12456" class="Bound">eq2</a> <a id="12460" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12462" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12464" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12466" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12468" class="Keyword">rewrite</a> <a id="12476" href="/20.07/BigStep/#6932" class="Function">sub-id</a><a id="12482" class="Symbol">{</a><a id="12483" class="Argument">M</a> <a id="12485" class="Symbol">=</a> <a id="12487" class="Bound">M</a><a id="12488" class="Symbol">}</a> <a id="12490" class="Symbol">|</a> <a id="12492" href="/20.07/BigStep/#12456" class="Bound">eq2</a> <a id="12496" class="Symbol">=</a>
      <a id="12504" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12506" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="12512" class="Symbol">(</a><a id="12513" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="12518" href="/20.07/BigStep/#12446" class="Bound">σ</a><a id="12519" class="Symbol">)</a> <a id="12521" class="Bound">N′</a> <a id="12524" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12526" href="/20.07/BigStep/#12439" class="Bound">rs</a> <a id="12529" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
</pre><h4 id="exercise-big-alt-implies-multi-practice">Exercise <code class="language-plaintext highlighter-rouge">big-alt-implies-multi</code> (practice)</h4><p>Formulate an alternative big-step semantics, of the form <code class="language-plaintext highlighter-rouge">M ↓ N</code>, for call-by-name that uses substitution instead of environments. That is, the analogue of the application rule <code class="language-plaintext highlighter-rouge">⇓-app</code> should perform substitution, as in <code class="language-plaintext highlighter-rouge">N [ M ]</code>, instead of extending the environment with <code class="language-plaintext highlighter-rouge">M</code>. Prove that <code class="language-plaintext highlighter-rouge">M ↓ N</code> implies <code class="language-plaintext highlighter-rouge">M —↠ N</code>.</p><pre class="Agda"><a id="12907" class="Comment">-- Your code goes here</a>
</pre><h2 id="beta-reduction-to-a-lambda-implies-big-step-evaluation">Beta reduction to a lambda implies big-step evaluation</h2><p>The proof of the backward direction, that beta reduction to a lambda implies that the call-by-name semantics produces a result, is more difficult to prove. The difficulty stems from reduction proceeding underneath lambda abstractions via the <code class="language-plaintext highlighter-rouge">ζ</code> rule. The call-by-name semantics does not reduce under lambda, so a straightforward proof by induction on the reduction sequence is impossible. In the article <em>Call-by-name, call-by-value, and the λ-calculus</em>, Plotkin proves the theorem in two steps, using two auxilliary reduction relations. The first step uses a classic technique called Curry-Feys standardisation. It relies on the notion of <em>standard reduction sequence</em>, which acts as a half-way point between full beta reduction and call-by-name by expanding call-by-name to also include reduction underneath lambda. Plotkin proves that <code class="language-plaintext highlighter-rouge">M</code> reduces to <code class="language-plaintext highlighter-rouge">L</code> if and only if <code class="language-plaintext highlighter-rouge">M</code> is related to <code class="language-plaintext highlighter-rouge">L</code> by a standard reduction sequence.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Theorem 1 (Standardisation)
`M —↠ L` if and only if `M` goes to `L` via a standard reduction sequence.
</code></pre></div></div><p>Plotkin then introduces <em>left reduction</em>, a small-step version of call-by-name and uses the above theorem to prove that beta reduction and left reduction are equivalent in the following sense.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Corollary 1
`M —↠ ƛ N` if and only if `M` goes to `ƛ N′`, for some `N′`, by left reduction.
</code></pre></div></div><p>The second step of the proof connects left reduction to call-by-name evaluation.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Theorem 2
`M` left reduces to `ƛ N` if and only if `⊢ M ⇓ ƛ N`.
</code></pre></div></div><p>(Plotkin’s call-by-name evaluator uses substitution instead of environments, which explains why the environment is omitted in <code class="language-plaintext highlighter-rouge">⊢ M ⇓ ƛ N</code> in the above theorem statement.)</p><p>Putting Corollary 1 and Theorem 2 together, Plotkin proves that call-by-name evaluation is equivalent to beta reduction.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Corollary 2
`M —↠ ƛ N` if and only if `⊢ M ⇓ ƛ N′` for some `N′`.
</code></pre></div></div><p>Plotkin also proves an analogous result for the λᵥ calculus, relating it to call-by-value evaluation. For a nice exposition of that proof, we recommend Chapter 5 of <em>Semantics Engineering with PLT Redex</em> by Felleisen, Findler, and Flatt.</p><p>Instead of proving the backwards direction via standardisation, as sketched above, we defer the proof until after we define a denotational semantics for the lambda calculus, at which point the proof of the backwards direction will fall out as a corollary to the soundness and adequacy of the denotational semantics.</p><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>≈  U+2248  ALMOST EQUAL TO (\~~ or \approx)
ₑ  U+2091  LATIN SUBSCRIPT SMALL LETTER E (\_e)
⊢  U+22A2  RIGHT TACK (\|- or \vdash)
⇓  U+21DB  DOWNWARDS DOUBLE ARROW (\d= or \Downarrow)
</code></pre></div></div></div><p style="text-align:center"><a alt="Previous chapter" href="/20.07/Confluence/">Prev</a> &bullet; <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev-20.07/src/plfa/part2/BigStep.lagda.md">Source</a> &bullet; <a alt="Next chapter" href="/20.07/Denotational/">Next</a></p></article></div></main><footer class="site-footer h-card"><data class="u-url" href="/20.07/"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jsiek"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jsiek</span></a></li><li><a href="https://www.twitter.com/jeremysiek"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jeremysiek</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer><script type="text/javascript" src="/20.07/assets/jquery.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha256-E4RlfxwyJVmkkk0szw7LYJxuPlp6evtPSBDlWHsYYL8=" crossorigin="anonymous"></script><script type="text/javascript">anchors.add()</script><script type="text/javascript">$(".menu-icon").click(function(){$(".trigger").toggle()}),$("div.foldable pre").each(function(){var i=$(this).height(),t=parseFloat($(this).css("line-height")),h=$("<div></div>"),e=$("<div></div>"),o=$("<div></div>");$(this).prepend(h),h.css({position:"relative",float:"right",right:"-"+(.5*t-1.5)+"px",width:t,height:t}),o.css({position:"relative",height:t,width:"3px","background-color":"#C1E0FF"}),e.css({position:"relative",top:"-"+(.5*t+1.5)+"px",left:"-"+(.5*t-1.5)+"px",height:"3px",width:t,"background-color":"#C1E0FF"}),h.append(o),h.append(e),$(this).height(2*t),$(this).css("overflow","hidden"),$(this).click(function(){$(this).height()==i?($(this).height(2*t),h.show()):($(this).height("auto"),h.hide())})})</script><script type="text/javascript" src="/20.07/assets/katex.js"></script><script type="text/javascript">$("script[type='math/tex']").replaceWith(function(){var t=$(this).text();return'<span class="inline-equation">'+katex.renderToString(t)+"</span>"}),$("script[type='math/tex; mode=display']").replaceWith(function(){var t=$(this).text().replace(/%.*?(\n|$)/g,"");return'<div class="equation">'+katex.renderToString("\\displaystyle "+t)+"</div>"})</script></body></html>