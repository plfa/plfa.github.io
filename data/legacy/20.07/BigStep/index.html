<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>BigStep: Big-step semantics of untyped lambda calculus | Programming Language Foundations in Agda
</title><!-- Begin Jekyll SEO tag v2.6.1 -->
<meta name="generator" content="Jekyll v3.9.0" />
<meta property="og:title" content="BigStep: Big-step semantics of untyped lambda calculus" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Programming Language Foundations in Agda" />
<meta property="og:description" content="Programming Language Foundations in Agda" />
<link rel="canonical" href="https://plfa.github.io/20.07/BigStep/" />
<meta property="og:url" content="https://plfa.github.io/20.07/BigStep/" />
<meta property="og:site_name" content="Programming Language Foundations in Agda" />
<script type="application/ld+json">
{"url":"https://plfa.github.io/20.07/BigStep/","headline":"BigStep: Big-step semantics of untyped lambda calculus","description":"Programming Language Foundations in Agda","@type":"WebPage","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/20.07/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/20.07/">Programming Language Foundations in Agda
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/20.07/">The Book</a>
                <a class="page-link" href="/20.07/Announcements/">Announcements</a>
                <a class="page-link" href="/20.07/GettingStarted/">Getting Started</a>
                <a class="page-link" href="/20.07/Citing/">Citing</a>
                <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">BigStep: Big-step semantics of untyped lambda calculus</h1>
  </header>

  <p style="text-align:center;">

    <a alt="Previous chapter" href="/20.07/Confluence/">Prev</a>


    &bullet;


    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev-20.07/src/plfa/part2/BigStep.lagda.md">Source</a>


    &bullet;


    <a alt="Next chapter" href="/20.07/Denotational/">Next</a>

</p>


  <div class="post-content">
    <pre class="Agda"><a id="174" class="Keyword">module</a> <a id="181" href="/20.07/BigStep/" class="Module">plfa.part2.BigStep</a> <a id="200" class="Keyword">where</a>
</pre>
<h2 id="introduction">Introduction</h2>

<p>The call-by-name evaluation strategy is a deterministic method for
computing the value of a program in the lambda calculus.  That is,
call-by-name produces a value if and only if beta reduction can reduce
the program to a lambda abstraction. In this chapter we define
call-by-name evaluation and prove the forward direction of this
if-and-only-if. The backward direction is traditionally proved via
Curry-Feys standardisation, which is quite complex.  We give a sketch
of that proof, due to Plotkin, but postpone the proof in Agda until
after we have developed a denotational semantics for the lambda
calculus, at which point the proof is an easy corollary of properties
of the denotational semantics.</p>

<p>We present the call-by-name strategy as a relation between an input
term and an output value. Such a relation is often called a <em>big-step
semantics</em>, written <code class="language-plaintext highlighter-rouge">M ⇓ V</code>, as it relates the input term <code class="language-plaintext highlighter-rouge">M</code> directly
to the final result <code class="language-plaintext highlighter-rouge">V</code>, in contrast to the small-step reduction
relation, <code class="language-plaintext highlighter-rouge">M —→ M′</code>, that maps <code class="language-plaintext highlighter-rouge">M</code> to another term <code class="language-plaintext highlighter-rouge">M′</code> in which a
single sub-computation has been completed.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="1332" class="Keyword">open</a> <a id="1337" class="Keyword">import</a> <a id="1344" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="1384" class="Keyword">using</a> <a id="1390" class="Symbol">(</a><a id="1391" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="1394" class="Symbol">;</a> <a id="1396" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="1400" class="Symbol">;</a> <a id="1402" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#984" class="Function">trans</a><a id="1407" class="Symbol">;</a> <a id="1409" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a><a id="1412" class="Symbol">;</a> <a id="1414" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a><a id="1422" class="Symbol">)</a>
<a id="1424" class="Keyword">open</a> <a id="1429" class="Keyword">import</a> <a id="1436" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html" class="Module">Data.Product</a> <a id="1449" class="Keyword">using</a> <a id="1455" class="Symbol">(</a><a id="1456" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">_×_</a><a id="1459" class="Symbol">;</a> <a id="1461" href="Agda.Builtin.Sigma.html#139" class="Record">Σ</a><a id="1462" class="Symbol">;</a> <a id="1464" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ-syntax</a><a id="1472" class="Symbol">;</a> <a id="1474" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1364" class="Function">∃</a><a id="1475" class="Symbol">;</a> <a id="1477" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">∃-syntax</a><a id="1485" class="Symbol">;</a> <a id="1487" href="Agda.Builtin.Sigma.html#225" class="Field">proj₁</a><a id="1492" class="Symbol">;</a> <a id="1494" href="Agda.Builtin.Sigma.html#237" class="Field">proj₂</a><a id="1499" class="Symbol">)</a>
  <a id="1503" class="Keyword">renaming</a> <a id="1512" class="Symbol">(</a><a id="1513" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">_,_</a> <a id="1517" class="Symbol">to</a> <a id="1520" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="1525" class="Symbol">)</a>
<a id="1527" class="Keyword">open</a> <a id="1532" class="Keyword">import</a> <a id="1539" href="https://agda.github.io/agda-stdlib/v1.1/Function.html" class="Module">Function</a> <a id="1548" class="Keyword">using</a> <a id="1554" class="Symbol">(</a><a id="1555" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">_∘_</a><a id="1558" class="Symbol">)</a>
<a id="1560" class="Keyword">open</a> <a id="1565" class="Keyword">import</a> <a id="1572" href="/20.07/Untyped/" class="Module">plfa.part2.Untyped</a>
  <a id="1593" class="Keyword">using</a> <a id="1599" class="Symbol">(</a><a id="1600" href="/20.07/Untyped/#3153" class="Datatype">Context</a><a id="1607" class="Symbol">;</a> <a id="1609" href="/20.07/Untyped/#4294" class="Datatype Operator">_⊢_</a><a id="1612" class="Symbol">;</a> <a id="1614" href="/20.07/Untyped/#3521" class="Datatype Operator">_∋_</a><a id="1617" class="Symbol">;</a> <a id="1619" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="1620" class="Symbol">;</a> <a id="1622" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a><a id="1623" class="Symbol">;</a> <a id="1625" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">_,_</a><a id="1628" class="Symbol">;</a> <a id="1630" href="/20.07/Untyped/#3557" class="InductiveConstructor">Z</a><a id="1631" class="Symbol">;</a> <a id="1633" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S_</a><a id="1635" class="Symbol">;</a> <a id="1637" href="/20.07/Untyped/#4330" class="InductiveConstructor Operator">`_</a><a id="1639" class="Symbol">;</a> <a id="1641" href="/20.07/Untyped/#5111" class="Function Operator">#_</a><a id="1643" class="Symbol">;</a> <a id="1645" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ_</a><a id="1647" class="Symbol">;</a> <a id="1649" href="/20.07/Untyped/#4442" class="InductiveConstructor Operator">_·_</a><a id="1652" class="Symbol">;</a>
  <a id="1656" href="/20.07/Untyped/#6963" class="Function">subst</a><a id="1661" class="Symbol">;</a> <a id="1663" href="/20.07/Untyped/#7375" class="Function">subst-zero</a><a id="1673" class="Symbol">;</a> <a id="1675" href="/20.07/Untyped/#6671" class="Function">exts</a><a id="1679" class="Symbol">;</a> <a id="1681" href="/20.07/Untyped/#6235" class="Function">rename</a><a id="1687" class="Symbol">;</a> <a id="1689" href="/20.07/Untyped/#10178" class="InductiveConstructor">β</a><a id="1690" class="Symbol">;</a> <a id="1692" href="/20.07/Untyped/#9998" class="InductiveConstructor">ξ₁</a><a id="1694" class="Symbol">;</a> <a id="1696" href="/20.07/Untyped/#10088" class="InductiveConstructor">ξ₂</a><a id="1698" class="Symbol">;</a> <a id="1700" href="/20.07/Untyped/#10286" class="InductiveConstructor">ζ</a><a id="1701" class="Symbol">;</a> <a id="1703" href="/20.07/Untyped/#9948" class="Datatype Operator">_—→_</a><a id="1707" class="Symbol">;</a> <a id="1709" href="/20.07/Untyped/#11068" class="Datatype Operator">_—↠_</a><a id="1713" class="Symbol">;</a> <a id="1715" href="/20.07/Untyped/#11174" class="InductiveConstructor Operator">_—→⟨_⟩_</a><a id="1722" class="Symbol">;</a> <a id="1724" href="/20.07/Untyped/#11118" class="InductiveConstructor Operator">_∎</a><a id="1726" class="Symbol">;</a>
  <a id="1730" href="/20.07/Untyped/#21721" class="Function">—↠-trans</a><a id="1738" class="Symbol">;</a> <a id="1740" href="/20.07/Untyped/#22905" class="Function">appL-cong</a><a id="1749" class="Symbol">)</a>
<a id="1751" class="Keyword">open</a> <a id="1756" class="Keyword">import</a> <a id="1763" href="/20.07/Substitution/" class="Module">plfa.part2.Substitution</a> <a id="1787" class="Keyword">using</a> <a id="1793" class="Symbol">(</a><a id="1794" href="/20.07/Substitution/#2405" class="Function">Subst</a><a id="1799" class="Symbol">;</a> <a id="1801" href="/20.07/Substitution/#3046" class="Function">ids</a><a id="1804" class="Symbol">)</a>
</pre>
<h2 id="environments">Environments</h2>

<p>To handle variables and function application, there is the choice
between using substitution, as in <code class="language-plaintext highlighter-rouge">—→</code>, or to use an <em>environment</em>.
An environment in call-by-name is a map from variables to closures,
that is, to terms paired with their environments. We choose to use
environments instead of substitution because the point of the
call-by-name strategy is to be closer to an implementation of the
language. Also, the denotational semantics introduced in later
chapters uses environments and the proof of adequacy
is made easier by aligning these choices.</p>

<p>We define environments and closures as follows.</p>

<pre class="Agda"><a id="ClosEnv"></a><a id="2437" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2445" class="Symbol">:</a> <a id="2447" href="/20.07/Untyped/#3153" class="Datatype">Context</a> <a id="2455" class="Symbol">→</a> <a id="2457" class="PrimitiveType">Set</a>

<a id="2462" class="Keyword">data</a> <a id="Clos"></a><a id="2467" href="/20.07/BigStep/#2467" class="Datatype">Clos</a> <a id="2472" class="Symbol">:</a> <a id="2474" class="PrimitiveType">Set</a> <a id="2478" class="Keyword">where</a>
  <a id="Clos.clos"></a><a id="2486" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="2491" class="Symbol">:</a> <a id="2493" class="Symbol">∀{</a><a id="2495" href="/20.07/BigStep/#2495" class="Bound">Γ</a><a id="2496" class="Symbol">}</a> <a id="2498" class="Symbol">→</a> <a id="2500" class="Symbol">(</a><a id="2501" href="/20.07/BigStep/#2501" class="Bound">M</a> <a id="2503" class="Symbol">:</a> <a id="2505" href="/20.07/BigStep/#2495" class="Bound">Γ</a> <a id="2507" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="2509" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="2510" class="Symbol">)</a> <a id="2512" class="Symbol">→</a> <a id="2514" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2522" href="/20.07/BigStep/#2495" class="Bound">Γ</a> <a id="2524" class="Symbol">→</a> <a id="2526" href="/20.07/BigStep/#2467" class="Datatype">Clos</a>

<a id="2532" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2540" href="/20.07/BigStep/#2540" class="Bound">Γ</a> <a id="2542" class="Symbol">=</a> <a id="2544" class="Symbol">∀</a> <a id="2546" class="Symbol">(</a><a id="2547" href="/20.07/BigStep/#2547" class="Bound">x</a> <a id="2549" class="Symbol">:</a> <a id="2551" href="/20.07/BigStep/#2540" class="Bound">Γ</a> <a id="2553" href="/20.07/Untyped/#3521" class="Datatype Operator">∋</a> <a id="2555" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="2556" class="Symbol">)</a> <a id="2558" class="Symbol">→</a> <a id="2560" href="/20.07/BigStep/#2467" class="Datatype">Clos</a>
</pre>
<p>As usual, we have the empty environment, and we can extend an
environment.</p>

<pre class="Agda"><a id="∅&#39;"></a><a id="2650" href="/20.07/BigStep/#2650" class="Function">∅&#39;</a> <a id="2653" class="Symbol">:</a> <a id="2655" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2663" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a>
<a id="2665" href="/20.07/BigStep/#2650" class="Function">∅&#39;</a> <a id="2668" class="Symbol">()</a>

<a id="_,&#39;_"></a><a id="2672" href="/20.07/BigStep/#2672" class="Function Operator">_,&#39;_</a> <a id="2677" class="Symbol">:</a> <a id="2679" class="Symbol">∀</a> <a id="2681" class="Symbol">{</a><a id="2682" href="/20.07/BigStep/#2682" class="Bound">Γ</a><a id="2683" class="Symbol">}</a> <a id="2685" class="Symbol">→</a> <a id="2687" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2695" href="/20.07/BigStep/#2682" class="Bound">Γ</a> <a id="2697" class="Symbol">→</a> <a id="2699" href="/20.07/BigStep/#2467" class="Datatype">Clos</a> <a id="2704" class="Symbol">→</a> <a id="2706" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="2714" class="Symbol">(</a><a id="2715" href="/20.07/BigStep/#2682" class="Bound">Γ</a> <a id="2717" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="2719" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="2720" class="Symbol">)</a>
<a id="2722" class="Symbol">(</a><a id="2723" href="/20.07/BigStep/#2723" class="Bound">γ</a> <a id="2725" href="/20.07/BigStep/#2672" class="Function Operator">,&#39;</a> <a id="2728" href="/20.07/BigStep/#2728" class="Bound">c</a><a id="2729" class="Symbol">)</a> <a id="2731" href="/20.07/Untyped/#3557" class="InductiveConstructor">Z</a> <a id="2733" class="Symbol">=</a> <a id="2735" href="/20.07/BigStep/#2728" class="Bound">c</a>
<a id="2737" class="Symbol">(</a><a id="2738" href="/20.07/BigStep/#2738" class="Bound">γ</a> <a id="2740" href="/20.07/BigStep/#2672" class="Function Operator">,&#39;</a> <a id="2743" href="/20.07/BigStep/#2743" class="Bound">c</a><a id="2744" class="Symbol">)</a> <a id="2746" class="Symbol">(</a><a id="2747" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S</a> <a id="2749" href="/20.07/BigStep/#2749" class="Bound">x</a><a id="2750" class="Symbol">)</a> <a id="2752" class="Symbol">=</a> <a id="2754" href="/20.07/BigStep/#2738" class="Bound">γ</a> <a id="2756" href="/20.07/BigStep/#2749" class="Bound">x</a>
</pre>
<h2 id="big-step-evaluation">Big-step evaluation</h2>

<p>The big-step semantics is represented as a ternary relation,
written <code class="language-plaintext highlighter-rouge">γ ⊢ M ⇓ V</code>, where <code class="language-plaintext highlighter-rouge">γ</code> is the environment, <code class="language-plaintext highlighter-rouge">M</code> is the input
term, and <code class="language-plaintext highlighter-rouge">V</code> is the result value.  A <em>value</em> is a closure whose term
is a lambda abstraction.</p>

<pre class="Agda"><a id="3016" class="Keyword">data</a> <a id="_⊢_⇓_"></a><a id="3021" href="/20.07/BigStep/#3021" class="Datatype Operator">_⊢_⇓_</a> <a id="3027" class="Symbol">:</a> <a id="3029" class="Symbol">∀{</a><a id="3031" href="/20.07/BigStep/#3031" class="Bound">Γ</a><a id="3032" class="Symbol">}</a> <a id="3034" class="Symbol">→</a> <a id="3036" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3044" href="/20.07/BigStep/#3031" class="Bound">Γ</a> <a id="3046" class="Symbol">→</a> <a id="3048" class="Symbol">(</a><a id="3049" href="/20.07/BigStep/#3031" class="Bound">Γ</a> <a id="3051" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3053" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3054" class="Symbol">)</a> <a id="3056" class="Symbol">→</a> <a id="3058" href="/20.07/BigStep/#2467" class="Datatype">Clos</a> <a id="3063" class="Symbol">→</a> <a id="3065" class="PrimitiveType">Set</a> <a id="3069" class="Keyword">where</a>

  <a id="_⊢_⇓_.⇓-var"></a><a id="3078" href="/20.07/BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="3084" class="Symbol">:</a> <a id="3086" class="Symbol">∀{</a><a id="3088" href="/20.07/BigStep/#3088" class="Bound">Γ</a><a id="3089" class="Symbol">}{</a><a id="3091" href="/20.07/BigStep/#3091" class="Bound">γ</a> <a id="3093" class="Symbol">:</a> <a id="3095" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3103" href="/20.07/BigStep/#3088" class="Bound">Γ</a><a id="3104" class="Symbol">}{</a><a id="3106" href="/20.07/BigStep/#3106" class="Bound">x</a> <a id="3108" class="Symbol">:</a> <a id="3110" href="/20.07/BigStep/#3088" class="Bound">Γ</a> <a id="3112" href="/20.07/Untyped/#3521" class="Datatype Operator">∋</a> <a id="3114" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3115" class="Symbol">}{</a><a id="3117" href="/20.07/BigStep/#3117" class="Bound">Δ</a><a id="3118" class="Symbol">}{</a><a id="3120" href="/20.07/BigStep/#3120" class="Bound">δ</a> <a id="3122" class="Symbol">:</a> <a id="3124" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3132" href="/20.07/BigStep/#3117" class="Bound">Δ</a><a id="3133" class="Symbol">}{</a><a id="3135" href="/20.07/BigStep/#3135" class="Bound">M</a> <a id="3137" class="Symbol">:</a> <a id="3139" href="/20.07/BigStep/#3117" class="Bound">Δ</a> <a id="3141" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3143" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3144" class="Symbol">}{</a><a id="3146" href="/20.07/BigStep/#3146" class="Bound">V</a><a id="3147" class="Symbol">}</a>
    <a id="3153" class="Symbol">→</a> <a id="3155" href="/20.07/BigStep/#3091" class="Bound">γ</a> <a id="3157" href="/20.07/BigStep/#3106" class="Bound">x</a> <a id="3159" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="3161" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3166" href="/20.07/BigStep/#3135" class="Bound">M</a> <a id="3168" href="/20.07/BigStep/#3120" class="Bound">δ</a>
    <a id="3174" class="Symbol">→</a> <a id="3176" href="/20.07/BigStep/#3120" class="Bound">δ</a> <a id="3178" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3180" href="/20.07/BigStep/#3135" class="Bound">M</a> <a id="3182" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3184" href="/20.07/BigStep/#3146" class="Bound">V</a>
      <a id="3192" class="Comment">-----------</a>
    <a id="3208" class="Symbol">→</a> <a id="3210" href="/20.07/BigStep/#3091" class="Bound">γ</a> <a id="3212" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3214" href="/20.07/Untyped/#4330" class="InductiveConstructor Operator">`</a> <a id="3216" href="/20.07/BigStep/#3106" class="Bound">x</a> <a id="3218" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3220" href="/20.07/BigStep/#3146" class="Bound">V</a>

  <a id="_⊢_⇓_.⇓-lam"></a><a id="3225" href="/20.07/BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="3231" class="Symbol">:</a> <a id="3233" class="Symbol">∀{</a><a id="3235" href="/20.07/BigStep/#3235" class="Bound">Γ</a><a id="3236" class="Symbol">}{</a><a id="3238" href="/20.07/BigStep/#3238" class="Bound">γ</a> <a id="3240" class="Symbol">:</a> <a id="3242" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3250" href="/20.07/BigStep/#3235" class="Bound">Γ</a><a id="3251" class="Symbol">}{</a><a id="3253" href="/20.07/BigStep/#3253" class="Bound">M</a> <a id="3255" class="Symbol">:</a> <a id="3257" href="/20.07/BigStep/#3235" class="Bound">Γ</a> <a id="3259" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="3261" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="3263" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3265" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3266" class="Symbol">}</a>
    <a id="3272" class="Symbol">→</a> <a id="3274" href="/20.07/BigStep/#3238" class="Bound">γ</a> <a id="3276" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3278" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="3280" href="/20.07/BigStep/#3253" class="Bound">M</a> <a id="3282" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3284" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3289" class="Symbol">(</a><a id="3290" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="3292" href="/20.07/BigStep/#3253" class="Bound">M</a><a id="3293" class="Symbol">)</a> <a id="3295" href="/20.07/BigStep/#3238" class="Bound">γ</a>

  <a id="_⊢_⇓_.⇓-app"></a><a id="3300" href="/20.07/BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="3306" class="Symbol">:</a> <a id="3308" class="Symbol">∀{</a><a id="3310" href="/20.07/BigStep/#3310" class="Bound">Γ</a><a id="3311" class="Symbol">}{</a><a id="3313" href="/20.07/BigStep/#3313" class="Bound">γ</a> <a id="3315" class="Symbol">:</a> <a id="3317" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3325" href="/20.07/BigStep/#3310" class="Bound">Γ</a><a id="3326" class="Symbol">}{</a><a id="3328" href="/20.07/BigStep/#3328" class="Bound">L</a> <a id="3330" href="/20.07/BigStep/#3330" class="Bound">M</a> <a id="3332" class="Symbol">:</a> <a id="3334" href="/20.07/BigStep/#3310" class="Bound">Γ</a> <a id="3336" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3338" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3339" class="Symbol">}{</a><a id="3341" href="/20.07/BigStep/#3341" class="Bound">Δ</a><a id="3342" class="Symbol">}{</a><a id="3344" href="/20.07/BigStep/#3344" class="Bound">δ</a> <a id="3346" class="Symbol">:</a> <a id="3348" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="3356" href="/20.07/BigStep/#3341" class="Bound">Δ</a><a id="3357" class="Symbol">}{</a><a id="3359" href="/20.07/BigStep/#3359" class="Bound">N</a> <a id="3361" class="Symbol">:</a> <a id="3363" href="/20.07/BigStep/#3341" class="Bound">Δ</a> <a id="3365" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="3367" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="3369" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="3371" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="3372" class="Symbol">}{</a><a id="3374" href="/20.07/BigStep/#3374" class="Bound">V</a><a id="3375" class="Symbol">}</a>
    <a id="3381" class="Symbol">→</a> <a id="3383" href="/20.07/BigStep/#3313" class="Bound">γ</a> <a id="3385" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3387" href="/20.07/BigStep/#3328" class="Bound">L</a> <a id="3389" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3391" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3396" class="Symbol">(</a><a id="3397" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="3399" href="/20.07/BigStep/#3359" class="Bound">N</a><a id="3400" class="Symbol">)</a> <a id="3402" href="/20.07/BigStep/#3344" class="Bound">δ</a>   <a id="3406" class="Symbol">→</a>   <a id="3410" class="Symbol">(</a><a id="3411" href="/20.07/BigStep/#3344" class="Bound">δ</a> <a id="3413" href="/20.07/BigStep/#2672" class="Function Operator">,&#39;</a> <a id="3416" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="3421" href="/20.07/BigStep/#3330" class="Bound">M</a> <a id="3423" href="/20.07/BigStep/#3313" class="Bound">γ</a><a id="3424" class="Symbol">)</a> <a id="3426" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3428" href="/20.07/BigStep/#3359" class="Bound">N</a> <a id="3430" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3432" href="/20.07/BigStep/#3374" class="Bound">V</a>
      <a id="3440" class="Comment">---------------------------------------------------</a>
    <a id="3496" class="Symbol">→</a> <a id="3498" href="/20.07/BigStep/#3313" class="Bound">γ</a> <a id="3500" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="3502" href="/20.07/BigStep/#3328" class="Bound">L</a> <a id="3504" href="/20.07/Untyped/#4442" class="InductiveConstructor Operator">·</a> <a id="3506" href="/20.07/BigStep/#3330" class="Bound">M</a> <a id="3508" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="3510" href="/20.07/BigStep/#3374" class="Bound">V</a>
</pre>
<ul>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">⇓-var</code> rule evaluates a variable by finding the associated
closure in the environment and then evaluating the closure.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">⇓-lam</code> rule turns a lambda abstraction into a closure
by packaging it up with its environment.</p>
  </li>
  <li>
    <p>The <code class="language-plaintext highlighter-rouge">⇓-app</code> rule performs function application by first evaluating
the term <code class="language-plaintext highlighter-rouge">L</code> in operator position. If that produces a closure containing
a lambda abstraction <code class="language-plaintext highlighter-rouge">ƛ N</code>, then we evaluate the body <code class="language-plaintext highlighter-rouge">N</code> in an
environment extended with the argument <code class="language-plaintext highlighter-rouge">M</code>. Note that <code class="language-plaintext highlighter-rouge">M</code> is not
evaluated in rule <code class="language-plaintext highlighter-rouge">⇓-app</code> because this is call-by-name and not
call-by-value.</p>
  </li>
</ul>

<h4 id="exercise-big-step-eg-practice">Exercise <code class="language-plaintext highlighter-rouge">big-step-eg</code> (practice)</h4>

<p>Show that <code class="language-plaintext highlighter-rouge">(ƛ ƛ # 1) · ((ƛ # 0 · # 0) · (ƛ # 0 · # 0))</code>
terminates under big-step call-by-name evaluation.</p>

<pre class="Agda"><a id="4264" class="Comment">-- Your code goes here</a>
</pre>

<h2 id="the-big-step-semantics-is-deterministic">The big-step semantics is deterministic</h2>

<p>If the big-step relation evaluates a term <code class="language-plaintext highlighter-rouge">M</code> to both <code class="language-plaintext highlighter-rouge">V</code> and
<code class="language-plaintext highlighter-rouge">V′</code>, then <code class="language-plaintext highlighter-rouge">V</code> and <code class="language-plaintext highlighter-rouge">V′</code> must be identical. In other words, the
call-by-name relation is a partial function. The proof is a
straightforward induction on the two big-step derivations.</p>

<pre class="Agda"><a id="⇓-determ"></a><a id="4586" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4595" class="Symbol">:</a> <a id="4597" class="Symbol">∀{</a><a id="4599" href="/20.07/BigStep/#4599" class="Bound">Γ</a><a id="4600" class="Symbol">}{</a><a id="4602" href="/20.07/BigStep/#4602" class="Bound">γ</a> <a id="4604" class="Symbol">:</a> <a id="4606" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="4614" href="/20.07/BigStep/#4599" class="Bound">Γ</a><a id="4615" class="Symbol">}{</a><a id="4617" href="/20.07/BigStep/#4617" class="Bound">M</a> <a id="4619" class="Symbol">:</a> <a id="4621" href="/20.07/BigStep/#4599" class="Bound">Γ</a> <a id="4623" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="4625" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="4626" class="Symbol">}{</a><a id="4628" href="/20.07/BigStep/#4628" class="Bound">V</a> <a id="4630" href="/20.07/BigStep/#4630" class="Bound">V&#39;</a> <a id="4633" class="Symbol">:</a> <a id="4635" href="/20.07/BigStep/#2467" class="Datatype">Clos</a><a id="4639" class="Symbol">}</a>
  <a id="4643" class="Symbol">→</a> <a id="4645" href="/20.07/BigStep/#4602" class="Bound">γ</a> <a id="4647" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="4649" href="/20.07/BigStep/#4617" class="Bound">M</a> <a id="4651" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="4653" href="/20.07/BigStep/#4628" class="Bound">V</a> <a id="4655" class="Symbol">→</a> <a id="4657" href="/20.07/BigStep/#4602" class="Bound">γ</a> <a id="4659" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="4661" href="/20.07/BigStep/#4617" class="Bound">M</a> <a id="4663" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="4665" href="/20.07/BigStep/#4630" class="Bound">V&#39;</a>
  <a id="4670" class="Symbol">→</a> <a id="4672" href="/20.07/BigStep/#4628" class="Bound">V</a> <a id="4674" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="4676" href="/20.07/BigStep/#4630" class="Bound">V&#39;</a>
<a id="4679" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4688" class="Symbol">(</a><a id="4689" href="/20.07/BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="4695" href="/20.07/BigStep/#4695" class="Bound">eq1</a> <a id="4699" href="/20.07/BigStep/#4699" class="Bound">mc</a><a id="4701" class="Symbol">)</a> <a id="4703" class="Symbol">(</a><a id="4704" href="/20.07/BigStep/#3078" class="InductiveConstructor">⇓-var</a> <a id="4710" href="/20.07/BigStep/#4710" class="Bound">eq2</a> <a id="4714" href="/20.07/BigStep/#4714" class="Bound">mc&#39;</a><a id="4717" class="Symbol">)</a>
    <a id="4723" class="Keyword">with</a> <a id="4728" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#984" class="Function">trans</a> <a id="4734" class="Symbol">(</a><a id="4735" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#939" class="Function">sym</a> <a id="4739" href="/20.07/BigStep/#4695" class="Bound">eq1</a><a id="4742" class="Symbol">)</a> <a id="4744" href="/20.07/BigStep/#4710" class="Bound">eq2</a>
<a id="4748" class="Symbol">...</a> <a id="4752" class="Symbol">|</a> <a id="4754" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="4759" class="Symbol">=</a> <a id="4761" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4770" class="Bound">mc</a> <a id="4773" class="Bound">mc&#39;</a>
<a id="4777" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4786" href="/20.07/BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="4792" href="/20.07/BigStep/#3225" class="InductiveConstructor">⇓-lam</a> <a id="4798" class="Symbol">=</a> <a id="4800" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="4805" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4814" class="Symbol">(</a><a id="4815" href="/20.07/BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="4821" href="/20.07/BigStep/#4821" class="Bound">mc</a> <a id="4824" href="/20.07/BigStep/#4824" class="Bound">mc₁</a><a id="4827" class="Symbol">)</a> <a id="4829" class="Symbol">(</a><a id="4830" href="/20.07/BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="4836" href="/20.07/BigStep/#4836" class="Bound">mc&#39;</a> <a id="4840" href="/20.07/BigStep/#4840" class="Bound">mc&#39;&#39;</a><a id="4844" class="Symbol">)</a>
    <a id="4850" class="Keyword">with</a> <a id="4855" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4864" href="/20.07/BigStep/#4821" class="Bound">mc</a> <a id="4867" href="/20.07/BigStep/#4836" class="Bound">mc&#39;</a>
<a id="4871" class="Symbol">...</a> <a id="4875" class="Symbol">|</a> <a id="4877" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="4882" class="Symbol">=</a> <a id="4884" href="/20.07/BigStep/#4586" class="Function">⇓-determ</a> <a id="4893" class="Bound">mc₁</a> <a id="4897" class="Bound">mc&#39;&#39;</a>
</pre>

<h2 id="big-step-evaluation-implies-beta-reduction-to-a-lambda">Big-step evaluation implies beta reduction to a lambda</h2>

<p>If big-step evaluation produces a value, then the input term can
reduce to a lambda abstraction by beta reduction:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ∅' ⊢ M ⇓ clos (ƛ N′) δ
  -----------------------------
→ Σ[ N ∈ ∅ , ★ ⊢ ★ ] (M —↠ ƛ N)
</code></pre></div></div>

<p>The proof is by induction on the big-step derivation. As is often
necessary, one must generalize the statement to get the induction to
go through. In the case for <code class="language-plaintext highlighter-rouge">⇓-app</code> (function application), the
argument is added to the environment, so the environment becomes
non-empty. The corresponding β reduction substitutes the argument into
the body of the lambda abstraction.  So we generalize the lemma to
allow an arbitrary environment <code class="language-plaintext highlighter-rouge">γ</code> and we add a premise that relates
the environment <code class="language-plaintext highlighter-rouge">γ</code> to an equivalent substitution <code class="language-plaintext highlighter-rouge">σ</code>.</p>

<p>The case for <code class="language-plaintext highlighter-rouge">⇓-app</code> also requires that we strengthen the
conclusion. In the case for <code class="language-plaintext highlighter-rouge">⇓-app</code> we have <code class="language-plaintext highlighter-rouge">γ ⊢ L ⇓ clos (λ N) δ</code> and
the induction hypothesis gives us <code class="language-plaintext highlighter-rouge">L —↠ ƛ N′</code>, but we need to know
that <code class="language-plaintext highlighter-rouge">N</code> and <code class="language-plaintext highlighter-rouge">N′</code> are equivalent. In particular, that <code class="language-plaintext highlighter-rouge">N′ ≡ subst τ N</code>
where <code class="language-plaintext highlighter-rouge">τ</code> is the substitution that is equivalent to <code class="language-plaintext highlighter-rouge">δ</code>. Therefore we
expand the conclusion of the statement, stating that the results are
equivalent.</p>

<p>We make the two notions of equivalence precise by defining the
following two mutually-recursive predicates <code class="language-plaintext highlighter-rouge">V ≈ M</code> and <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>.</p>

<pre class="Agda"><a id="_≈_"></a><a id="6265" href="/20.07/BigStep/#6265" class="Function Operator">_≈_</a> <a id="6269" class="Symbol">:</a> <a id="6271" href="/20.07/BigStep/#2467" class="Datatype">Clos</a> <a id="6276" class="Symbol">→</a> <a id="6278" class="Symbol">(</a><a id="6279" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="6281" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="6283" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="6284" class="Symbol">)</a> <a id="6286" class="Symbol">→</a> <a id="6288" class="PrimitiveType">Set</a>
<a id="_≈ₑ_"></a><a id="6292" href="/20.07/BigStep/#6292" class="Function Operator">_≈ₑ_</a> <a id="6297" class="Symbol">:</a> <a id="6299" class="Symbol">∀{</a><a id="6301" href="/20.07/BigStep/#6301" class="Bound">Γ</a><a id="6302" class="Symbol">}</a> <a id="6304" class="Symbol">→</a> <a id="6306" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="6314" href="/20.07/BigStep/#6301" class="Bound">Γ</a> <a id="6316" class="Symbol">→</a> <a id="6318" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="6324" href="/20.07/BigStep/#6301" class="Bound">Γ</a> <a id="6326" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="6328" class="Symbol">→</a> <a id="6330" class="PrimitiveType">Set</a>

<a id="6335" class="Symbol">(</a><a id="6336" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="6341" class="Symbol">{</a><a id="6342" href="/20.07/BigStep/#6342" class="Bound">Γ</a><a id="6343" class="Symbol">}</a> <a id="6345" href="/20.07/BigStep/#6345" class="Bound">M</a> <a id="6347" href="/20.07/BigStep/#6347" class="Bound">γ</a><a id="6348" class="Symbol">)</a> <a id="6350" href="/20.07/BigStep/#6265" class="Function Operator">≈</a> <a id="6352" href="/20.07/BigStep/#6352" class="Bound">N</a> <a id="6354" class="Symbol">=</a> <a id="6356" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="6359" href="/20.07/BigStep/#6359" class="Bound">σ</a> <a id="6361" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="6363" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="6369" href="/20.07/BigStep/#6342" class="Bound">Γ</a> <a id="6371" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="6373" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="6375" href="/20.07/BigStep/#6347" class="Bound">γ</a> <a id="6377" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6380" href="/20.07/BigStep/#6359" class="Bound">σ</a> <a id="6382" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">×</a> <a id="6384" class="Symbol">(</a><a id="6385" href="/20.07/BigStep/#6352" class="Bound">N</a> <a id="6387" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="6389" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="6395" href="/20.07/BigStep/#6359" class="Bound">σ</a> <a id="6397" href="/20.07/BigStep/#6345" class="Bound">M</a><a id="6398" class="Symbol">)</a>

<a id="6401" href="/20.07/BigStep/#6401" class="Bound">γ</a> <a id="6403" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6406" href="/20.07/BigStep/#6406" class="Bound">σ</a> <a id="6408" class="Symbol">=</a> <a id="6410" class="Symbol">∀{</a><a id="6412" href="/20.07/BigStep/#6412" class="Bound">x</a><a id="6413" class="Symbol">}</a> <a id="6415" class="Symbol">→</a> <a id="6417" class="Symbol">(</a><a id="6418" href="/20.07/BigStep/#6401" class="Bound">γ</a> <a id="6420" href="/20.07/BigStep/#6412" class="Bound">x</a><a id="6421" class="Symbol">)</a> <a id="6423" href="/20.07/BigStep/#6265" class="Function Operator">≈</a> <a id="6425" class="Symbol">(</a><a id="6426" href="/20.07/BigStep/#6406" class="Bound">σ</a> <a id="6428" href="/20.07/BigStep/#6412" class="Bound">x</a><a id="6429" class="Symbol">)</a>
</pre>
<p>We can now state the main lemma:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>If γ ⊢ M ⇓ V  and  γ ≈ₑ σ,
then  subst σ M —↠ N  and  V ≈ N  for some N.
</code></pre></div></div>

<p>Before starting the proof, we establish a couple lemmas
about equivalent environments and substitutions.</p>

<p>The empty environment is equivalent to the identity substitution
<code class="language-plaintext highlighter-rouge">ids</code>, which we import from Chapter <a href="/20.07/Substitution/">Substitution</a>.</p>

<pre class="Agda"><a id="≈ₑ-id"></a><a id="6814" href="/20.07/BigStep/#6814" class="Function">≈ₑ-id</a> <a id="6820" class="Symbol">:</a> <a id="6822" href="/20.07/BigStep/#2650" class="Function">∅&#39;</a> <a id="6825" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="6828" href="/20.07/Substitution/#3046" class="Function">ids</a>
<a id="6832" href="/20.07/BigStep/#6814" class="Function">≈ₑ-id</a> <a id="6838" class="Symbol">{()}</a>
</pre>
<p>Of course, applying the identity substitution to a term returns
the same term.</p>

<pre class="Agda"><a id="sub-id"></a><a id="6932" href="/20.07/BigStep/#6932" class="Function">sub-id</a> <a id="6939" class="Symbol">:</a> <a id="6941" class="Symbol">∀{</a><a id="6943" href="/20.07/BigStep/#6943" class="Bound">Γ</a><a id="6944" class="Symbol">}</a> <a id="6946" class="Symbol">{</a><a id="6947" href="/20.07/BigStep/#6947" class="Bound">A</a><a id="6948" class="Symbol">}</a> <a id="6950" class="Symbol">{</a><a id="6951" href="/20.07/BigStep/#6951" class="Bound">M</a> <a id="6953" class="Symbol">:</a> <a id="6955" href="/20.07/BigStep/#6943" class="Bound">Γ</a> <a id="6957" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="6959" href="/20.07/BigStep/#6947" class="Bound">A</a><a id="6960" class="Symbol">}</a> <a id="6962" class="Symbol">→</a> <a id="6964" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="6970" href="/20.07/Substitution/#3046" class="Function">ids</a> <a id="6974" href="/20.07/BigStep/#6951" class="Bound">M</a> <a id="6976" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="6978" href="/20.07/BigStep/#6951" class="Bound">M</a>
<a id="6980" href="/20.07/BigStep/#6932" class="Function">sub-id</a> <a id="6987" class="Symbol">=</a> <a id="6989" href="/20.07/Substitution/#16936" class="Function">plfa.part2.Substitution.sub-id</a>
</pre>

<p>We define an auxilliary function for extending a substitution.</p>

<pre class="Agda"><a id="ext-subst"></a><a id="7094" href="/20.07/BigStep/#7094" class="Function">ext-subst</a> <a id="7104" class="Symbol">:</a> <a id="7106" class="Symbol">∀{</a><a id="7108" href="/20.07/BigStep/#7108" class="Bound">Γ</a> <a id="7110" href="/20.07/BigStep/#7110" class="Bound">Δ</a><a id="7111" class="Symbol">}</a> <a id="7113" class="Symbol">→</a> <a id="7115" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="7121" href="/20.07/BigStep/#7108" class="Bound">Γ</a> <a id="7123" href="/20.07/BigStep/#7110" class="Bound">Δ</a> <a id="7125" class="Symbol">→</a> <a id="7127" href="/20.07/BigStep/#7110" class="Bound">Δ</a> <a id="7129" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="7131" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="7133" class="Symbol">→</a> <a id="7135" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="7141" class="Symbol">(</a><a id="7142" href="/20.07/BigStep/#7108" class="Bound">Γ</a> <a id="7144" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="7146" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="7147" class="Symbol">)</a> <a id="7149" href="/20.07/BigStep/#7110" class="Bound">Δ</a>
<a id="7151" href="/20.07/BigStep/#7094" class="Function">ext-subst</a><a id="7160" class="Symbol">{</a><a id="7161" href="/20.07/BigStep/#7161" class="Bound">Γ</a><a id="7162" class="Symbol">}{</a><a id="7164" href="/20.07/BigStep/#7164" class="Bound">Δ</a><a id="7165" class="Symbol">}</a> <a id="7167" href="/20.07/BigStep/#7167" class="Bound">σ</a> <a id="7169" href="/20.07/BigStep/#7169" class="Bound">N</a> <a id="7171" class="Symbol">{</a><a id="7172" href="/20.07/BigStep/#7172" class="Bound">A</a><a id="7173" class="Symbol">}</a> <a id="7175" class="Symbol">=</a> <a id="7177" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="7183" class="Symbol">(</a><a id="7184" href="/20.07/Untyped/#7375" class="Function">subst-zero</a> <a id="7195" href="/20.07/BigStep/#7169" class="Bound">N</a><a id="7196" class="Symbol">)</a> <a id="7198" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="7200" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="7205" href="/20.07/BigStep/#7167" class="Bound">σ</a>
</pre>
<p>The next lemma we need to prove states that if you start with an
equivalent environment and substitution <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>, extending them with
an equivalent closure and term <code class="language-plaintext highlighter-rouge">c ≈ N</code> produces an equivalent
environment and substitution: <code class="language-plaintext highlighter-rouge">(γ ,' V) ≈ₑ (ext-subst σ N)</code>,
or equivalently, <code class="language-plaintext highlighter-rouge">(γ ,' V) x ≈ₑ (ext-subst σ N) x</code> for any
variable <code class="language-plaintext highlighter-rouge">x</code>. The proof will be by induction on <code class="language-plaintext highlighter-rouge">x</code> and
for the induction step we need the following lemma,
which states that applying the composition of <code class="language-plaintext highlighter-rouge">exts σ</code>
and <code class="language-plaintext highlighter-rouge">subst-zero</code> to <code class="language-plaintext highlighter-rouge">S x</code> is the same as just <code class="language-plaintext highlighter-rouge">σ x</code>,
which is a corollary of a theorem in
Chapter <a href="/20.07/Substitution/">Substitution</a>.</p>

<pre class="Agda"><a id="subst-zero-exts"></a><a id="7845" href="/20.07/BigStep/#7845" class="Function">subst-zero-exts</a> <a id="7861" class="Symbol">:</a> <a id="7863" class="Symbol">∀{</a><a id="7865" href="/20.07/BigStep/#7865" class="Bound">Γ</a> <a id="7867" href="/20.07/BigStep/#7867" class="Bound">Δ</a><a id="7868" class="Symbol">}{</a><a id="7870" href="/20.07/BigStep/#7870" class="Bound">σ</a> <a id="7872" class="Symbol">:</a> <a id="7874" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="7880" href="/20.07/BigStep/#7865" class="Bound">Γ</a> <a id="7882" href="/20.07/BigStep/#7867" class="Bound">Δ</a><a id="7883" class="Symbol">}{</a><a id="7885" href="/20.07/BigStep/#7885" class="Bound">B</a><a id="7886" class="Symbol">}{</a><a id="7888" href="/20.07/BigStep/#7888" class="Bound">M</a> <a id="7890" class="Symbol">:</a> <a id="7892" href="/20.07/BigStep/#7867" class="Bound">Δ</a> <a id="7894" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="7896" href="/20.07/BigStep/#7885" class="Bound">B</a><a id="7897" class="Symbol">}{</a><a id="7899" href="/20.07/BigStep/#7899" class="Bound">x</a> <a id="7901" class="Symbol">:</a> <a id="7903" href="/20.07/BigStep/#7865" class="Bound">Γ</a> <a id="7905" href="/20.07/Untyped/#3521" class="Datatype Operator">∋</a> <a id="7907" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="7908" class="Symbol">}</a>
  <a id="7912" class="Symbol">→</a> <a id="7914" class="Symbol">(</a><a id="7915" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="7921" class="Symbol">(</a><a id="7922" href="/20.07/Untyped/#7375" class="Function">subst-zero</a> <a id="7933" href="/20.07/BigStep/#7888" class="Bound">M</a><a id="7934" class="Symbol">)</a> <a id="7936" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="7938" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="7943" href="/20.07/BigStep/#7870" class="Bound">σ</a><a id="7944" class="Symbol">)</a> <a id="7946" class="Symbol">(</a><a id="7947" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S</a> <a id="7949" href="/20.07/BigStep/#7899" class="Bound">x</a><a id="7950" class="Symbol">)</a> <a id="7952" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="7954" href="/20.07/BigStep/#7870" class="Bound">σ</a> <a id="7956" href="/20.07/BigStep/#7899" class="Bound">x</a>
<a id="7958" href="/20.07/BigStep/#7845" class="Function">subst-zero-exts</a> <a id="7974" class="Symbol">{</a><a id="7975" href="/20.07/BigStep/#7975" class="Bound">Γ</a><a id="7976" class="Symbol">}{</a><a id="7978" href="/20.07/BigStep/#7978" class="Bound">Δ</a><a id="7979" class="Symbol">}{</a><a id="7981" href="/20.07/BigStep/#7981" class="Bound">σ</a><a id="7982" class="Symbol">}{</a><a id="7984" href="/20.07/BigStep/#7984" class="Bound">B</a><a id="7985" class="Symbol">}{</a><a id="7987" href="/20.07/BigStep/#7987" class="Bound">M</a><a id="7988" class="Symbol">}{</a><a id="7990" href="/20.07/BigStep/#7990" class="Bound">x</a><a id="7991" class="Symbol">}</a> <a id="7993" class="Symbol">=</a>
   <a id="7998" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html#1308" class="Function">cong-app</a> <a id="8007" class="Symbol">(</a><a id="8008" href="/20.07/Substitution/#25138" class="Function">plfa.part2.Substitution.subst-zero-exts-cons</a><a id="8052" class="Symbol">{</a><a id="8053" class="Argument">σ</a> <a id="8055" class="Symbol">=</a> <a id="8057" href="/20.07/BigStep/#7981" class="Bound">σ</a><a id="8058" class="Symbol">})</a> <a id="8061" class="Symbol">(</a><a id="8062" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S</a> <a id="8064" href="/20.07/BigStep/#7990" class="Bound">x</a><a id="8065" class="Symbol">)</a>
</pre>
<p>So the proof of <code class="language-plaintext highlighter-rouge">≈ₑ-ext</code> is as follows.</p>

<pre class="Agda"><a id="≈ₑ-ext"></a><a id="8117" href="/20.07/BigStep/#8117" class="Function">≈ₑ-ext</a> <a id="8124" class="Symbol">:</a> <a id="8126" class="Symbol">∀</a> <a id="8128" class="Symbol">{</a><a id="8129" href="/20.07/BigStep/#8129" class="Bound">Γ</a><a id="8130" class="Symbol">}</a> <a id="8132" class="Symbol">{</a><a id="8133" href="/20.07/BigStep/#8133" class="Bound">γ</a> <a id="8135" class="Symbol">:</a> <a id="8137" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="8145" href="/20.07/BigStep/#8129" class="Bound">Γ</a><a id="8146" class="Symbol">}</a> <a id="8148" class="Symbol">{</a><a id="8149" href="/20.07/BigStep/#8149" class="Bound">σ</a> <a id="8151" class="Symbol">:</a> <a id="8153" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="8159" href="/20.07/BigStep/#8129" class="Bound">Γ</a> <a id="8161" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a><a id="8162" class="Symbol">}</a> <a id="8164" class="Symbol">{</a><a id="8165" href="/20.07/BigStep/#8165" class="Bound">V</a><a id="8166" class="Symbol">}</a> <a id="8168" class="Symbol">{</a><a id="8169" href="/20.07/BigStep/#8169" class="Bound">N</a> <a id="8171" class="Symbol">:</a> <a id="8173" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="8175" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="8177" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="8178" class="Symbol">}</a>
  <a id="8182" class="Symbol">→</a> <a id="8184" href="/20.07/BigStep/#8133" class="Bound">γ</a> <a id="8186" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="8189" href="/20.07/BigStep/#8149" class="Bound">σ</a>  <a id="8192" class="Symbol">→</a>  <a id="8195" href="/20.07/BigStep/#8165" class="Bound">V</a> <a id="8197" href="/20.07/BigStep/#6265" class="Function Operator">≈</a> <a id="8199" href="/20.07/BigStep/#8169" class="Bound">N</a>
    <a id="8205" class="Comment">--------------------------</a>
  <a id="8234" class="Symbol">→</a> <a id="8236" class="Symbol">(</a><a id="8237" href="/20.07/BigStep/#8133" class="Bound">γ</a> <a id="8239" href="/20.07/BigStep/#2672" class="Function Operator">,&#39;</a> <a id="8242" href="/20.07/BigStep/#8165" class="Bound">V</a><a id="8243" class="Symbol">)</a> <a id="8245" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="8248" class="Symbol">(</a><a id="8249" href="/20.07/BigStep/#7094" class="Function">ext-subst</a> <a id="8259" href="/20.07/BigStep/#8149" class="Bound">σ</a> <a id="8261" href="/20.07/BigStep/#8169" class="Bound">N</a><a id="8262" class="Symbol">)</a>
<a id="8264" href="/20.07/BigStep/#8117" class="Function">≈ₑ-ext</a> <a id="8271" class="Symbol">{</a><a id="8272" href="/20.07/BigStep/#8272" class="Bound">Γ</a><a id="8273" class="Symbol">}</a> <a id="8275" class="Symbol">{</a><a id="8276" href="/20.07/BigStep/#8276" class="Bound">γ</a><a id="8277" class="Symbol">}</a> <a id="8279" class="Symbol">{</a><a id="8280" href="/20.07/BigStep/#8280" class="Bound">σ</a><a id="8281" class="Symbol">}</a> <a id="8283" class="Symbol">{</a><a id="8284" href="/20.07/BigStep/#8284" class="Bound">V</a><a id="8285" class="Symbol">}</a> <a id="8287" class="Symbol">{</a><a id="8288" href="/20.07/BigStep/#8288" class="Bound">N</a><a id="8289" class="Symbol">}</a> <a id="8291" href="/20.07/BigStep/#8291" class="Bound">γ≈ₑσ</a> <a id="8296" href="/20.07/BigStep/#8296" class="Bound">V≈N</a> <a id="8300" class="Symbol">{</a><a id="8301" href="/20.07/Untyped/#3557" class="InductiveConstructor">Z</a><a id="8302" class="Symbol">}</a> <a id="8304" class="Symbol">=</a> <a id="8306" href="/20.07/BigStep/#8296" class="Bound">V≈N</a>
<a id="8310" href="/20.07/BigStep/#8117" class="Function">≈ₑ-ext</a> <a id="8317" class="Symbol">{</a><a id="8318" href="/20.07/BigStep/#8318" class="Bound">Γ</a><a id="8319" class="Symbol">}</a> <a id="8321" class="Symbol">{</a><a id="8322" href="/20.07/BigStep/#8322" class="Bound">γ</a><a id="8323" class="Symbol">}</a> <a id="8325" class="Symbol">{</a><a id="8326" href="/20.07/BigStep/#8326" class="Bound">σ</a><a id="8327" class="Symbol">}</a> <a id="8329" class="Symbol">{</a><a id="8330" href="/20.07/BigStep/#8330" class="Bound">V</a><a id="8331" class="Symbol">}</a> <a id="8333" class="Symbol">{</a><a id="8334" href="/20.07/BigStep/#8334" class="Bound">N</a><a id="8335" class="Symbol">}</a> <a id="8337" href="/20.07/BigStep/#8337" class="Bound">γ≈ₑσ</a> <a id="8342" href="/20.07/BigStep/#8342" class="Bound">V≈N</a> <a id="8346" class="Symbol">{</a><a id="8347" href="/20.07/Untyped/#3602" class="InductiveConstructor Operator">S</a> <a id="8349" href="/20.07/BigStep/#8349" class="Bound">x</a><a id="8350" class="Symbol">}</a>
  <a id="8354" class="Keyword">rewrite</a> <a id="8362" href="/20.07/BigStep/#7845" class="Function">subst-zero-exts</a> <a id="8378" class="Symbol">{</a><a id="8379" class="Argument">σ</a> <a id="8381" class="Symbol">=</a> <a id="8383" href="/20.07/BigStep/#8326" class="Bound">σ</a><a id="8384" class="Symbol">}{</a><a id="8386" class="Argument">M</a> <a id="8388" class="Symbol">=</a> <a id="8390" href="/20.07/BigStep/#8334" class="Bound">N</a><a id="8391" class="Symbol">}{</a><a id="8393" href="/20.07/BigStep/#8349" class="Bound">x</a><a id="8394" class="Symbol">}</a> <a id="8396" class="Symbol">=</a> <a id="8398" href="/20.07/BigStep/#8337" class="Bound">γ≈ₑσ</a>
</pre>
<p>We proceed by induction on the input variable.</p>

<ul>
  <li>
    <p>If it is <code class="language-plaintext highlighter-rouge">Z</code>, then we immediately conclude using the
premise <code class="language-plaintext highlighter-rouge">V ≈ N</code>.</p>
  </li>
  <li>
    <p>If it is <code class="language-plaintext highlighter-rouge">S x</code>, then we rewrite using the
<code class="language-plaintext highlighter-rouge">subst-zero-exts</code> lemma and use the premise <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>
to conclude.</p>
  </li>
</ul>

<p>To prove the main lemma, we need another technical lemma about
substitution. Applying one substitution after another is the same as
composing the two substitutions and then applying them.</p>

<pre class="Agda"><a id="sub-sub"></a><a id="8840" href="/20.07/BigStep/#8840" class="Function">sub-sub</a> <a id="8848" class="Symbol">:</a> <a id="8850" class="Symbol">∀{</a><a id="8852" href="/20.07/BigStep/#8852" class="Bound">Γ</a> <a id="8854" href="/20.07/BigStep/#8854" class="Bound">Δ</a> <a id="8856" href="/20.07/BigStep/#8856" class="Bound">Σ</a><a id="8857" class="Symbol">}{</a><a id="8859" href="/20.07/BigStep/#8859" class="Bound">A</a><a id="8860" class="Symbol">}{</a><a id="8862" href="/20.07/BigStep/#8862" class="Bound">M</a> <a id="8864" class="Symbol">:</a> <a id="8866" href="/20.07/BigStep/#8852" class="Bound">Γ</a> <a id="8868" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="8870" href="/20.07/BigStep/#8859" class="Bound">A</a><a id="8871" class="Symbol">}</a> <a id="8873" class="Symbol">{</a><a id="8874" href="/20.07/BigStep/#8874" class="Bound">σ₁</a> <a id="8877" class="Symbol">:</a> <a id="8879" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="8885" href="/20.07/BigStep/#8852" class="Bound">Γ</a> <a id="8887" href="/20.07/BigStep/#8854" class="Bound">Δ</a><a id="8888" class="Symbol">}{</a><a id="8890" href="/20.07/BigStep/#8890" class="Bound">σ₂</a> <a id="8893" class="Symbol">:</a> <a id="8895" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="8901" href="/20.07/BigStep/#8854" class="Bound">Δ</a> <a id="8903" href="/20.07/BigStep/#8856" class="Bound">Σ</a><a id="8904" class="Symbol">}</a>
  <a id="8908" class="Symbol">→</a> <a id="8910" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="8916" href="/20.07/BigStep/#8890" class="Bound">σ₂</a> <a id="8919" class="Symbol">(</a><a id="8920" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="8926" href="/20.07/BigStep/#8874" class="Bound">σ₁</a> <a id="8929" href="/20.07/BigStep/#8862" class="Bound">M</a><a id="8930" class="Symbol">)</a> <a id="8932" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="8934" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="8940" class="Symbol">(</a><a id="8941" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="8947" href="/20.07/BigStep/#8890" class="Bound">σ₂</a> <a id="8950" href="https://agda.github.io/agda-stdlib/v1.1/Function.html#1099" class="Function Operator">∘</a> <a id="8952" href="/20.07/BigStep/#8874" class="Bound">σ₁</a><a id="8954" class="Symbol">)</a> <a id="8956" href="/20.07/BigStep/#8862" class="Bound">M</a>
<a id="8958" href="/20.07/BigStep/#8840" class="Function">sub-sub</a> <a id="8966" class="Symbol">{</a><a id="8967" class="Argument">M</a> <a id="8969" class="Symbol">=</a> <a id="8971" href="/20.07/BigStep/#8971" class="Bound">M</a><a id="8972" class="Symbol">}</a> <a id="8974" class="Symbol">=</a> <a id="8976" href="/20.07/Substitution/#22915" class="Function">plfa.part2.Substitution.sub-sub</a> <a id="9008" class="Symbol">{</a><a id="9009" class="Argument">M</a> <a id="9011" class="Symbol">=</a> <a id="9013" href="/20.07/BigStep/#8971" class="Bound">M</a><a id="9014" class="Symbol">}</a>
</pre>
<p>We arive at the main lemma: if <code class="language-plaintext highlighter-rouge">M</code> big steps to a
closure <code class="language-plaintext highlighter-rouge">V</code> in environment <code class="language-plaintext highlighter-rouge">γ</code>, and if <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>, then <code class="language-plaintext highlighter-rouge">subst σ M</code> reduces
to some term <code class="language-plaintext highlighter-rouge">N</code> that is equivalent to <code class="language-plaintext highlighter-rouge">V</code>. We describe the proof
below.</p>

<pre class="Agda"><a id="⇓→—↠×≈"></a><a id="9223" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a> <a id="9230" class="Symbol">:</a> <a id="9232" class="Symbol">∀{</a><a id="9234" href="/20.07/BigStep/#9234" class="Bound">Γ</a><a id="9235" class="Symbol">}{</a><a id="9237" href="/20.07/BigStep/#9237" class="Bound">γ</a> <a id="9239" class="Symbol">:</a> <a id="9241" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="9249" href="/20.07/BigStep/#9234" class="Bound">Γ</a><a id="9250" class="Symbol">}{</a><a id="9252" href="/20.07/BigStep/#9252" class="Bound">σ</a> <a id="9254" class="Symbol">:</a> <a id="9256" href="/20.07/Substitution/#2405" class="Function">Subst</a> <a id="9262" href="/20.07/BigStep/#9234" class="Bound">Γ</a> <a id="9264" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a><a id="9265" class="Symbol">}{</a><a id="9267" href="/20.07/BigStep/#9267" class="Bound">M</a> <a id="9269" class="Symbol">:</a> <a id="9271" href="/20.07/BigStep/#9234" class="Bound">Γ</a> <a id="9273" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="9275" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="9276" class="Symbol">}{</a><a id="9278" href="/20.07/BigStep/#9278" class="Bound">V</a> <a id="9280" class="Symbol">:</a> <a id="9282" href="/20.07/BigStep/#2467" class="Datatype">Clos</a><a id="9286" class="Symbol">}</a>
       <a id="9295" class="Symbol">→</a> <a id="9297" href="/20.07/BigStep/#9237" class="Bound">γ</a> <a id="9299" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="9301" href="/20.07/BigStep/#9267" class="Bound">M</a> <a id="9303" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="9305" href="/20.07/BigStep/#9278" class="Bound">V</a>  <a id="9308" class="Symbol">→</a>  <a id="9311" href="/20.07/BigStep/#9237" class="Bound">γ</a> <a id="9313" href="/20.07/BigStep/#6292" class="Function Operator">≈ₑ</a> <a id="9316" href="/20.07/BigStep/#9252" class="Bound">σ</a>
         <a id="9327" class="Comment">---------------------------------------</a>
       <a id="9374" class="Symbol">→</a> <a id="9376" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="9379" href="/20.07/BigStep/#9379" class="Bound">N</a> <a id="9381" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="9383" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="9385" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="9387" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="9389" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="9391" class="Symbol">(</a><a id="9392" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="9398" href="/20.07/BigStep/#9252" class="Bound">σ</a> <a id="9400" href="/20.07/BigStep/#9267" class="Bound">M</a> <a id="9402" href="/20.07/Untyped/#11068" class="Datatype Operator">—↠</a> <a id="9405" href="/20.07/BigStep/#9379" class="Bound">N</a><a id="9406" class="Symbol">)</a> <a id="9408" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">×</a> <a id="9410" href="/20.07/BigStep/#9278" class="Bound">V</a> <a id="9412" href="/20.07/BigStep/#6265" class="Function Operator">≈</a> <a id="9414" href="/20.07/BigStep/#9379" class="Bound">N</a>
<a id="9416" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a> <a id="9423" class="Symbol">{</a><a id="9424" class="Argument">γ</a> <a id="9426" class="Symbol">=</a> <a id="9428" href="/20.07/BigStep/#9428" class="Bound">γ</a><a id="9429" class="Symbol">}</a> <a id="9431" class="Symbol">(</a><a id="9432" href="/20.07/BigStep/#3078" class="InductiveConstructor">⇓-var</a><a id="9437" class="Symbol">{</a><a id="9438" class="Argument">x</a> <a id="9440" class="Symbol">=</a> <a id="9442" href="/20.07/BigStep/#9442" class="Bound">x</a><a id="9443" class="Symbol">}</a> <a id="9445" href="/20.07/BigStep/#9445" class="Bound">γx≡Lδ</a> <a id="9451" href="/20.07/BigStep/#9451" class="Bound">δ⊢L⇓V</a><a id="9456" class="Symbol">)</a> <a id="9458" href="/20.07/BigStep/#9458" class="Bound">γ≈ₑσ</a>
    <a id="9467" class="Keyword">with</a> <a id="9472" href="/20.07/BigStep/#9428" class="Bound">γ</a> <a id="9474" href="/20.07/BigStep/#9442" class="Bound">x</a> <a id="9476" class="Symbol">|</a> <a id="9478" href="/20.07/BigStep/#9458" class="Bound">γ≈ₑσ</a> <a id="9483" class="Symbol">{</a><a id="9484" href="/20.07/BigStep/#9442" class="Bound">x</a><a id="9485" class="Symbol">}</a> <a id="9487" class="Symbol">|</a> <a id="9489" href="/20.07/BigStep/#9445" class="Bound">γx≡Lδ</a>
<a id="9495" class="Symbol">...</a> <a id="9499" class="Symbol">|</a> <a id="9501" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="9506" href="/20.07/BigStep/#9506" class="Bound">L</a> <a id="9508" href="/20.07/BigStep/#9508" class="Bound">δ</a> <a id="9510" class="Symbol">|</a> <a id="9512" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9514" href="/20.07/BigStep/#9514" class="Bound">τ</a> <a id="9516" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9518" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9520" href="/20.07/BigStep/#9520" class="Bound">δ≈ₑτ</a> <a id="9525" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9527" href="/20.07/BigStep/#9527" class="Bound">σx≡τL</a> <a id="9533" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9535" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9537" class="Symbol">|</a> <a id="9539" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
      <a id="9550" class="Keyword">with</a> <a id="9555" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a><a id="9561" class="Symbol">{</a><a id="9562" class="Argument">σ</a> <a id="9564" class="Symbol">=</a> <a id="9566" href="/20.07/BigStep/#9514" class="Bound">τ</a><a id="9567" class="Symbol">}</a> <a id="9569" class="Bound">δ⊢L⇓V</a> <a id="9575" href="/20.07/BigStep/#9520" class="Bound">δ≈ₑτ</a>
<a id="9580" class="Symbol">...</a>   <a id="9586" class="Symbol">|</a> <a id="9588" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9590" href="/20.07/BigStep/#9590" class="Bound">N</a> <a id="9592" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9594" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9596" href="/20.07/BigStep/#9596" class="Bound">τL—↠N</a> <a id="9602" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9604" href="/20.07/BigStep/#9604" class="Bound">V≈N</a> <a id="9608" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9610" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9612" class="Keyword">rewrite</a> <a id="9620" class="Bound">σx≡τL</a> <a id="9626" class="Symbol">=</a>
        <a id="9636" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9638" href="/20.07/BigStep/#9590" class="Bound">N</a> <a id="9640" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9642" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9644" href="/20.07/BigStep/#9596" class="Bound">τL—↠N</a> <a id="9650" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9652" href="/20.07/BigStep/#9604" class="Bound">V≈N</a> <a id="9656" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9658" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
<a id="9660" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a> <a id="9667" class="Symbol">{</a><a id="9668" class="Argument">σ</a> <a id="9670" class="Symbol">=</a> <a id="9672" href="/20.07/BigStep/#9672" class="Bound">σ</a><a id="9673" class="Symbol">}</a> <a id="9675" class="Symbol">{</a><a id="9676" class="Argument">V</a> <a id="9678" class="Symbol">=</a> <a id="9680" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="9685" class="Symbol">(</a><a id="9686" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="9688" href="/20.07/BigStep/#9688" class="Bound">N</a><a id="9689" class="Symbol">)</a> <a id="9691" href="/20.07/BigStep/#9691" class="Bound">γ</a><a id="9692" class="Symbol">}</a> <a id="9694" class="Symbol">(</a><a id="9695" href="/20.07/BigStep/#3225" class="InductiveConstructor">⇓-lam</a><a id="9700" class="Symbol">)</a> <a id="9702" href="/20.07/BigStep/#9702" class="Bound">γ≈ₑσ</a> <a id="9707" class="Symbol">=</a>
    <a id="9713" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9715" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="9721" href="/20.07/BigStep/#9672" class="Bound">σ</a> <a id="9723" class="Symbol">(</a><a id="9724" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="9726" href="/20.07/BigStep/#9688" class="Bound">N</a><a id="9727" class="Symbol">)</a> <a id="9729" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9731" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9733" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="9739" href="/20.07/BigStep/#9672" class="Bound">σ</a> <a id="9741" class="Symbol">(</a><a id="9742" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="9744" href="/20.07/BigStep/#9688" class="Bound">N</a><a id="9745" class="Symbol">)</a> <a id="9747" href="/20.07/Untyped/#11118" class="InductiveConstructor Operator">∎</a> <a id="9749" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9751" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9753" href="/20.07/BigStep/#9672" class="Bound">σ</a> <a id="9755" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9757" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9759" href="/20.07/BigStep/#9702" class="Bound">γ≈ₑσ</a> <a id="9764" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9766" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="9771" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9773" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9775" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9777" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
<a id="9779" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a><a id="9785" class="Symbol">{</a><a id="9786" href="/20.07/BigStep/#9786" class="Bound">Γ</a><a id="9787" class="Symbol">}{</a><a id="9789" href="/20.07/BigStep/#9789" class="Bound">γ</a><a id="9790" class="Symbol">}</a> <a id="9792" class="Symbol">{</a><a id="9793" class="Argument">σ</a> <a id="9795" class="Symbol">=</a> <a id="9797" href="/20.07/BigStep/#9797" class="Bound">σ</a><a id="9798" class="Symbol">}</a> <a id="9800" class="Symbol">{</a><a id="9801" href="/20.07/BigStep/#9801" class="Bound">L</a> <a id="9803" href="/20.07/Untyped/#4442" class="InductiveConstructor Operator">·</a> <a id="9805" href="/20.07/BigStep/#9805" class="Bound">M</a><a id="9806" class="Symbol">}</a> <a id="9808" class="Symbol">{</a><a id="9809" href="/20.07/BigStep/#9809" class="Bound">V</a><a id="9810" class="Symbol">}</a> <a id="9812" class="Symbol">(</a><a id="9813" href="/20.07/BigStep/#3300" class="InductiveConstructor">⇓-app</a> <a id="9819" class="Symbol">{</a><a id="9820" class="Argument">N</a> <a id="9822" class="Symbol">=</a> <a id="9824" href="/20.07/BigStep/#9824" class="Bound">N</a><a id="9825" class="Symbol">}</a> <a id="9827" href="/20.07/BigStep/#9827" class="Bound">L⇓ƛNδ</a> <a id="9833" href="/20.07/BigStep/#9833" class="Bound">N⇓V</a><a id="9836" class="Symbol">)</a> <a id="9838" href="/20.07/BigStep/#9838" class="Bound">γ≈ₑσ</a>
    <a id="9847" class="Keyword">with</a> <a id="9852" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a><a id="9858" class="Symbol">{</a><a id="9859" class="Argument">σ</a> <a id="9861" class="Symbol">=</a> <a id="9863" href="/20.07/BigStep/#9797" class="Bound">σ</a><a id="9864" class="Symbol">}</a> <a id="9866" href="/20.07/BigStep/#9827" class="Bound">L⇓ƛNδ</a> <a id="9872" href="/20.07/BigStep/#9838" class="Bound">γ≈ₑσ</a>
<a id="9877" class="Symbol">...</a> <a id="9881" class="Symbol">|</a> <a id="9883" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9885" class="Symbol">_</a> <a id="9887" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9889" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9891" href="/20.07/BigStep/#9891" class="Bound">σL—↠ƛτN</a> <a id="9899" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9901" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9903" href="/20.07/BigStep/#9903" class="Bound">τ</a> <a id="9905" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9907" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="9909" href="/20.07/BigStep/#9909" class="Bound">δ≈ₑτ</a> <a id="9914" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="9916" href="/20.07/BigStep/#9916" class="Bound">≡ƛτN</a> <a id="9921" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9923" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9925" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9927" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="9929" class="Keyword">rewrite</a> <a id="9937" href="/20.07/BigStep/#9916" class="Bound">≡ƛτN</a>
      <a id="9949" class="Keyword">with</a> <a id="9954" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a> <a id="9961" class="Symbol">{</a><a id="9962" class="Argument">σ</a> <a id="9964" class="Symbol">=</a> <a id="9966" href="/20.07/BigStep/#7094" class="Function">ext-subst</a> <a id="9976" href="/20.07/BigStep/#9903" class="Bound">τ</a> <a id="9978" class="Symbol">(</a><a id="9979" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="9985" class="Bound">σ</a> <a id="9987" class="Bound">M</a><a id="9988" class="Symbol">)}</a> <a id="9991" class="Bound">N⇓V</a>
             <a id="10008" class="Symbol">(λ</a> <a id="10011" class="Symbol">{</a><a id="10012" href="/20.07/BigStep/#10012" class="Bound">x</a><a id="10013" class="Symbol">}</a> <a id="10015" class="Symbol">→</a> <a id="10017" href="/20.07/BigStep/#8117" class="Function">≈ₑ-ext</a><a id="10023" class="Symbol">{</a><a id="10024" class="Argument">σ</a> <a id="10026" class="Symbol">=</a> <a id="10028" href="/20.07/BigStep/#9903" class="Bound">τ</a><a id="10029" class="Symbol">}</a> <a id="10031" href="/20.07/BigStep/#9909" class="Bound">δ≈ₑτ</a> <a id="10036" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10038" class="Bound">σ</a> <a id="10040" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10042" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10044" class="Bound">γ≈ₑσ</a> <a id="10049" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10051" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a> <a id="10056" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10058" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10060" class="Symbol">{</a><a id="10061" href="/20.07/BigStep/#10012" class="Bound">x</a><a id="10062" class="Symbol">})</a>
           <a id="10076" class="Symbol">|</a> <a id="10078" href="/20.07/Untyped/#10178" class="InductiveConstructor">β</a><a id="10079" class="Symbol">{</a><a id="10080" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a><a id="10081" class="Symbol">}{</a><a id="10083" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10089" class="Symbol">(</a><a id="10090" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="10095" href="/20.07/BigStep/#9903" class="Bound">τ</a><a id="10096" class="Symbol">)</a> <a id="10098" class="Bound">N</a><a id="10099" class="Symbol">}{</a><a id="10101" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10107" class="Bound">σ</a> <a id="10109" class="Bound">M</a><a id="10110" class="Symbol">}</a>
<a id="10112" class="Symbol">...</a>   <a id="10118" class="Symbol">|</a> <a id="10120" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10122" href="/20.07/BigStep/#10122" class="Bound">N&#39;</a> <a id="10125" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10127" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10129" href="/20.07/BigStep/#10129" class="Bound">—↠N&#39;</a> <a id="10134" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10136" href="/20.07/BigStep/#10136" class="Bound">V≈N&#39;</a> <a id="10141" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10143" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10145" class="Symbol">|</a> <a id="10147" href="/20.07/BigStep/#10147" class="Bound">ƛτN·σM—→</a>
        <a id="10164" class="Keyword">rewrite</a> <a id="10172" href="/20.07/BigStep/#8840" class="Function">sub-sub</a><a id="10179" class="Symbol">{</a><a id="10180" class="Argument">M</a> <a id="10182" class="Symbol">=</a> <a id="10184" class="Bound">N</a><a id="10185" class="Symbol">}{</a><a id="10187" class="Argument">σ₁</a> <a id="10190" class="Symbol">=</a> <a id="10192" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="10197" class="Bound">τ</a><a id="10198" class="Symbol">}{</a><a id="10200" class="Argument">σ₂</a> <a id="10203" class="Symbol">=</a> <a id="10205" href="/20.07/Untyped/#7375" class="Function">subst-zero</a> <a id="10216" class="Symbol">(</a><a id="10217" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10223" class="Bound">σ</a> <a id="10225" class="Bound">M</a><a id="10226" class="Symbol">)}</a> <a id="10229" class="Symbol">=</a>
        <a id="10239" class="Keyword">let</a> <a id="10243" href="/20.07/BigStep/#10243" class="Bound">rs</a> <a id="10246" class="Symbol">=</a> <a id="10248" class="Symbol">(</a><a id="10249" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="10251" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10257" class="Symbol">(</a><a id="10258" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="10263" class="Bound">τ</a><a id="10264" class="Symbol">)</a> <a id="10266" class="Bound">N</a><a id="10267" class="Symbol">)</a> <a id="10269" href="/20.07/Untyped/#4442" class="InductiveConstructor Operator">·</a> <a id="10271" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="10277" class="Bound">σ</a> <a id="10279" class="Bound">M</a> <a id="10281" href="/20.07/Untyped/#11174" class="InductiveConstructor Operator">—→⟨</a> <a id="10285" href="/20.07/BigStep/#10147" class="Bound">ƛτN·σM—→</a> <a id="10294" href="/20.07/Untyped/#11174" class="InductiveConstructor Operator">⟩</a> <a id="10296" href="/20.07/BigStep/#10129" class="Bound">—↠N&#39;</a> <a id="10301" class="Keyword">in</a>
        <a id="10312" class="Keyword">let</a> <a id="10316" href="/20.07/BigStep/#10316" class="Bound">g</a> <a id="10318" class="Symbol">=</a> <a id="10320" href="/20.07/Untyped/#21721" class="Function">—↠-trans</a> <a id="10329" class="Symbol">(</a><a id="10330" href="/20.07/Untyped/#22905" class="Function">appL-cong</a> <a id="10340" class="Bound">σL—↠ƛτN</a><a id="10347" class="Symbol">)</a> <a id="10349" href="/20.07/BigStep/#10243" class="Bound">rs</a> <a id="10352" class="Keyword">in</a>
        <a id="10363" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10365" href="/20.07/BigStep/#10122" class="Bound">N&#39;</a> <a id="10368" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10370" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="10372" href="/20.07/BigStep/#10316" class="Bound">g</a> <a id="10374" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="10376" href="/20.07/BigStep/#10136" class="Bound">V≈N&#39;</a> <a id="10381" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="10383" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
</pre>
<p>The proof is by induction on <code class="language-plaintext highlighter-rouge">γ ⊢ M ⇓ V</code>. We have three cases
to consider.</p>

<ul>
  <li>
    <p>Case <code class="language-plaintext highlighter-rouge">⇓-var</code>.
So we have <code class="language-plaintext highlighter-rouge">γ x ≡ clos L δ</code> and <code class="language-plaintext highlighter-rouge">δ ⊢ L ⇓ V</code>.
We need to show that <code class="language-plaintext highlighter-rouge">subst σ x —↠ N</code> and <code class="language-plaintext highlighter-rouge">V ≈ N</code> for some <code class="language-plaintext highlighter-rouge">N</code>.
The premise <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code> tells us that <code class="language-plaintext highlighter-rouge">γ x ≈ σ x</code>, so <code class="language-plaintext highlighter-rouge">clos L δ ≈ σ x</code>.
By the definition of <code class="language-plaintext highlighter-rouge">≈</code>, there exists a <code class="language-plaintext highlighter-rouge">τ</code> such that
<code class="language-plaintext highlighter-rouge">δ ≈ₑ τ</code> and <code class="language-plaintext highlighter-rouge">σ x ≡ subst τ L </code>.
Using <code class="language-plaintext highlighter-rouge">δ ⊢ L ⇓ V</code> and <code class="language-plaintext highlighter-rouge">δ ≈ₑ τ</code>,
the induction hypothesis gives us
<code class="language-plaintext highlighter-rouge">subst τ L —↠ N</code> and <code class="language-plaintext highlighter-rouge">V ≈ N</code> for some <code class="language-plaintext highlighter-rouge">N</code>.
So we have shown that <code class="language-plaintext highlighter-rouge">subst σ x —↠ N</code> and <code class="language-plaintext highlighter-rouge">V ≈ N</code> for some <code class="language-plaintext highlighter-rouge">N</code>.</p>
  </li>
  <li>
    <p>Case <code class="language-plaintext highlighter-rouge">⇓-lam</code>.
We immediately have <code class="language-plaintext highlighter-rouge">subst σ (ƛ N) —↠ subst σ (ƛ N)</code>
and <code class="language-plaintext highlighter-rouge">clos (subst σ (ƛ N)) γ ≈ subst σ (ƛ N)</code>.</p>
  </li>
  <li>
    <p>Case <code class="language-plaintext highlighter-rouge">⇓-app</code>.
Using <code class="language-plaintext highlighter-rouge">γ ⊢ L ⇓ clos N δ</code> and <code class="language-plaintext highlighter-rouge">γ ≈ₑ σ</code>,
the induction hypothesis gives us</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L —↠ ƛ subst (exts τ) N                                     (1)
</code></pre></div>    </div>

    <p>and <code class="language-plaintext highlighter-rouge">δ ≈ₑ τ</code> for some <code class="language-plaintext highlighter-rouge">τ</code>.
From <code class="language-plaintext highlighter-rouge">γ≈ₑσ</code> we have <code class="language-plaintext highlighter-rouge">clos M γ ≈ subst σ M</code>.
Then with <code class="language-plaintext highlighter-rouge">(δ ,' clos M γ) ⊢ N ⇓ V</code>,
the induction hypothesis gives us <code class="language-plaintext highlighter-rouge">V ≈ N'</code> and</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst (subst (subst-zero (subst σ M)) ∘ (exts τ)) N —↠ N'         (2)
</code></pre></div>    </div>

    <p>Meanwhile, by <code class="language-plaintext highlighter-rouge">β</code>, we have</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst-zero (subst σ M)) (subst (exts τ) N)
</code></pre></div>    </div>

    <p>which is the same as the following, by <code class="language-plaintext highlighter-rouge">sub-sub</code>.</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M
  —→ subst (subst (subst-zero (subst σ M)) ∘ exts τ) N              (3)
</code></pre></div>    </div>

    <p>Using (3) and (2) we have</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (ƛ subst (exts τ) N) · subst σ M —↠ N'                             (4)
</code></pre></div>    </div>

    <p>From (1) we have</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L · subst σ M —↠ (ƛ subst (exts τ) N) · subst σ M
</code></pre></div>    </div>

    <p>which we combine with (4) to conclude that</p>

    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  subst σ L · subst σ M —↠ N'
</code></pre></div>    </div>
  </li>
</ul>

<p>With the main lemma complete, we establish the forward direction
of the equivalence between the big-step semantics and beta reduction.</p>

<pre class="Agda"><a id="cbn→reduce"></a><a id="12205" href="/20.07/BigStep/#12205" class="Function">cbn→reduce</a> <a id="12216" class="Symbol">:</a>  <a id="12219" class="Symbol">∀{</a><a id="12221" href="/20.07/BigStep/#12221" class="Bound">M</a> <a id="12223" class="Symbol">:</a> <a id="12225" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="12227" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="12229" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="12230" class="Symbol">}{</a><a id="12232" href="/20.07/BigStep/#12232" class="Bound">Δ</a><a id="12233" class="Symbol">}{</a><a id="12235" href="/20.07/BigStep/#12235" class="Bound">δ</a> <a id="12237" class="Symbol">:</a> <a id="12239" href="/20.07/BigStep/#2437" class="Function">ClosEnv</a> <a id="12247" href="/20.07/BigStep/#12232" class="Bound">Δ</a><a id="12248" class="Symbol">}{</a><a id="12250" href="/20.07/BigStep/#12250" class="Bound">N′</a> <a id="12253" class="Symbol">:</a> <a id="12255" href="/20.07/BigStep/#12232" class="Bound">Δ</a> <a id="12257" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="12259" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="12261" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="12263" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a><a id="12264" class="Symbol">}</a>
  <a id="12268" class="Symbol">→</a> <a id="12270" href="/20.07/BigStep/#2650" class="Function">∅&#39;</a> <a id="12273" href="/20.07/BigStep/#3021" class="Datatype Operator">⊢</a> <a id="12275" href="/20.07/BigStep/#12221" class="Bound">M</a> <a id="12277" href="/20.07/BigStep/#3021" class="Datatype Operator">⇓</a> <a id="12279" href="/20.07/BigStep/#2486" class="InductiveConstructor">clos</a> <a id="12284" class="Symbol">(</a><a id="12285" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="12287" href="/20.07/BigStep/#12250" class="Bound">N′</a><a id="12289" class="Symbol">)</a> <a id="12291" href="/20.07/BigStep/#12235" class="Bound">δ</a>
    <a id="12297" class="Comment">-----------------------------</a>
  <a id="12329" class="Symbol">→</a> <a id="12331" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">Σ[</a> <a id="12334" href="/20.07/BigStep/#12334" class="Bound">N</a> <a id="12336" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">∈</a> <a id="12338" href="/20.07/Untyped/#3175" class="InductiveConstructor">∅</a> <a id="12340" href="/20.07/Untyped/#3191" class="InductiveConstructor Operator">,</a> <a id="12342" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="12344" href="/20.07/Untyped/#4294" class="Datatype Operator">⊢</a> <a id="12346" href="/20.07/Untyped/#2888" class="InductiveConstructor">★</a> <a id="12348" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#911" class="Function">]</a> <a id="12350" class="Symbol">(</a><a id="12351" href="/20.07/BigStep/#12221" class="Bound">M</a> <a id="12353" href="/20.07/Untyped/#11068" class="Datatype Operator">—↠</a> <a id="12356" href="/20.07/Untyped/#4382" class="InductiveConstructor Operator">ƛ</a> <a id="12358" href="/20.07/BigStep/#12334" class="Bound">N</a><a id="12359" class="Symbol">)</a>
<a id="12361" href="/20.07/BigStep/#12205" class="Function">cbn→reduce</a> <a id="12372" class="Symbol">{</a><a id="12373" href="/20.07/BigStep/#12373" class="Bound">M</a><a id="12374" class="Symbol">}{</a><a id="12376" href="/20.07/BigStep/#12376" class="Bound">Δ</a><a id="12377" class="Symbol">}{</a><a id="12379" href="/20.07/BigStep/#12379" class="Bound">δ</a><a id="12380" class="Symbol">}{</a><a id="12382" href="/20.07/BigStep/#12382" class="Bound">N′</a><a id="12384" class="Symbol">}</a> <a id="12386" href="/20.07/BigStep/#12386" class="Bound">M⇓c</a>
    <a id="12394" class="Keyword">with</a> <a id="12399" href="/20.07/BigStep/#9223" class="Function">⇓→—↠×≈</a><a id="12405" class="Symbol">{</a><a id="12406" class="Argument">σ</a> <a id="12408" class="Symbol">=</a> <a id="12410" href="/20.07/Substitution/#3046" class="Function">ids</a><a id="12413" class="Symbol">}</a> <a id="12415" href="/20.07/BigStep/#12386" class="Bound">M⇓c</a> <a id="12419" href="/20.07/BigStep/#6814" class="Function">≈ₑ-id</a>
<a id="12425" class="Symbol">...</a> <a id="12429" class="Symbol">|</a> <a id="12431" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12433" href="/20.07/BigStep/#12433" class="Bound">N</a> <a id="12435" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12437" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12439" href="/20.07/BigStep/#12439" class="Bound">rs</a> <a id="12442" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12444" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12446" href="/20.07/BigStep/#12446" class="Bound">σ</a> <a id="12448" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12450" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12452" href="/20.07/BigStep/#12452" class="Bound">h</a> <a id="12454" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12456" href="/20.07/BigStep/#12456" class="Bound">eq2</a> <a id="12460" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12462" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12464" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12466" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a> <a id="12468" class="Keyword">rewrite</a> <a id="12476" href="/20.07/BigStep/#6932" class="Function">sub-id</a><a id="12482" class="Symbol">{</a><a id="12483" class="Argument">M</a> <a id="12485" class="Symbol">=</a> <a id="12487" class="Bound">M</a><a id="12488" class="Symbol">}</a> <a id="12490" class="Symbol">|</a> <a id="12492" href="/20.07/BigStep/#12456" class="Bound">eq2</a> <a id="12496" class="Symbol">=</a>
      <a id="12504" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟨</a> <a id="12506" href="/20.07/Untyped/#6963" class="Function">subst</a> <a id="12512" class="Symbol">(</a><a id="12513" href="/20.07/Untyped/#6671" class="Function">exts</a> <a id="12518" href="/20.07/BigStep/#12446" class="Bound">σ</a><a id="12519" class="Symbol">)</a> <a id="12521" class="Bound">N′</a> <a id="12524" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">,</a> <a id="12526" href="/20.07/BigStep/#12439" class="Bound">rs</a> <a id="12529" href="Agda.Builtin.Sigma.html#209" class="InductiveConstructor Operator">⟩</a>
</pre>
<h4 id="exercise-big-alt-implies-multi-practice">Exercise <code class="language-plaintext highlighter-rouge">big-alt-implies-multi</code> (practice)</h4>

<p>Formulate an alternative big-step semantics, of the form <code class="language-plaintext highlighter-rouge">M ↓ N</code>, for
call-by-name that uses substitution instead of environments.  That is,
the analogue of the application rule <code class="language-plaintext highlighter-rouge">⇓-app</code> should perform
substitution, as in <code class="language-plaintext highlighter-rouge">N [ M ]</code>, instead of extending the environment
with <code class="language-plaintext highlighter-rouge">M</code>. Prove that <code class="language-plaintext highlighter-rouge">M ↓ N</code> implies <code class="language-plaintext highlighter-rouge">M —↠ N</code>.</p>

<pre class="Agda"><a id="12907" class="Comment">-- Your code goes here</a>
</pre>
<h2 id="beta-reduction-to-a-lambda-implies-big-step-evaluation">Beta reduction to a lambda implies big-step evaluation</h2>

<p>The proof of the backward direction, that beta reduction to a lambda
implies that the call-by-name semantics produces a result, is more
difficult to prove. The difficulty stems from reduction proceeding
underneath lambda abstractions via the <code class="language-plaintext highlighter-rouge">ζ</code> rule. The call-by-name
semantics does not reduce under lambda, so a straightforward proof by
induction on the reduction sequence is impossible.  In the article
<em>Call-by-name, call-by-value, and the λ-calculus</em>, Plotkin proves the
theorem in two steps, using two auxilliary reduction relations. The
first step uses a classic technique called Curry-Feys standardisation.
It relies on the notion of <em>standard reduction sequence</em>, which acts
as a half-way point between full beta reduction and call-by-name by
expanding call-by-name to also include reduction underneath
lambda. Plotkin proves that <code class="language-plaintext highlighter-rouge">M</code> reduces to <code class="language-plaintext highlighter-rouge">L</code> if and only if <code class="language-plaintext highlighter-rouge">M</code> is
related to <code class="language-plaintext highlighter-rouge">L</code> by a standard reduction sequence.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Theorem 1 (Standardisation)
`M —↠ L` if and only if `M` goes to `L` via a standard reduction sequence.
</code></pre></div></div>

<p>Plotkin then introduces <em>left reduction</em>, a small-step version of
call-by-name and uses the above theorem to prove that beta reduction
and left reduction are equivalent in the following sense.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Corollary 1
`M —↠ ƛ N` if and only if `M` goes to `ƛ N′`, for some `N′`, by left reduction.
</code></pre></div></div>

<p>The second step of the proof connects left reduction to call-by-name
evaluation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Theorem 2
`M` left reduces to `ƛ N` if and only if `⊢ M ⇓ ƛ N`.
</code></pre></div></div>

<p>(Plotkin’s call-by-name evaluator uses substitution instead of
environments, which explains why the environment is omitted in <code class="language-plaintext highlighter-rouge">⊢ M ⇓
ƛ N</code> in the above theorem statement.)</p>

<p>Putting Corollary 1 and Theorem 2 together, Plotkin proves that
call-by-name evaluation is equivalent to beta reduction.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Corollary 2
`M —↠ ƛ N` if and only if `⊢ M ⇓ ƛ N′` for some `N′`.
</code></pre></div></div>

<p>Plotkin also proves an analogous result for the λᵥ calculus, relating
it to call-by-value evaluation. For a nice exposition of that proof,
we recommend Chapter 5 of <em>Semantics Engineering with PLT Redex</em> by
Felleisen, Findler, and Flatt.</p>

<p>Instead of proving the backwards direction via standardisation, as
sketched above, we defer the proof until after we define a
denotational semantics for the lambda calculus, at which point the
proof of the backwards direction will fall out as a corollary to the
soundness and adequacy of the denotational semantics.</p>

<h2 id="unicode">Unicode</h2>

<p>This chapter uses the following unicode:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>≈  U+2248  ALMOST EQUAL TO (\~~ or \approx)
ₑ  U+2091  LATIN SUBSCRIPT SMALL LETTER E (\_e)
⊢  U+22A2  RIGHT TACK (\|- or \vdash)
⇓  U+21DB  DOWNWARDS DOUBLE ARROW (\d= or \Downarrow)
</code></pre></div></div>

  </div>

  <p style="text-align:center;">

    <a alt="Previous chapter" href="/20.07/Confluence/">Prev</a>


    &bullet;


    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev-20.07/src/plfa/part2/BigStep.lagda.md">Source</a>


    &bullet;


    <a alt="Next chapter" href="/20.07/Denotational/">Next</a>

</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/20.07/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programming Language Foundations in Agda
</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Jeremy G. Siek</li>
          <li><a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jsiek"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jsiek</span></a></li><li><a href="https://www.twitter.com/jeremysiek"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jeremysiek</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/20.07/assets/jquery.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha256-E4RlfxwyJVmkkk0szw7LYJxuPlp6evtPSBDlWHsYYL8=" crossorigin="anonymous"></script>
<script type="text/javascript">
  anchors.add();
</script>

<script type="text/javascript">

 // Makes sandwhich menu works
 $('.menu-icon').click(function(){
   $('.trigger').toggle();
 });

 // Script which allows for foldable code blocks
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/20.07/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
