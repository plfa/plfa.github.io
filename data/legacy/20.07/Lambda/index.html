<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Lambda: Introduction to Lambda Calculus | Programming Language Foundations in Agda</title><meta name="generator" content="Jekyll v3.9.0"><meta property="og:title" content="Lambda: Introduction to Lambda Calculus"><meta property="og:locale" content="en_US"><meta name="description" content="Programming Language Foundations in Agda"><meta property="og:description" content="Programming Language Foundations in Agda"><link rel="canonical" href="https://plfa.github.io/20.07/Lambda/"><meta property="og:url" content="https://plfa.github.io/20.07/Lambda/"><meta property="og:site_name" content="Programming Language Foundations in Agda"><script type="application/ld+json">{"url":"https://plfa.github.io/20.07/Lambda/","headline":"Lambda: Introduction to Lambda Calculus","description":"Programming Language Foundations in Agda","@type":"WebPage","@context":"https://schema.org"}</script><link rel="stylesheet" href="/20.07/assets/main.css"></head><body><header class="site-header" role="banner"><div class="wrapper"><a class="site-title" href="/20.07/">Programming Language Foundations in Agda</a><nav class="site-nav"><span class="menu-icon"><svg viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/></svg></span><div class="trigger"><a class="page-link" href="/20.07/">The Book</a> <a class="page-link" href="/20.07/Announcements/">Announcements</a> <a class="page-link" href="/20.07/GettingStarted/">Getting Started</a> <a class="page-link" href="/20.07/Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">ä¸­æ–‡</a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><header class="post-header"><h1 class="post-title">Lambda: Introduction to Lambda Calculus</h1></header><p style="text-align:center"><a alt="Previous chapter" href="/20.07/Lists/">Prev</a> &bullet; <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev-20.07/src/plfa/part2/Lambda.lagda.md">Source</a> &bullet; <a alt="Next chapter" href="/20.07/Properties/">Next</a></p><div class="post-content"><pre class="Agda"><a id="151" class="Keyword">module</a> <a id="158" href="/20.07/Lambda/" class="Module">plfa.part2.Lambda</a> <a id="176" class="Keyword">where</a>
</pre><p>The <em>lambda-calculus</em>, first published by the logician Alonzo Church in 1932, is a core calculus with only three syntactic constructs: variables, abstraction, and application. It captures the key concept of <em>functional abstraction</em>, which appears in pretty much every programming language, in the form of either functions, procedures, or methods. The <em>simply-typed lambda calculus</em> (or STLC) is a variant of the lambda calculus published by Church in 1940. It has the three constructs above for function types, plus whatever else is required for base types. Church had a minimal base type with no operations. We will instead echo Plotkinâ€™s <em>Programmable Computable Functions</em> (PCF), and add operations on natural numbers and recursive function definitions.</p><p>This chapter formalises the simply-typed lambda calculus, giving its syntax, small-step semantics, and typing rules. The next chapter <a href="/20.07/Properties/">Properties</a> proves its main properties, including progress and preservation. Following chapters will look at a number of variants of lambda calculus.</p><p>Be aware that the approach we take here is <em>not</em> our recommended approach to formalisation. Using de Bruijn indices and intrinsically-typed terms, as we will do in Chapter <a href="/20.07/DeBruijn/">DeBruijn</a>, leads to a more compact formulation. Nonetheless, we begin with named variables and extrinsically-typed terms, partly because names are easier than indices to read, and partly because the development is more traditional.</p><p>The development in this chapter was inspired by the corresponding development in Chapter <em>Stlc</em> of <em>Software Foundations</em> (<em>Programming Language Foundations</em>). We differ by representing contexts explicitly (as lists pairing identifiers with types) rather than as partial maps (which take identifiers to types), which corresponds better to our subsequent development of DeBruijn notation. We also differ by taking natural numbers as the base type rather than booleans, allowing more sophisticated examples. In particular, we will be able to show (twice!) that two plus two is four.</p><h2 id="imports">Imports</h2><pre class="Agda"><a id="2304" class="Keyword">open</a> <a id="2309" class="Keyword">import</a> <a id="2316" href="https://agda.github.io/agda-stdlib/v1.1/Data.Bool.html" class="Module">Data.Bool</a> <a id="2326" class="Keyword">using</a> <a id="2332" class="Symbol">(</a><a id="2333" href="https://agda.github.io/agda-stdlib/v1.1/Data.Bool.Base.html#1480" class="Function">T</a><a id="2334" class="Symbol">;</a> <a id="2336" href="https://agda.github.io/agda-stdlib/v1.1/Data.Bool.Base.html#961" class="Function">not</a><a id="2339" class="Symbol">)</a>
<a id="2341" class="Keyword">open</a> <a id="2346" class="Keyword">import</a> <a id="2353" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html" class="Module">Data.Empty</a> <a id="2364" class="Keyword">using</a> <a id="2370" class="Symbol">(</a><a id="2371" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#279" class="Datatype">âŠ¥</a><a id="2372" class="Symbol">;</a> <a id="2374" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#294" class="Function">âŠ¥-elim</a><a id="2380" class="Symbol">)</a>
<a id="2382" class="Keyword">open</a> <a id="2387" class="Keyword">import</a> <a id="2394" href="https://agda.github.io/agda-stdlib/v1.1/Data.List.html" class="Module">Data.List</a> <a id="2404" class="Keyword">using</a> <a id="2410" class="Symbol">(</a><a id="2411" href="Agda.Builtin.List.html#121" class="Datatype">List</a><a id="2415" class="Symbol">;</a> <a id="2417" href="Agda.Builtin.List.html#173" class="InductiveConstructor Operator">_âˆ·_</a><a id="2420" class="Symbol">;</a> <a id="2422" href="https://agda.github.io/agda-stdlib/v1.1/Data.List.Base.html#8786" class="InductiveConstructor">[]</a><a id="2424" class="Symbol">)</a>
<a id="2426" class="Keyword">open</a> <a id="2431" class="Keyword">import</a> <a id="2438" href="https://agda.github.io/agda-stdlib/v1.1/Data.Nat.html" class="Module">Data.Nat</a> <a id="2447" class="Keyword">using</a> <a id="2453" class="Symbol">(</a><a id="2454" href="Agda.Builtin.Nat.html#165" class="Datatype">â„•</a><a id="2455" class="Symbol">;</a> <a id="2457" href="Agda.Builtin.Nat.html#183" class="InductiveConstructor">zero</a><a id="2461" class="Symbol">;</a> <a id="2463" href="Agda.Builtin.Nat.html#196" class="InductiveConstructor">suc</a><a id="2466" class="Symbol">)</a>
<a id="2468" class="Keyword">open</a> <a id="2473" class="Keyword">import</a> <a id="2480" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html" class="Module">Data.Product</a> <a id="2493" class="Keyword">using</a> <a id="2499" class="Symbol">(</a><a id="2500" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">âˆƒ-syntax</a><a id="2508" class="Symbol">;</a> <a id="2510" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">_Ã—_</a><a id="2513" class="Symbol">)</a>
<a id="2515" class="Keyword">open</a> <a id="2520" class="Keyword">import</a> <a id="2527" href="https://agda.github.io/agda-stdlib/v1.1/Data.String.html" class="Module">Data.String</a> <a id="2539" class="Keyword">using</a> <a id="2545" class="Symbol">(</a><a id="2546" href="Agda.Builtin.String.html#206" class="Postulate">String</a><a id="2552" class="Symbol">;</a> <a id="2554" href="https://agda.github.io/agda-stdlib/v1.1/Data.String.Properties.html#2569" class="Function Operator">_â‰Ÿ_</a><a id="2557" class="Symbol">)</a>
<a id="2559" class="Keyword">open</a> <a id="2564" class="Keyword">import</a> <a id="2571" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="2588" class="Keyword">using</a> <a id="2594" class="Symbol">(</a><a id="2595" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#605" class="Datatype">Dec</a><a id="2598" class="Symbol">;</a> <a id="2600" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#641" class="InductiveConstructor">yes</a><a id="2603" class="Symbol">;</a> <a id="2605" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#668" class="InductiveConstructor">no</a><a id="2607" class="Symbol">;</a> <a id="2609" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#535" class="Function Operator">Â¬_</a><a id="2611" class="Symbol">)</a>
<a id="2613" class="Keyword">open</a> <a id="2618" class="Keyword">import</a> <a id="2625" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.Decidable.html" class="Module">Relation.Nullary.Decidable</a> <a id="2652" class="Keyword">using</a> <a id="2658" class="Symbol">(</a><a id="2659" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.Decidable.Core.html#753" class="Function Operator">âŒŠ_âŒ‹</a><a id="2662" class="Symbol">;</a> <a id="2664" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.Decidable.Core.html#845" class="Function">False</a><a id="2669" class="Symbol">;</a> <a id="2671" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.Decidable.Core.html#1189" class="Function">toWitnessFalse</a><a id="2685" class="Symbol">)</a>
<a id="2687" class="Keyword">open</a> <a id="2692" class="Keyword">import</a> <a id="2699" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="2725" class="Keyword">using</a> <a id="2731" class="Symbol">(</a><a id="2732" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.Negation.html#1115" class="Function">Â¬?</a><a id="2734" class="Symbol">)</a>
<a id="2736" class="Keyword">open</a> <a id="2741" class="Keyword">import</a> <a id="2748" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="2786" class="Keyword">using</a> <a id="2792" class="Symbol">(</a><a id="2793" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_â‰¡_</a><a id="2796" class="Symbol">;</a> <a id="2798" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#799" class="Function Operator">_â‰¢_</a><a id="2801" class="Symbol">;</a> <a id="2803" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="2807" class="Symbol">)</a>
</pre><h2 id="syntax-of-terms">Syntax of terms</h2><p>Terms have seven constructs. Three are for the core lambda calculus:</p><ul><li>Variables <code class="language-plaintext highlighter-rouge">` x</code></li><li>Abstractions <code class="language-plaintext highlighter-rouge">Æ› x â‡’ N</code></li><li>Applications <code class="language-plaintext highlighter-rouge">L Â· M</code></li></ul><p>Three are for the naturals:</p><ul><li>Zero <code class="language-plaintext highlighter-rouge">`zero</code></li><li>Successor <code class="language-plaintext highlighter-rouge">`suc M</code></li><li>Case <code class="language-plaintext highlighter-rouge">case L [zeroâ‡’ M |suc x â‡’ N ]</code></li></ul><p>And one is for recursion:</p><ul><li>Fixpoint <code class="language-plaintext highlighter-rouge">Î¼ x â‡’ M</code></li></ul><p>Abstraction is also called <em>lambda abstraction</em>, and is the construct from which the calculus takes its name.</p><p>With the exception of variables and fixpoints, each term form either constructs a value of a given type (abstractions yield functions, zero and successor yield natural numbers) or deconstructs it (applications use functions, case terms use naturals). We will see this again when we come to the rules for assigning types to terms, where constructors correspond to introduction rules and deconstructors to eliminators.</p><p>Here is the syntax of terms in Backus-Naur Form (BNF):</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L, M, N  ::=
  ` x  |  Æ› x â‡’ N  |  L Â· M  |
  `zero  |  `suc M  |  case L [zeroâ‡’ M |suc x â‡’ N ]  |
  Î¼ x â‡’ M
</code></pre></div></div><p>And here it is formalised in Agda:</p><pre class="Agda"><a id="Id"></a><a id="3904" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="3907" class="Symbol">:</a> <a id="3909" class="PrimitiveType">Set</a>
<a id="3913" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="3916" class="Symbol">=</a> <a id="3918" href="Agda.Builtin.String.html#206" class="Postulate">String</a>

<a id="3926" class="Keyword">infix</a>  <a id="3933" class="Number">5</a>  <a id="3936" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›_â‡’_</a>
<a id="3941" class="Keyword">infix</a>  <a id="3948" class="Number">5</a>  <a id="3951" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼_â‡’_</a>
<a id="3956" class="Keyword">infixl</a> <a id="3963" class="Number">7</a>  <a id="3966" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">_Â·_</a>
<a id="3970" class="Keyword">infix</a>  <a id="3977" class="Number">8</a>  <a id="3980" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc_</a>
<a id="3986" class="Keyword">infix</a>  <a id="3993" class="Number">9</a>  <a id="3996" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`_</a>

<a id="4000" class="Keyword">data</a> <a id="Term"></a><a id="4005" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4010" class="Symbol">:</a> <a id="4012" class="PrimitiveType">Set</a> <a id="4016" class="Keyword">where</a>
  <a id="Term.`_"></a><a id="4024" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`_</a>                      <a id="4048" class="Symbol">:</a>  <a id="4051" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="4054" class="Symbol">â†’</a> <a id="4056" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
  <a id="Term.Æ›_â‡’_"></a><a id="4063" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›_â‡’_</a>                    <a id="4087" class="Symbol">:</a>  <a id="4090" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="4093" class="Symbol">â†’</a> <a id="4095" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4100" class="Symbol">â†’</a> <a id="4102" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
  <a id="Term._Â·_"></a><a id="4109" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">_Â·_</a>                     <a id="4133" class="Symbol">:</a>  <a id="4136" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4141" class="Symbol">â†’</a> <a id="4143" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4148" class="Symbol">â†’</a> <a id="4150" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
  <a id="Term.`zero"></a><a id="4157" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>                   <a id="4181" class="Symbol">:</a>  <a id="4184" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
  <a id="Term.`suc_"></a><a id="4191" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc_</a>                   <a id="4215" class="Symbol">:</a>  <a id="4218" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4223" class="Symbol">â†’</a> <a id="4225" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
  <a id="Term.case_[zeroâ‡’_|suc_â‡’_]"></a><a id="4232" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case_[zeroâ‡’_|suc_â‡’_]</a>    <a id="4256" class="Symbol">:</a>  <a id="4259" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4264" class="Symbol">â†’</a> <a id="4266" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4271" class="Symbol">â†’</a> <a id="4273" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="4276" class="Symbol">â†’</a> <a id="4278" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4283" class="Symbol">â†’</a> <a id="4285" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
  <a id="Term.Î¼_â‡’_"></a><a id="4292" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼_â‡’_</a>                    <a id="4316" class="Symbol">:</a>  <a id="4319" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="4322" class="Symbol">â†’</a> <a id="4324" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="4329" class="Symbol">â†’</a> <a id="4331" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
</pre><p>We represent identifiers by strings. We choose precedence so that lambda abstraction and fixpoint bind least tightly, then application, then successor, and tightest of all is the constructor for variables. Case expressions are self-bracketing.</p><h3 id="example-terms">Example terms</h3><p>Here are some example terms: the natural number two, a function that adds naturals, and a term that computes two plus two:</p><pre class="Agda"><a id="two"></a><a id="4733" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="4737" class="Symbol">:</a> <a id="4739" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="4744" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="4748" class="Symbol">=</a> <a id="4750" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="4755" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="4760" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>

<a id="plus"></a><a id="4767" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="4772" class="Symbol">:</a> <a id="4774" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="4779" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="4784" class="Symbol">=</a> <a id="4786" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼</a> <a id="4788" class="String">&quot;+&quot;</a> <a id="4792" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">â‡’</a> <a id="4794" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="4796" class="String">&quot;m&quot;</a> <a id="4800" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="4802" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="4804" class="String">&quot;n&quot;</a> <a id="4808" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a>
         <a id="4819" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="4824" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="4826" class="String">&quot;m&quot;</a>
           <a id="4841" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="4848" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="4850" class="String">&quot;n&quot;</a>
           <a id="4865" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="4870" class="String">&quot;m&quot;</a> <a id="4874" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="4876" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="4881" class="Symbol">(</a><a id="4882" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="4884" class="String">&quot;+&quot;</a> <a id="4888" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="4890" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="4892" class="String">&quot;m&quot;</a> <a id="4896" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="4898" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="4900" class="String">&quot;n&quot;</a><a id="4903" class="Symbol">)</a> <a id="4905" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a>
</pre><p>The recursive definition of addition is similar to our original definition of <code class="language-plaintext highlighter-rouge">_+_</code> for naturals, as given in Chapter <a href="/20.07/Naturals/#plus">Naturals</a>. Here variable â€œmâ€ is bound twice, once in a lambda abstraction and once in the successor branch of the case; the first use of â€œmâ€ refers to the former and the second to the latter. Any use of â€œmâ€ in the successor branch must refer to the latter binding, and so we say that the latter binding <em>shadows</em> the former. Later we will confirm that two plus two is four, in other words that the term</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plus Â· two Â· two
</code></pre></div></div><p>reduces to <code class="language-plaintext highlighter-rouge">`suc `suc `suc `suc `zero</code>.</p><p>As a second example, we use higher-order functions to represent natural numbers. In particular, the number <em>n</em> is represented by a function that accepts two arguments and applies the first <em>n</em> times to the second. This is called the <em>Church representation</em> of the naturals. Here are some example terms: the Church numeral two, a function that adds Church numerals, a function to compute successor, and a term that computes two plus two:</p><pre class="Agda"><a id="twoá¶œ"></a><a id="5982" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="5987" class="Symbol">:</a> <a id="5989" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="5994" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="5999" class="Symbol">=</a>  <a id="6002" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="6004" class="String">&quot;s&quot;</a> <a id="6008" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="6010" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="6012" class="String">&quot;z&quot;</a> <a id="6016" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="6018" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6020" class="String">&quot;s&quot;</a> <a id="6024" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="6026" class="Symbol">(</a><a id="6027" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6029" class="String">&quot;s&quot;</a> <a id="6033" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="6035" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6037" class="String">&quot;z&quot;</a><a id="6040" class="Symbol">)</a>

<a id="plusá¶œ"></a><a id="6043" href="/20.07/Lambda/#6043" class="Function">plusá¶œ</a> <a id="6049" class="Symbol">:</a> <a id="6051" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="6056" href="/20.07/Lambda/#6043" class="Function">plusá¶œ</a> <a id="6062" class="Symbol">=</a>  <a id="6065" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="6067" class="String">&quot;m&quot;</a> <a id="6071" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="6073" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="6075" class="String">&quot;n&quot;</a> <a id="6079" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="6081" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="6083" class="String">&quot;s&quot;</a> <a id="6087" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="6089" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="6091" class="String">&quot;z&quot;</a> <a id="6095" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a>
         <a id="6106" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6108" class="String">&quot;m&quot;</a> <a id="6112" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="6114" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6116" class="String">&quot;s&quot;</a> <a id="6120" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="6122" class="Symbol">(</a><a id="6123" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6125" class="String">&quot;n&quot;</a> <a id="6129" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="6131" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6133" class="String">&quot;s&quot;</a> <a id="6137" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="6139" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6141" class="String">&quot;z&quot;</a><a id="6144" class="Symbol">)</a>

<a id="sucá¶œ"></a><a id="6147" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="6152" class="Symbol">:</a> <a id="6154" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="6159" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="6164" class="Symbol">=</a> <a id="6166" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="6168" class="String">&quot;n&quot;</a> <a id="6172" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="6174" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="6179" class="Symbol">(</a><a id="6180" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="6182" class="String">&quot;n&quot;</a><a id="6185" class="Symbol">)</a>
</pre><p>The Church numeral for two takes two arguments <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">z</code> and applies <code class="language-plaintext highlighter-rouge">s</code> twice to <code class="language-plaintext highlighter-rouge">z</code>. Addition takes two numerals <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code>, a function <code class="language-plaintext highlighter-rouge">s</code> and an argument <code class="language-plaintext highlighter-rouge">z</code>, and it uses <code class="language-plaintext highlighter-rouge">m</code> to apply <code class="language-plaintext highlighter-rouge">s</code> to the result of using <code class="language-plaintext highlighter-rouge">n</code> to apply <code class="language-plaintext highlighter-rouge">s</code> to <code class="language-plaintext highlighter-rouge">z</code>; hence <code class="language-plaintext highlighter-rouge">s</code> is applied <code class="language-plaintext highlighter-rouge">m</code> plus <code class="language-plaintext highlighter-rouge">n</code> times to <code class="language-plaintext highlighter-rouge">z</code>, yielding the Church numeral for the sum of <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code>. For convenience, we define a function that computes successor. To convert a Church numeral to the corresponding natural, we apply it to the <code class="language-plaintext highlighter-rouge">sucá¶œ</code> function and the natural number zero. Again, later we will confirm that two plus two is four, in other words that the term</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>plusá¶œ Â· twoá¶œ Â· twoá¶œ Â· sucá¶œ Â· `zero
</code></pre></div></div><p>reduces to <code class="language-plaintext highlighter-rouge">`suc `suc `suc `suc `zero</code>.</p><h4 id="exercise-mul-recommended">Exercise <code class="language-plaintext highlighter-rouge">mul</code> (recommended)</h4><p>Write out the definition of a lambda term that multiplies two natural numbers. Your definition may use <code class="language-plaintext highlighter-rouge">plus</code> as defined earlier.</p><pre class="Agda"><a id="7067" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-mulá¶œ-practice">Exercise <code class="language-plaintext highlighter-rouge">mulá¶œ</code> (practice)</h4><p>Write out the definition of a lambda term that multiplies two natural numbers represented as Church numerals. Your definition may use <code class="language-plaintext highlighter-rouge">plusá¶œ</code> as defined earlier (or may not â€” there are nice definitions both ways).</p><pre class="Agda"><a id="7348" class="Comment">-- Your code goes here</a>
</pre><h4 id="primed">Exercise <code class="language-plaintext highlighter-rouge">primed</code> (stretch)</h4><p>Some people find it annoying to write <code class="language-plaintext highlighter-rouge">` "x"</code> instead of <code class="language-plaintext highlighter-rouge">x</code>. We can make examples with lambda terms slightly easier to write by adding the following definitions:</p><pre class="Agda"><a id="Æ›â€²_â‡’_"></a><a id="7592" href="/20.07/Lambda/#7592" class="Function Operator">Æ›â€²_â‡’_</a> <a id="7598" class="Symbol">:</a> <a id="7600" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="7605" class="Symbol">â†’</a> <a id="7607" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="7612" class="Symbol">â†’</a> <a id="7614" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="7619" href="/20.07/Lambda/#7592" class="Function Operator">Æ›â€²</a> <a id="7622" class="Symbol">(</a><a id="7623" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="7625" href="/20.07/Lambda/#7625" class="Bound">x</a><a id="7626" class="Symbol">)</a> <a id="7628" href="/20.07/Lambda/#7592" class="Function Operator">â‡’</a> <a id="7630" href="/20.07/Lambda/#7630" class="Bound">N</a>  <a id="7633" class="Symbol">=</a>  <a id="7636" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="7638" href="/20.07/Lambda/#7625" class="Bound">x</a> <a id="7640" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="7642" href="/20.07/Lambda/#7630" class="Bound">N</a>
<a id="7644" href="/20.07/Lambda/#7592" class="CatchallClause Function Operator">Æ›â€²</a><a id="7646" class="CatchallClause"> </a><a id="7647" class="CatchallClause Symbol">_</a><a id="7648" class="CatchallClause"> </a><a id="7649" href="/20.07/Lambda/#7592" class="CatchallClause Function Operator">â‡’</a><a id="7650" class="CatchallClause"> </a><a id="7651" class="CatchallClause Symbol">_</a>      <a id="7658" class="Symbol">=</a>  <a id="7661" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#294" class="Function">âŠ¥-elim</a> <a id="7668" href="/20.07/Lambda/#7697" class="Postulate">impossible</a>
  <a id="7681" class="Keyword">where</a> <a id="7687" class="Keyword">postulate</a> <a id="7697" href="/20.07/Lambda/#7697" class="Postulate">impossible</a> <a id="7708" class="Symbol">:</a> <a id="7710" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#279" class="Datatype">âŠ¥</a>

<a id="caseâ€²_[zeroâ‡’_|suc_â‡’_]"></a><a id="7713" href="/20.07/Lambda/#7713" class="Function Operator">caseâ€²_[zeroâ‡’_|suc_â‡’_]</a> <a id="7735" class="Symbol">:</a> <a id="7737" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="7742" class="Symbol">â†’</a> <a id="7744" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="7749" class="Symbol">â†’</a> <a id="7751" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="7756" class="Symbol">â†’</a> <a id="7758" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="7763" class="Symbol">â†’</a> <a id="7765" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="7770" href="/20.07/Lambda/#7713" class="Function Operator">caseâ€²</a> <a id="7776" href="/20.07/Lambda/#7776" class="Bound">L</a> <a id="7778" href="/20.07/Lambda/#7713" class="Function Operator">[zeroâ‡’</a> <a id="7785" href="/20.07/Lambda/#7785" class="Bound">M</a> <a id="7787" href="/20.07/Lambda/#7713" class="Function Operator">|suc</a> <a id="7792" class="Symbol">(</a><a id="7793" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="7795" href="/20.07/Lambda/#7795" class="Bound">x</a><a id="7796" class="Symbol">)</a> <a id="7798" href="/20.07/Lambda/#7713" class="Function Operator">â‡’</a> <a id="7800" href="/20.07/Lambda/#7800" class="Bound">N</a> <a id="7802" href="/20.07/Lambda/#7713" class="Function Operator">]</a>  <a id="7805" class="Symbol">=</a>  <a id="7808" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="7813" href="/20.07/Lambda/#7776" class="Bound">L</a> <a id="7815" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="7822" href="/20.07/Lambda/#7785" class="Bound">M</a> <a id="7824" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="7829" href="/20.07/Lambda/#7795" class="Bound">x</a> <a id="7831" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="7833" href="/20.07/Lambda/#7800" class="Bound">N</a> <a id="7835" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a>
<a id="7837" href="/20.07/Lambda/#7713" class="CatchallClause Function Operator">caseâ€²</a><a id="7842" class="CatchallClause"> </a><a id="7843" class="CatchallClause Symbol">_</a><a id="7844" class="CatchallClause"> </a><a id="7845" href="/20.07/Lambda/#7713" class="CatchallClause Function Operator">[zeroâ‡’</a><a id="7851" class="CatchallClause"> </a><a id="7852" class="CatchallClause Symbol">_</a><a id="7853" class="CatchallClause"> </a><a id="7854" href="/20.07/Lambda/#7713" class="CatchallClause Function Operator">|suc</a><a id="7858" class="CatchallClause"> </a><a id="7859" class="CatchallClause Symbol">_</a><a id="7860" class="CatchallClause"> </a><a id="7861" href="/20.07/Lambda/#7713" class="CatchallClause Function Operator">â‡’</a><a id="7862" class="CatchallClause"> </a><a id="7863" class="CatchallClause Symbol">_</a><a id="7864" class="CatchallClause"> </a><a id="7865" href="/20.07/Lambda/#7713" class="CatchallClause Function Operator">]</a>      <a id="7872" class="Symbol">=</a>  <a id="7875" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#294" class="Function">âŠ¥-elim</a> <a id="7882" href="/20.07/Lambda/#7911" class="Postulate">impossible</a>
  <a id="7895" class="Keyword">where</a> <a id="7901" class="Keyword">postulate</a> <a id="7911" href="/20.07/Lambda/#7911" class="Postulate">impossible</a> <a id="7922" class="Symbol">:</a> <a id="7924" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#279" class="Datatype">âŠ¥</a>

<a id="Î¼â€²_â‡’_"></a><a id="7927" href="/20.07/Lambda/#7927" class="Function Operator">Î¼â€²_â‡’_</a> <a id="7933" class="Symbol">:</a> <a id="7935" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="7940" class="Symbol">â†’</a> <a id="7942" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="7947" class="Symbol">â†’</a> <a id="7949" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="7954" href="/20.07/Lambda/#7927" class="Function Operator">Î¼â€²</a> <a id="7957" class="Symbol">(</a><a id="7958" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="7960" href="/20.07/Lambda/#7960" class="Bound">x</a><a id="7961" class="Symbol">)</a> <a id="7963" href="/20.07/Lambda/#7927" class="Function Operator">â‡’</a> <a id="7965" href="/20.07/Lambda/#7965" class="Bound">N</a>  <a id="7968" class="Symbol">=</a>  <a id="7971" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼</a> <a id="7973" href="/20.07/Lambda/#7960" class="Bound">x</a> <a id="7975" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">â‡’</a> <a id="7977" href="/20.07/Lambda/#7965" class="Bound">N</a>
<a id="7979" href="/20.07/Lambda/#7927" class="CatchallClause Function Operator">Î¼â€²</a><a id="7981" class="CatchallClause"> </a><a id="7982" class="CatchallClause Symbol">_</a><a id="7983" class="CatchallClause"> </a><a id="7984" href="/20.07/Lambda/#7927" class="CatchallClause Function Operator">â‡’</a><a id="7985" class="CatchallClause"> </a><a id="7986" class="CatchallClause Symbol">_</a>      <a id="7993" class="Symbol">=</a>  <a id="7996" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#294" class="Function">âŠ¥-elim</a> <a id="8003" href="/20.07/Lambda/#8032" class="Postulate">impossible</a>
  <a id="8016" class="Keyword">where</a> <a id="8022" class="Keyword">postulate</a> <a id="8032" href="/20.07/Lambda/#8032" class="Postulate">impossible</a> <a id="8043" class="Symbol">:</a> <a id="8045" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#279" class="Datatype">âŠ¥</a>
</pre><p>We intend to apply the function only when the first term is a variable, which we indicate by postulating a term <code class="language-plaintext highlighter-rouge">impossible</code> of the empty type <code class="language-plaintext highlighter-rouge">âŠ¥</code>. If we use C-c C-n to normalise the term</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Æ›â€² two â‡’ two
</code></pre></div></div><p>Agda will return an answer warning us that the impossible has occurred:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âŠ¥-elim (plfa.part2.Lambda.impossible (`` `suc (`suc `zero)) (`suc (`suc `zero)) ``)
</code></pre></div></div><p>While postulating the impossible is a useful technique, it must be used with care, since such postulation could allow us to provide evidence of <em>any</em> proposition whatsoever, regardless of its truth.</p><p>The definition of <code class="language-plaintext highlighter-rouge">plus</code> can now be written as follows:</p><pre class="Agda"><a id="plusâ€²"></a><a id="8681" href="/20.07/Lambda/#8681" class="Function">plusâ€²</a> <a id="8687" class="Symbol">:</a> <a id="8689" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="8694" href="/20.07/Lambda/#8681" class="Function">plusâ€²</a> <a id="8700" class="Symbol">=</a> <a id="8702" href="/20.07/Lambda/#7927" class="Function Operator">Î¼â€²</a> <a id="8705" href="/20.07/Lambda/#8812" class="Function">+</a> <a id="8707" href="/20.07/Lambda/#7927" class="Function Operator">â‡’</a> <a id="8709" href="/20.07/Lambda/#7592" class="Function Operator">Æ›â€²</a> <a id="8712" href="/20.07/Lambda/#8826" class="Function">m</a> <a id="8714" href="/20.07/Lambda/#7592" class="Function Operator">â‡’</a> <a id="8716" href="/20.07/Lambda/#7592" class="Function Operator">Æ›â€²</a> <a id="8719" href="/20.07/Lambda/#8840" class="Function">n</a> <a id="8721" href="/20.07/Lambda/#7592" class="Function Operator">â‡’</a>
          <a id="8733" href="/20.07/Lambda/#7713" class="Function Operator">caseâ€²</a> <a id="8739" href="/20.07/Lambda/#8826" class="Function">m</a>
            <a id="8753" href="/20.07/Lambda/#7713" class="Function Operator">[zeroâ‡’</a> <a id="8760" href="/20.07/Lambda/#8840" class="Function">n</a>
            <a id="8774" href="/20.07/Lambda/#7713" class="Function Operator">|suc</a> <a id="8779" href="/20.07/Lambda/#8826" class="Function">m</a> <a id="8781" href="/20.07/Lambda/#7713" class="Function Operator">â‡’</a> <a id="8783" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="8788" class="Symbol">(</a><a id="8789" href="/20.07/Lambda/#8812" class="Function">+</a> <a id="8791" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="8793" href="/20.07/Lambda/#8826" class="Function">m</a> <a id="8795" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="8797" href="/20.07/Lambda/#8840" class="Function">n</a><a id="8798" class="Symbol">)</a> <a id="8800" href="/20.07/Lambda/#7713" class="Function Operator">]</a>
  <a id="8804" class="Keyword">where</a>
  <a id="8812" href="/20.07/Lambda/#8812" class="Function">+</a>  <a id="8815" class="Symbol">=</a>  <a id="8818" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="8820" class="String">&quot;+&quot;</a>
  <a id="8826" href="/20.07/Lambda/#8826" class="Function">m</a>  <a id="8829" class="Symbol">=</a>  <a id="8832" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="8834" class="String">&quot;m&quot;</a>
  <a id="8840" href="/20.07/Lambda/#8840" class="Function">n</a>  <a id="8843" class="Symbol">=</a>  <a id="8846" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="8848" class="String">&quot;n&quot;</a>
</pre><p>Write out the definition of multiplication in the same style.</p><h3 id="formal-vs-informal">Formal vs informal</h3><p>In informal presentation of formal semantics, one uses choice of variable name to disambiguate and writes <code class="language-plaintext highlighter-rouge">x</code> rather than <code class="language-plaintext highlighter-rouge">` x</code> for a term that is a variable. Agda requires we distinguish.</p><p>Similarly, informal presentation often use the same notation for function types, lambda abstraction, and function application in both the <em>object language</em> (the language one is describing) and the <em>meta-language</em> (the language in which the description is written), trusting readers can use context to distinguish the two. Agda is not quite so forgiving, so here we use <code class="language-plaintext highlighter-rouge">Æ› x â‡’ N</code> and <code class="language-plaintext highlighter-rouge">L Â· M</code> for the object language, as compared to <code class="language-plaintext highlighter-rouge">Î» x â†’ N</code> and <code class="language-plaintext highlighter-rouge">L M</code> in our meta-language, Agda.</p><h3 id="bound-and-free-variables">Bound and free variables</h3><p>In an abstraction <code class="language-plaintext highlighter-rouge">Æ› x â‡’ N</code> we call <code class="language-plaintext highlighter-rouge">x</code> the <em>bound</em> variable and <code class="language-plaintext highlighter-rouge">N</code> the <em>body</em> of the abstraction. A central feature of lambda calculus is that consistent renaming of bound variables leaves the meaning of a term unchanged. Thus the five terms</p><ul><li><code class="language-plaintext highlighter-rouge">Æ› "s" â‡’ Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z")</code></li><li><code class="language-plaintext highlighter-rouge">Æ› "f" â‡’ Æ› "x" â‡’ ` "f" Â· (` "f" Â· ` "x")</code></li><li><code class="language-plaintext highlighter-rouge">Æ› "sam" â‡’ Æ› "zelda" â‡’ ` "sam" Â· (` "sam" Â· ` "zelda")</code></li><li><code class="language-plaintext highlighter-rouge">Æ› "z" â‡’ Æ› "s" â‡’ ` "z" Â· (` "z" Â· ` "s")</code></li><li><code class="language-plaintext highlighter-rouge">Æ› "ğŸ˜‡" â‡’ Æ› "ğŸ˜ˆ" â‡’ ` "ğŸ˜‡" Â· (` "ğŸ˜‡" Â· ` "ğŸ˜ˆ" )</code></li></ul><p>are all considered equivalent. Following the convention introduced by Haskell Curry, who used the Greek letter <code class="language-plaintext highlighter-rouge">Î±</code> (<em>alpha</em>) to label such rules, this equivalence relation is called <em>alpha renaming</em>.</p><p>As we descend from a term into its subterms, variables that are bound may become free. Consider the following terms:</p><ul><li><p><code class="language-plaintext highlighter-rouge">Æ› "s" â‡’ Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z")</code> has both <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">z</code> as bound variables.</p></li><li><p><code class="language-plaintext highlighter-rouge">Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z")</code> has <code class="language-plaintext highlighter-rouge">z</code> bound and <code class="language-plaintext highlighter-rouge">s</code> free.</p></li><li><p><code class="language-plaintext highlighter-rouge">` "s" Â· (` "s" Â· ` "z")</code> has both <code class="language-plaintext highlighter-rouge">s</code> and <code class="language-plaintext highlighter-rouge">z</code> as free variables.</p></li></ul><p>We say that a term with no free variables is <em>closed</em>; otherwise it is <em>open</em>. Of the three terms above, the first is closed and the other two are open. We will focus on reduction of closed terms.</p><p>Different occurrences of a variable may be bound and free. In the term</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Æ› "x" â‡’ ` "x") Â· ` "x"
</code></pre></div></div><p>the inner occurrence of <code class="language-plaintext highlighter-rouge">x</code> is bound while the outer occurrence is free. By alpha renaming, the term above is equivalent to</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Æ› "y" â‡’ ` "y") Â· ` "x"
</code></pre></div></div><p>in which <code class="language-plaintext highlighter-rouge">y</code> is bound and <code class="language-plaintext highlighter-rouge">x</code> is free. A common convention, called the <em>Barendregt convention</em>, is to use alpha renaming to ensure that the bound variables in a term are distinct from the free variables, which can avoid confusions that may arise if bound and free variables have the same names.</p><p>Case and recursion also introduce bound variables, which are also subject to alpha renaming. In the term</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Î¼ "+" â‡’ Æ› "m" â‡’ Æ› "n" â‡’
  case ` "m"
    [zeroâ‡’ ` "n"
    |suc "m" â‡’ `suc (` "+" Â· ` "m" Â· ` "n") ]
</code></pre></div></div><p>notice that there are two binding occurrences of <code class="language-plaintext highlighter-rouge">m</code>, one in the first line and one in the last line. It is equivalent to the following term,</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Î¼ "plus" â‡’ Æ› "x" â‡’ Æ› "y" â‡’
  case ` "x"
    [zeroâ‡’ ` "y"
    |suc "xâ€²" â‡’ `suc (` "plus" Â· ` "xâ€²" Â· ` "y") ]
</code></pre></div></div><p>where the two binding occurrences corresponding to <code class="language-plaintext highlighter-rouge">m</code> now have distinct names, <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">xâ€²</code>.</p><h2 id="values">Values</h2><p>A <em>value</em> is a term that corresponds to an answer. Thus, <code class="language-plaintext highlighter-rouge">`suc `suc `suc `suc `zero</code> is a value, while <code class="language-plaintext highlighter-rouge">plus Â· two Â· two</code> is not. Following convention, we treat all function abstractions as values; thus, <code class="language-plaintext highlighter-rouge">plus</code> by itself is considered a value.</p><p>The predicate <code class="language-plaintext highlighter-rouge">Value M</code> holds if term <code class="language-plaintext highlighter-rouge">M</code> is a value:</p><pre class="Agda"><a id="12379" class="Keyword">data</a> <a id="Value"></a><a id="12384" href="/20.07/Lambda/#12384" class="Datatype">Value</a> <a id="12390" class="Symbol">:</a> <a id="12392" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="12397" class="Symbol">â†’</a> <a id="12399" class="PrimitiveType">Set</a> <a id="12403" class="Keyword">where</a>

  <a id="Value.V-Æ›"></a><a id="12412" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a> <a id="12416" class="Symbol">:</a> <a id="12418" class="Symbol">âˆ€</a> <a id="12420" class="Symbol">{</a><a id="12421" href="/20.07/Lambda/#12421" class="Bound">x</a> <a id="12423" href="/20.07/Lambda/#12423" class="Bound">N</a><a id="12424" class="Symbol">}</a>
      <a id="12432" class="Comment">---------------</a>
    <a id="12452" class="Symbol">â†’</a> <a id="12454" href="/20.07/Lambda/#12384" class="Datatype">Value</a> <a id="12460" class="Symbol">(</a><a id="12461" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="12463" href="/20.07/Lambda/#12421" class="Bound">x</a> <a id="12465" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="12467" href="/20.07/Lambda/#12423" class="Bound">N</a><a id="12468" class="Symbol">)</a>

  <a id="Value.V-zero"></a><a id="12473" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a> <a id="12480" class="Symbol">:</a>
      <a id="12488" class="Comment">-----------</a>
      <a id="12506" href="/20.07/Lambda/#12384" class="Datatype">Value</a> <a id="12512" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>

  <a id="Value.V-suc"></a><a id="12521" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="12527" class="Symbol">:</a> <a id="12529" class="Symbol">âˆ€</a> <a id="12531" class="Symbol">{</a><a id="12532" href="/20.07/Lambda/#12532" class="Bound">V</a><a id="12533" class="Symbol">}</a>
    <a id="12539" class="Symbol">â†’</a> <a id="12541" href="/20.07/Lambda/#12384" class="Datatype">Value</a> <a id="12547" href="/20.07/Lambda/#12532" class="Bound">V</a>
      <a id="12555" class="Comment">--------------</a>
    <a id="12574" class="Symbol">â†’</a> <a id="12576" href="/20.07/Lambda/#12384" class="Datatype">Value</a> <a id="12582" class="Symbol">(</a><a id="12583" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="12588" href="/20.07/Lambda/#12532" class="Bound">V</a><a id="12589" class="Symbol">)</a>
</pre><p>In what follows, we let <code class="language-plaintext highlighter-rouge">V</code> and <code class="language-plaintext highlighter-rouge">W</code> range over values.</p><h3 id="formal-vs-informal-1">Formal vs informal</h3><p>In informal presentations of formal semantics, using <code class="language-plaintext highlighter-rouge">V</code> as the name of a metavariable is sufficient to indicate that it is a value. In Agda, we must explicitly invoke the <code class="language-plaintext highlighter-rouge">Value</code> predicate.</p><h3 id="other-approaches">Other approaches</h3><p>An alternative is not to focus on closed terms, to treat variables as values, and to treat <code class="language-plaintext highlighter-rouge">Æ› x â‡’ N</code> as a value only if <code class="language-plaintext highlighter-rouge">N</code> is a value. Indeed, this is how Agda normalises terms. We consider this approach in Chapter <a href="/20.07/Untyped/">Untyped</a>.</p><h2 id="substitution">Substitution</h2><p>The heart of lambda calculus is the operation of substituting one term for a variable in another term. Substitution plays a key role in defining the operational semantics of function application. For instance, we have</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  (Æ› "s" â‡’ Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z")) Â· sucá¶œ Â· `zero
â€”â†’
  (Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· `zero
â€”â†’
  sucá¶œ Â· (sucá¶œ Â· `zero)
</code></pre></div></div><p>where we substitute <code class="language-plaintext highlighter-rouge">sucá¶œ</code> for <code class="language-plaintext highlighter-rouge">` "s"</code> and <code class="language-plaintext highlighter-rouge">`zero</code> for <code class="language-plaintext highlighter-rouge">` "z"</code> in the body of the function abstraction.</p><p>We write substitution as <code class="language-plaintext highlighter-rouge">N [ x := V ]</code>, meaning â€œsubstitute term <code class="language-plaintext highlighter-rouge">V</code> for free occurrences of variable <code class="language-plaintext highlighter-rouge">x</code> in term <code class="language-plaintext highlighter-rouge">N</code>â€, or, more compactly, â€œsubstitute <code class="language-plaintext highlighter-rouge">V</code> for <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">N</code>â€, or equivalently, â€œin <code class="language-plaintext highlighter-rouge">N</code> replace <code class="language-plaintext highlighter-rouge">x</code> by <code class="language-plaintext highlighter-rouge">V</code>â€. Substitution works if <code class="language-plaintext highlighter-rouge">V</code> is any closed term; it need not be a value, but we use <code class="language-plaintext highlighter-rouge">V</code> since in fact we usually substitute values.</p><p>Here are some examples:</p><ul><li><code class="language-plaintext highlighter-rouge">(Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z")) [ "s" := sucá¶œ ]</code> yields <code class="language-plaintext highlighter-rouge">Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")</code>.</li><li><code class="language-plaintext highlighter-rouge">(sucá¶œ Â· (sucá¶œ Â· ` "z")) [ "z" := `zero ]</code> yields <code class="language-plaintext highlighter-rouge">sucá¶œ Â· (sucá¶œ Â· `zero)</code>.</li><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "y") [ "y" := `zero ]</code> yields <code class="language-plaintext highlighter-rouge">Æ› "x" â‡’ `zero</code>.</li><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x") [ "x" := `zero ]</code> yields <code class="language-plaintext highlighter-rouge">Æ› "x" â‡’ ` "x"</code>.</li><li><code class="language-plaintext highlighter-rouge">(Æ› "y" â‡’ ` "y") [ "x" := `zero ]</code> yields <code class="language-plaintext highlighter-rouge">Æ› "y" â‡’ ` "y"</code>.</li></ul><p>In the last but one example, substituting <code class="language-plaintext highlighter-rouge">`zero</code> for <code class="language-plaintext highlighter-rouge">x</code> in <code class="language-plaintext highlighter-rouge">Æ› "x" â‡’ ` "x"</code> does <em>not</em> yield <code class="language-plaintext highlighter-rouge">Æ› "x" â‡’ `zero</code>, since <code class="language-plaintext highlighter-rouge">x</code> is bound in the lambda abstraction. The choice of bound names is irrelevant: both <code class="language-plaintext highlighter-rouge">Æ› "x" â‡’ ` "x"</code> and <code class="language-plaintext highlighter-rouge">Æ› "y" â‡’ ` "y"</code> stand for the identity function. One way to think of this is that <code class="language-plaintext highlighter-rouge">x</code> within the body of the abstraction stands for a <em>different</em> variable than <code class="language-plaintext highlighter-rouge">x</code> outside the abstraction, they just happen to have the same name.</p><p>We will give a definition of substitution that is only valid when term substituted for the variable is closed. This is because substitution by terms that are <em>not</em> closed may require renaming of bound variables. For example:</p><ul><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x" Â· ` "y") [ "y" := ` "x" Â· `zero]</code> should not yield<br><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x" Â· (` "x" Â· `zero))</code>.</li></ul><p>Instead, we should rename the bound variable to avoid capture:</p><ul><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x" Â· ` "y") [ "y" := ` "x" Â· `zero ]</code> should yield<br><code class="language-plaintext highlighter-rouge">Æ› "xâ€²" â‡’ ` "xâ€²" Â· (` "x" Â· `zero)</code>.</li></ul><p>Here <code class="language-plaintext highlighter-rouge">xâ€²</code> is a fresh variable distinct from <code class="language-plaintext highlighter-rouge">x</code>. Formal definition of substitution with suitable renaming is considerably more complex, so we avoid it by restricting to substitution by closed terms, which will be adequate for our purposes.</p><p>Here is the formal definition of substitution by closed terms in Agda:</p><pre class="Agda"><a id="15752" class="Keyword">infix</a> <a id="15758" class="Number">9</a> <a id="15760" href="/20.07/Lambda/#15769" class="Function Operator">_[_:=_]</a>

<a id="_[_:=_]"></a><a id="15769" href="/20.07/Lambda/#15769" class="Function Operator">_[_:=_]</a> <a id="15777" class="Symbol">:</a> <a id="15779" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="15784" class="Symbol">â†’</a> <a id="15786" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="15789" class="Symbol">â†’</a> <a id="15791" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="15796" class="Symbol">â†’</a> <a id="15798" href="/20.07/Lambda/#4005" class="Datatype">Term</a>
<a id="15803" class="Symbol">(</a><a id="15804" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="15806" href="/20.07/Lambda/#15806" class="Bound">x</a><a id="15807" class="Symbol">)</a> <a id="15809" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="15811" href="/20.07/Lambda/#15811" class="Bound">y</a> <a id="15813" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="15816" href="/20.07/Lambda/#15816" class="Bound">V</a> <a id="15818" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="15820" class="Keyword">with</a> <a id="15825" href="/20.07/Lambda/#15806" class="Bound">x</a> <a id="15827" href="https://agda.github.io/agda-stdlib/v1.1/Data.String.Properties.html#2569" class="Function Operator">â‰Ÿ</a> <a id="15829" href="/20.07/Lambda/#15811" class="Bound">y</a>
<a id="15831" class="Symbol">...</a> <a id="15835" class="Symbol">|</a> <a id="15837" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#641" class="InductiveConstructor">yes</a> <a id="15841" class="Symbol">_</a>          <a id="15852" class="Symbol">=</a>  <a id="15855" class="Bound">V</a>
<a id="15857" class="Symbol">...</a> <a id="15861" class="Symbol">|</a> <a id="15863" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#668" class="InductiveConstructor">no</a>  <a id="15867" class="Symbol">_</a>          <a id="15878" class="Symbol">=</a>  <a id="15881" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="15883" class="Bound">x</a>
<a id="15885" class="Symbol">(</a><a id="15886" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="15888" href="/20.07/Lambda/#15888" class="Bound">x</a> <a id="15890" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="15892" href="/20.07/Lambda/#15892" class="Bound">N</a><a id="15893" class="Symbol">)</a> <a id="15895" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="15897" href="/20.07/Lambda/#15897" class="Bound">y</a> <a id="15899" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="15902" href="/20.07/Lambda/#15902" class="Bound">V</a> <a id="15904" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="15906" class="Keyword">with</a> <a id="15911" href="/20.07/Lambda/#15888" class="Bound">x</a> <a id="15913" href="https://agda.github.io/agda-stdlib/v1.1/Data.String.Properties.html#2569" class="Function Operator">â‰Ÿ</a> <a id="15915" href="/20.07/Lambda/#15897" class="Bound">y</a>
<a id="15917" class="Symbol">...</a> <a id="15921" class="Symbol">|</a> <a id="15923" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#641" class="InductiveConstructor">yes</a> <a id="15927" class="Symbol">_</a>          <a id="15938" class="Symbol">=</a>  <a id="15941" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="15943" class="Bound">x</a> <a id="15945" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="15947" class="Bound">N</a>
<a id="15949" class="Symbol">...</a> <a id="15953" class="Symbol">|</a> <a id="15955" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#668" class="InductiveConstructor">no</a>  <a id="15959" class="Symbol">_</a>          <a id="15970" class="Symbol">=</a>  <a id="15973" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="15975" class="Bound">x</a> <a id="15977" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="15979" class="Bound">N</a> <a id="15981" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="15983" class="Bound">y</a> <a id="15985" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="15988" class="Bound">V</a> <a id="15990" href="/20.07/Lambda/#15769" class="Function Operator">]</a>
<a id="15992" class="Symbol">(</a><a id="15993" href="/20.07/Lambda/#15993" class="Bound">L</a> <a id="15995" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="15997" href="/20.07/Lambda/#15997" class="Bound">M</a><a id="15998" class="Symbol">)</a> <a id="16000" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16002" href="/20.07/Lambda/#16002" class="Bound">y</a> <a id="16004" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16007" href="/20.07/Lambda/#16007" class="Bound">V</a> <a id="16009" href="/20.07/Lambda/#15769" class="Function Operator">]</a>   <a id="16013" class="Symbol">=</a>  <a id="16016" href="/20.07/Lambda/#15993" class="Bound">L</a> <a id="16018" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16020" href="/20.07/Lambda/#16002" class="Bound">y</a> <a id="16022" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16025" href="/20.07/Lambda/#16007" class="Bound">V</a> <a id="16027" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="16029" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="16031" href="/20.07/Lambda/#15997" class="Bound">M</a> <a id="16033" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16035" href="/20.07/Lambda/#16002" class="Bound">y</a> <a id="16037" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16040" href="/20.07/Lambda/#16007" class="Bound">V</a> <a id="16042" href="/20.07/Lambda/#15769" class="Function Operator">]</a>
<a id="16044" class="Symbol">(</a><a id="16045" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="16050" class="Symbol">)</a> <a id="16052" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16054" href="/20.07/Lambda/#16054" class="Bound">y</a> <a id="16056" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16059" href="/20.07/Lambda/#16059" class="Bound">V</a> <a id="16061" href="/20.07/Lambda/#15769" class="Function Operator">]</a>   <a id="16065" class="Symbol">=</a>  <a id="16068" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
<a id="16074" class="Symbol">(</a><a id="16075" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="16080" href="/20.07/Lambda/#16080" class="Bound">M</a><a id="16081" class="Symbol">)</a> <a id="16083" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16085" href="/20.07/Lambda/#16085" class="Bound">y</a> <a id="16087" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16090" href="/20.07/Lambda/#16090" class="Bound">V</a> <a id="16092" href="/20.07/Lambda/#15769" class="Function Operator">]</a>  <a id="16095" class="Symbol">=</a>  <a id="16098" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="16103" href="/20.07/Lambda/#16080" class="Bound">M</a> <a id="16105" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16107" href="/20.07/Lambda/#16085" class="Bound">y</a> <a id="16109" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16112" href="/20.07/Lambda/#16090" class="Bound">V</a> <a id="16114" href="/20.07/Lambda/#15769" class="Function Operator">]</a>
<a id="16116" class="Symbol">(</a><a id="16117" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="16122" href="/20.07/Lambda/#16122" class="Bound">L</a> <a id="16124" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="16131" href="/20.07/Lambda/#16131" class="Bound">M</a> <a id="16133" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="16138" href="/20.07/Lambda/#16138" class="Bound">x</a> <a id="16140" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="16142" href="/20.07/Lambda/#16142" class="Bound">N</a> <a id="16144" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="16145" class="Symbol">)</a> <a id="16147" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16149" href="/20.07/Lambda/#16149" class="Bound">y</a> <a id="16151" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16154" href="/20.07/Lambda/#16154" class="Bound">V</a> <a id="16156" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="16158" class="Keyword">with</a> <a id="16163" href="/20.07/Lambda/#16138" class="Bound">x</a> <a id="16165" href="https://agda.github.io/agda-stdlib/v1.1/Data.String.Properties.html#2569" class="Function Operator">â‰Ÿ</a> <a id="16167" href="/20.07/Lambda/#16149" class="Bound">y</a>
<a id="16169" class="Symbol">...</a> <a id="16173" class="Symbol">|</a> <a id="16175" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#641" class="InductiveConstructor">yes</a> <a id="16179" class="Symbol">_</a>          <a id="16190" class="Symbol">=</a>  <a id="16193" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="16198" class="Bound">L</a> <a id="16200" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16202" class="Bound">y</a> <a id="16204" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16207" class="Bound">V</a> <a id="16209" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="16211" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="16218" class="Bound">M</a> <a id="16220" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16222" class="Bound">y</a> <a id="16224" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16227" class="Bound">V</a> <a id="16229" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="16231" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="16236" class="Bound">x</a> <a id="16238" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="16240" class="Bound">N</a> <a id="16242" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a>
<a id="16244" class="Symbol">...</a> <a id="16248" class="Symbol">|</a> <a id="16250" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#668" class="InductiveConstructor">no</a>  <a id="16254" class="Symbol">_</a>          <a id="16265" class="Symbol">=</a>  <a id="16268" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="16273" class="Bound">L</a> <a id="16275" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16277" class="Bound">y</a> <a id="16279" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16282" class="Bound">V</a> <a id="16284" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="16286" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="16293" class="Bound">M</a> <a id="16295" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16297" class="Bound">y</a> <a id="16299" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16302" class="Bound">V</a> <a id="16304" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="16306" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="16311" class="Bound">x</a> <a id="16313" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="16315" class="Bound">N</a> <a id="16317" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16319" class="Bound">y</a> <a id="16321" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16324" class="Bound">V</a> <a id="16326" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="16328" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a>
<a id="16330" class="Symbol">(</a><a id="16331" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼</a> <a id="16333" href="/20.07/Lambda/#16333" class="Bound">x</a> <a id="16335" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">â‡’</a> <a id="16337" href="/20.07/Lambda/#16337" class="Bound">N</a><a id="16338" class="Symbol">)</a> <a id="16340" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16342" href="/20.07/Lambda/#16342" class="Bound">y</a> <a id="16344" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16347" href="/20.07/Lambda/#16347" class="Bound">V</a> <a id="16349" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="16351" class="Keyword">with</a> <a id="16356" href="/20.07/Lambda/#16333" class="Bound">x</a> <a id="16358" href="https://agda.github.io/agda-stdlib/v1.1/Data.String.Properties.html#2569" class="Function Operator">â‰Ÿ</a> <a id="16360" href="/20.07/Lambda/#16342" class="Bound">y</a>
<a id="16362" class="Symbol">...</a> <a id="16366" class="Symbol">|</a> <a id="16368" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#641" class="InductiveConstructor">yes</a> <a id="16372" class="Symbol">_</a>          <a id="16383" class="Symbol">=</a>  <a id="16386" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼</a> <a id="16388" class="Bound">x</a> <a id="16390" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">â‡’</a> <a id="16392" class="Bound">N</a>
<a id="16394" class="Symbol">...</a> <a id="16398" class="Symbol">|</a> <a id="16400" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#668" class="InductiveConstructor">no</a>  <a id="16404" class="Symbol">_</a>          <a id="16415" class="Symbol">=</a>  <a id="16418" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼</a> <a id="16420" class="Bound">x</a> <a id="16422" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">â‡’</a> <a id="16424" class="Bound">N</a> <a id="16426" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="16428" class="Bound">y</a> <a id="16430" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="16433" class="Bound">V</a> <a id="16435" href="/20.07/Lambda/#15769" class="Function Operator">]</a>
</pre><p>Letâ€™s unpack the first three cases:</p><ul><li><p>For variables, we compare <code class="language-plaintext highlighter-rouge">y</code>, the substituted variable, with <code class="language-plaintext highlighter-rouge">x</code>, the variable in the term. If they are the same, we yield <code class="language-plaintext highlighter-rouge">V</code>, otherwise we yield <code class="language-plaintext highlighter-rouge">x</code> unchanged.</p></li><li><p>For abstractions, we compare <code class="language-plaintext highlighter-rouge">y</code>, the substituted variable, with <code class="language-plaintext highlighter-rouge">x</code>, the variable bound in the abstraction. If they are the same, we yield the abstraction unchanged, otherwise we substitute inside the body.</p></li><li><p>For application, we recursively substitute in the function and the argument.</p></li></ul><p>Case expressions and recursion also have bound variables that are treated similarly to those in lambda abstractions. Otherwise we simply push substitution recursively into the subterms.</p><h3 id="examples">Examples</h3><p>Here is confirmation that the examples above are correct:</p><pre class="Agda"><a id="17202" href="/20.07/Lambda/#17202" class="Function">_</a> <a id="17204" class="Symbol">:</a> <a id="17206" class="Symbol">(</a><a id="17207" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="17209" class="String">&quot;z&quot;</a> <a id="17213" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="17215" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17217" class="String">&quot;s&quot;</a> <a id="17221" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="17223" class="Symbol">(</a><a id="17224" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17226" class="String">&quot;s&quot;</a> <a id="17230" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="17232" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17234" class="String">&quot;z&quot;</a><a id="17237" class="Symbol">))</a> <a id="17240" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="17242" class="String">&quot;s&quot;</a> <a id="17246" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="17249" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="17254" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="17256" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">â‰¡</a> <a id="17258" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="17260" class="String">&quot;z&quot;</a> <a id="17264" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="17266" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="17271" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="17273" class="Symbol">(</a><a id="17274" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="17279" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="17281" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17283" class="String">&quot;z&quot;</a><a id="17286" class="Symbol">)</a>
<a id="17288" class="Symbol">_</a> <a id="17290" class="Symbol">=</a> <a id="17292" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="17298" href="/20.07/Lambda/#17298" class="Function">_</a> <a id="17300" class="Symbol">:</a> <a id="17302" class="Symbol">(</a><a id="17303" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="17308" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="17310" class="Symbol">(</a><a id="17311" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="17316" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="17318" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17320" class="String">&quot;z&quot;</a><a id="17323" class="Symbol">))</a> <a id="17326" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="17328" class="String">&quot;z&quot;</a> <a id="17332" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="17335" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="17341" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="17343" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">â‰¡</a> <a id="17345" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="17350" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="17352" class="Symbol">(</a><a id="17353" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="17358" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="17360" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="17365" class="Symbol">)</a>
<a id="17367" class="Symbol">_</a> <a id="17369" class="Symbol">=</a> <a id="17371" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="17377" href="/20.07/Lambda/#17377" class="Function">_</a> <a id="17379" class="Symbol">:</a> <a id="17381" class="Symbol">(</a><a id="17382" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="17384" class="String">&quot;x&quot;</a> <a id="17388" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="17390" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17392" class="String">&quot;y&quot;</a><a id="17395" class="Symbol">)</a> <a id="17397" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="17399" class="String">&quot;y&quot;</a> <a id="17403" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="17406" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="17412" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="17414" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">â‰¡</a> <a id="17416" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="17418" class="String">&quot;x&quot;</a> <a id="17422" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="17424" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
<a id="17430" class="Symbol">_</a> <a id="17432" class="Symbol">=</a> <a id="17434" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="17440" href="/20.07/Lambda/#17440" class="Function">_</a> <a id="17442" class="Symbol">:</a> <a id="17444" class="Symbol">(</a><a id="17445" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="17447" class="String">&quot;x&quot;</a> <a id="17451" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="17453" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17455" class="String">&quot;x&quot;</a><a id="17458" class="Symbol">)</a> <a id="17460" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="17462" class="String">&quot;x&quot;</a> <a id="17466" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="17469" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="17475" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="17477" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">â‰¡</a> <a id="17479" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="17481" class="String">&quot;x&quot;</a> <a id="17485" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="17487" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17489" class="String">&quot;x&quot;</a>
<a id="17493" class="Symbol">_</a> <a id="17495" class="Symbol">=</a> <a id="17497" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>

<a id="17503" href="/20.07/Lambda/#17503" class="Function">_</a> <a id="17505" class="Symbol">:</a> <a id="17507" class="Symbol">(</a><a id="17508" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="17510" class="String">&quot;y&quot;</a> <a id="17514" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="17516" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17518" class="String">&quot;y&quot;</a><a id="17521" class="Symbol">)</a> <a id="17523" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="17525" class="String">&quot;x&quot;</a> <a id="17529" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="17532" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="17538" href="/20.07/Lambda/#15769" class="Function Operator">]</a> <a id="17540" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">â‰¡</a> <a id="17542" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="17544" class="String">&quot;y&quot;</a> <a id="17548" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="17550" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="17552" class="String">&quot;y&quot;</a>
<a id="17556" class="Symbol">_</a> <a id="17558" class="Symbol">=</a> <a id="17560" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre><h4 id="quiz">Quiz</h4><p>What is the result of the following substitution?</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Æ› "y" â‡’ ` "x" Â· (Æ› "x" â‡’ ` "x")) [ "x" := `zero ]
</code></pre></div></div><ol><li><code class="language-plaintext highlighter-rouge">(Æ› "y" â‡’ ` "x" Â· (Æ› "x" â‡’ ` "x"))</code></li><li><code class="language-plaintext highlighter-rouge">(Æ› "y" â‡’ ` "x" Â· (Æ› "x" â‡’ `zero))</code></li><li><code class="language-plaintext highlighter-rouge">(Æ› "y" â‡’ `zero Â· (Æ› "x" â‡’ ` "x"))</code></li><li><code class="language-plaintext highlighter-rouge">(Æ› "y" â‡’ `zero Â· (Æ› "x" â‡’ `zero))</code></li></ol><h4 id="exercise-___-stretch">Exercise <code class="language-plaintext highlighter-rouge">_[_:=_]â€²</code> (stretch)</h4><p>The definition of substitution above has three clauses (<code class="language-plaintext highlighter-rouge">Æ›</code>, <code class="language-plaintext highlighter-rouge">case</code>, and <code class="language-plaintext highlighter-rouge">Î¼</code>) that invoke a <code class="language-plaintext highlighter-rouge">with</code> clause to deal with bound variables. Rewrite the definition to factor the common part of these three clauses into a single function, defined by mutual recursion with substitution.</p><pre class="Agda"><a id="18183" class="Comment">-- Your code goes here</a>
</pre><h2 id="reduction">Reduction</h2><p>We give the reduction rules for call-by-value lambda calculus. To reduce an application, first we reduce the left-hand side until it becomes a value (which must be an abstraction); then we reduce the right-hand side until it becomes a value; and finally we substitute the argument for the variable in the abstraction.</p><p>In an informal presentation of the operational semantics, the rules for reduction of applications are written as follows:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>L â€”â†’ Lâ€²
--------------- Î¾-Â·â‚
L Â· M â€”â†’ Lâ€² Â· M

M â€”â†’ Mâ€²
--------------- Î¾-Â·â‚‚
V Â· M â€”â†’ V Â· Mâ€²

----------------------------- Î²-Æ›
(Æ› x â‡’ N) Â· V â€”â†’ N [ x := V ]
</code></pre></div></div><p>The Agda version of the rules below will be similar, except that universal quantifications are made explicit, and so are the predicates that indicate which terms are values.</p><p>The rules break into two sorts. Compatibility rules direct us to reduce some part of a term. We give them names starting with the Greek letter <code class="language-plaintext highlighter-rouge">Î¾</code> (<em>xi</em>). Once a term is sufficiently reduced, it will consist of a constructor and a deconstructor, in our case <code class="language-plaintext highlighter-rouge">Æ›</code> and <code class="language-plaintext highlighter-rouge">Â·</code>, which reduces directly. We give them names starting with the Greek letter <code class="language-plaintext highlighter-rouge">Î²</code> (<em>beta</em>) and such rules are traditionally called <em>beta rules</em>.</p><p>A bit of terminology: A term that matches the left-hand side of a reduction rule is called a <em>redex</em>. In the redex <code class="language-plaintext highlighter-rouge">(Æ› x â‡’ N) Â· V</code>, we may refer to <code class="language-plaintext highlighter-rouge">x</code> as the <em>formal parameter</em> of the function, and <code class="language-plaintext highlighter-rouge">V</code> as the <em>actual parameter</em> of the function application. Beta reduction replaces the formal parameter by the actual parameter.</p><p>If a term is a value, then no reduction applies; conversely, if a reduction applies to a term then it is not a value. We will show in the next chapter that this exhausts the possibilities: every well-typed term either reduces or is a value.</p><p>For numbers, zero does not reduce and successor reduces the subterm. A case expression reduces its argument to a number, and then chooses the zero or successor branch as appropriate. A fixpoint replaces the bound variable by the entire fixpoint term; this is the one case where we substitute by a term that is not a value.</p><p>Here are the rules formalised in Agda:</p><pre class="Agda"><a id="20390" class="Keyword">infix</a> <a id="20396" class="Number">4</a> <a id="20398" href="/20.07/Lambda/#20409" class="Datatype Operator">_â€”â†’_</a>

<a id="20404" class="Keyword">data</a> <a id="_â€”â†’_"></a><a id="20409" href="/20.07/Lambda/#20409" class="Datatype Operator">_â€”â†’_</a> <a id="20414" class="Symbol">:</a> <a id="20416" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="20421" class="Symbol">â†’</a> <a id="20423" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="20428" class="Symbol">â†’</a> <a id="20430" class="PrimitiveType">Set</a> <a id="20434" class="Keyword">where</a>

  <a id="_â€”â†’_.Î¾-Â·â‚"></a><a id="20443" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="20448" class="Symbol">:</a> <a id="20450" class="Symbol">âˆ€</a> <a id="20452" class="Symbol">{</a><a id="20453" href="/20.07/Lambda/#20453" class="Bound">L</a> <a id="20455" href="/20.07/Lambda/#20455" class="Bound">Lâ€²</a> <a id="20458" href="/20.07/Lambda/#20458" class="Bound">M</a><a id="20459" class="Symbol">}</a>
    <a id="20465" class="Symbol">â†’</a> <a id="20467" href="/20.07/Lambda/#20453" class="Bound">L</a> <a id="20469" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20472" href="/20.07/Lambda/#20455" class="Bound">Lâ€²</a>
      <a id="20481" class="Comment">-----------------</a>
    <a id="20503" class="Symbol">â†’</a> <a id="20505" href="/20.07/Lambda/#20453" class="Bound">L</a> <a id="20507" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="20509" href="/20.07/Lambda/#20458" class="Bound">M</a> <a id="20511" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20514" href="/20.07/Lambda/#20455" class="Bound">Lâ€²</a> <a id="20517" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="20519" href="/20.07/Lambda/#20458" class="Bound">M</a>

  <a id="_â€”â†’_.Î¾-Â·â‚‚"></a><a id="20524" href="/20.07/Lambda/#20524" class="InductiveConstructor">Î¾-Â·â‚‚</a> <a id="20529" class="Symbol">:</a> <a id="20531" class="Symbol">âˆ€</a> <a id="20533" class="Symbol">{</a><a id="20534" href="/20.07/Lambda/#20534" class="Bound">V</a> <a id="20536" href="/20.07/Lambda/#20536" class="Bound">M</a> <a id="20538" href="/20.07/Lambda/#20538" class="Bound">Mâ€²</a><a id="20540" class="Symbol">}</a>
    <a id="20546" class="Symbol">â†’</a> <a id="20548" href="/20.07/Lambda/#12384" class="Datatype">Value</a> <a id="20554" href="/20.07/Lambda/#20534" class="Bound">V</a>
    <a id="20560" class="Symbol">â†’</a> <a id="20562" href="/20.07/Lambda/#20536" class="Bound">M</a> <a id="20564" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20567" href="/20.07/Lambda/#20538" class="Bound">Mâ€²</a>
      <a id="20576" class="Comment">-----------------</a>
    <a id="20598" class="Symbol">â†’</a> <a id="20600" href="/20.07/Lambda/#20534" class="Bound">V</a> <a id="20602" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="20604" href="/20.07/Lambda/#20536" class="Bound">M</a> <a id="20606" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20609" href="/20.07/Lambda/#20534" class="Bound">V</a> <a id="20611" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="20613" href="/20.07/Lambda/#20538" class="Bound">Mâ€²</a>

  <a id="_â€”â†’_.Î²-Æ›"></a><a id="20619" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="20623" class="Symbol">:</a> <a id="20625" class="Symbol">âˆ€</a> <a id="20627" class="Symbol">{</a><a id="20628" href="/20.07/Lambda/#20628" class="Bound">x</a> <a id="20630" href="/20.07/Lambda/#20630" class="Bound">N</a> <a id="20632" href="/20.07/Lambda/#20632" class="Bound">V</a><a id="20633" class="Symbol">}</a>
    <a id="20639" class="Symbol">â†’</a> <a id="20641" href="/20.07/Lambda/#12384" class="Datatype">Value</a> <a id="20647" href="/20.07/Lambda/#20632" class="Bound">V</a>
      <a id="20655" class="Comment">------------------------------</a>
    <a id="20690" class="Symbol">â†’</a> <a id="20692" class="Symbol">(</a><a id="20693" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="20695" href="/20.07/Lambda/#20628" class="Bound">x</a> <a id="20697" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="20699" href="/20.07/Lambda/#20630" class="Bound">N</a><a id="20700" class="Symbol">)</a> <a id="20702" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="20704" href="/20.07/Lambda/#20632" class="Bound">V</a> <a id="20706" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20709" href="/20.07/Lambda/#20630" class="Bound">N</a> <a id="20711" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="20713" href="/20.07/Lambda/#20628" class="Bound">x</a> <a id="20715" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="20718" href="/20.07/Lambda/#20632" class="Bound">V</a> <a id="20720" href="/20.07/Lambda/#15769" class="Function Operator">]</a>

  <a id="_â€”â†’_.Î¾-suc"></a><a id="20725" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="20731" class="Symbol">:</a> <a id="20733" class="Symbol">âˆ€</a> <a id="20735" class="Symbol">{</a><a id="20736" href="/20.07/Lambda/#20736" class="Bound">M</a> <a id="20738" href="/20.07/Lambda/#20738" class="Bound">Mâ€²</a><a id="20740" class="Symbol">}</a>
    <a id="20746" class="Symbol">â†’</a> <a id="20748" href="/20.07/Lambda/#20736" class="Bound">M</a> <a id="20750" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20753" href="/20.07/Lambda/#20738" class="Bound">Mâ€²</a>
      <a id="20762" class="Comment">------------------</a>
    <a id="20785" class="Symbol">â†’</a> <a id="20787" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="20792" href="/20.07/Lambda/#20736" class="Bound">M</a> <a id="20794" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20797" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="20802" href="/20.07/Lambda/#20738" class="Bound">Mâ€²</a>

  <a id="_â€”â†’_.Î¾-case"></a><a id="20808" href="/20.07/Lambda/#20808" class="InductiveConstructor">Î¾-case</a> <a id="20815" class="Symbol">:</a> <a id="20817" class="Symbol">âˆ€</a> <a id="20819" class="Symbol">{</a><a id="20820" href="/20.07/Lambda/#20820" class="Bound">x</a> <a id="20822" href="/20.07/Lambda/#20822" class="Bound">L</a> <a id="20824" href="/20.07/Lambda/#20824" class="Bound">Lâ€²</a> <a id="20827" href="/20.07/Lambda/#20827" class="Bound">M</a> <a id="20829" href="/20.07/Lambda/#20829" class="Bound">N</a><a id="20830" class="Symbol">}</a>
    <a id="20836" class="Symbol">â†’</a> <a id="20838" href="/20.07/Lambda/#20822" class="Bound">L</a> <a id="20840" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20843" href="/20.07/Lambda/#20824" class="Bound">Lâ€²</a>
      <a id="20852" class="Comment">-----------------------------------------------------------------</a>
    <a id="20922" class="Symbol">â†’</a> <a id="20924" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="20929" href="/20.07/Lambda/#20822" class="Bound">L</a> <a id="20931" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="20938" href="/20.07/Lambda/#20827" class="Bound">M</a> <a id="20940" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="20945" href="/20.07/Lambda/#20820" class="Bound">x</a> <a id="20947" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="20949" href="/20.07/Lambda/#20829" class="Bound">N</a> <a id="20951" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a> <a id="20953" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="20956" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="20961" href="/20.07/Lambda/#20824" class="Bound">Lâ€²</a> <a id="20964" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="20971" href="/20.07/Lambda/#20827" class="Bound">M</a> <a id="20973" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="20978" href="/20.07/Lambda/#20820" class="Bound">x</a> <a id="20980" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="20982" href="/20.07/Lambda/#20829" class="Bound">N</a> <a id="20984" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a>

  <a id="_â€”â†’_.Î²-zero"></a><a id="20989" href="/20.07/Lambda/#20989" class="InductiveConstructor">Î²-zero</a> <a id="20996" class="Symbol">:</a> <a id="20998" class="Symbol">âˆ€</a> <a id="21000" class="Symbol">{</a><a id="21001" href="/20.07/Lambda/#21001" class="Bound">x</a> <a id="21003" href="/20.07/Lambda/#21003" class="Bound">M</a> <a id="21005" href="/20.07/Lambda/#21005" class="Bound">N</a><a id="21006" class="Symbol">}</a>
      <a id="21014" class="Comment">----------------------------------------</a>
    <a id="21059" class="Symbol">â†’</a> <a id="21061" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="21066" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="21072" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="21079" href="/20.07/Lambda/#21003" class="Bound">M</a> <a id="21081" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="21086" href="/20.07/Lambda/#21001" class="Bound">x</a> <a id="21088" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="21090" href="/20.07/Lambda/#21005" class="Bound">N</a> <a id="21092" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a> <a id="21094" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="21097" href="/20.07/Lambda/#21003" class="Bound">M</a>

  <a id="_â€”â†’_.Î²-suc"></a><a id="21102" href="/20.07/Lambda/#21102" class="InductiveConstructor">Î²-suc</a> <a id="21108" class="Symbol">:</a> <a id="21110" class="Symbol">âˆ€</a> <a id="21112" class="Symbol">{</a><a id="21113" href="/20.07/Lambda/#21113" class="Bound">x</a> <a id="21115" href="/20.07/Lambda/#21115" class="Bound">V</a> <a id="21117" href="/20.07/Lambda/#21117" class="Bound">M</a> <a id="21119" href="/20.07/Lambda/#21119" class="Bound">N</a><a id="21120" class="Symbol">}</a>
    <a id="21126" class="Symbol">â†’</a> <a id="21128" href="/20.07/Lambda/#12384" class="Datatype">Value</a> <a id="21134" href="/20.07/Lambda/#21115" class="Bound">V</a>
      <a id="21142" class="Comment">---------------------------------------------------</a>
    <a id="21198" class="Symbol">â†’</a> <a id="21200" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="21205" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="21210" href="/20.07/Lambda/#21115" class="Bound">V</a> <a id="21212" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="21219" href="/20.07/Lambda/#21117" class="Bound">M</a> <a id="21221" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="21226" href="/20.07/Lambda/#21113" class="Bound">x</a> <a id="21228" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="21230" href="/20.07/Lambda/#21119" class="Bound">N</a> <a id="21232" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a> <a id="21234" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="21237" href="/20.07/Lambda/#21119" class="Bound">N</a> <a id="21239" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="21241" href="/20.07/Lambda/#21113" class="Bound">x</a> <a id="21243" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="21246" href="/20.07/Lambda/#21115" class="Bound">V</a> <a id="21248" href="/20.07/Lambda/#15769" class="Function Operator">]</a>

  <a id="_â€”â†’_.Î²-Î¼"></a><a id="21253" href="/20.07/Lambda/#21253" class="InductiveConstructor">Î²-Î¼</a> <a id="21257" class="Symbol">:</a> <a id="21259" class="Symbol">âˆ€</a> <a id="21261" class="Symbol">{</a><a id="21262" href="/20.07/Lambda/#21262" class="Bound">x</a> <a id="21264" href="/20.07/Lambda/#21264" class="Bound">M</a><a id="21265" class="Symbol">}</a>
      <a id="21273" class="Comment">------------------------------</a>
    <a id="21308" class="Symbol">â†’</a> <a id="21310" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼</a> <a id="21312" href="/20.07/Lambda/#21262" class="Bound">x</a> <a id="21314" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">â‡’</a> <a id="21316" href="/20.07/Lambda/#21264" class="Bound">M</a> <a id="21318" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="21321" href="/20.07/Lambda/#21264" class="Bound">M</a> <a id="21323" href="/20.07/Lambda/#15769" class="Function Operator">[</a> <a id="21325" href="/20.07/Lambda/#21262" class="Bound">x</a> <a id="21327" href="/20.07/Lambda/#15769" class="Function Operator">:=</a> <a id="21330" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼</a> <a id="21332" href="/20.07/Lambda/#21262" class="Bound">x</a> <a id="21334" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">â‡’</a> <a id="21336" href="/20.07/Lambda/#21264" class="Bound">M</a> <a id="21338" href="/20.07/Lambda/#15769" class="Function Operator">]</a>
</pre><p>The reduction rules are carefully designed to ensure that subterms of a term are reduced to values before the whole term is reduced. This is referred to as <em>call-by-value</em> reduction.</p><p>Further, we have arranged that subterms are reduced in a left-to-right order. This means that reduction is <em>deterministic</em>: for any term, there is at most one other term to which it reduces. Put another way, our reduction relation <code class="language-plaintext highlighter-rouge">â€”â†’</code> is in fact a function.</p><p>This style of explaining the meaning of terms is called a <em>small-step operational semantics</em>. If <code class="language-plaintext highlighter-rouge">M â€”â†’ N</code>, we say that term <code class="language-plaintext highlighter-rouge">M</code> <em>reduces</em> to term <code class="language-plaintext highlighter-rouge">N</code>, or equivalently, term <code class="language-plaintext highlighter-rouge">M</code> <em>steps</em> to term <code class="language-plaintext highlighter-rouge">N</code>. Each compatibility rule has another reduction rule in its premise; so a step always consists of a beta rule, possibly adjusted by zero or more compatibility rules.</p><h4 id="quiz-1">Quiz</h4><p>What does the following term step to?</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x")  â€”â†’  ???
</code></pre></div></div><ol><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x")</code></li><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x")</code></li><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x")</code></li></ol><p>What does the following term step to?</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x")  â€”â†’  ???
</code></pre></div></div><ol><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x")</code></li><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x")</code></li><li><code class="language-plaintext highlighter-rouge">(Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x") Â· (Æ› "x" â‡’ ` "x")</code></li></ol><p>What does the following term step to? (Where <code class="language-plaintext highlighter-rouge">twoá¶œ</code> and <code class="language-plaintext highlighter-rouge">sucá¶œ</code> are as defined above.)</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>twoá¶œ Â· sucá¶œ Â· `zero  â€”â†’  ???
</code></pre></div></div><ol><li><code class="language-plaintext highlighter-rouge">sucá¶œ Â· (sucá¶œ Â· `zero)</code></li><li><code class="language-plaintext highlighter-rouge">(Æ› "z" â‡’ sucá¶œ Â· (sucá¶œ Â· ` "z")) Â· `zero</code></li><li><code class="language-plaintext highlighter-rouge">`zero</code></li></ol><h2 id="reflexive-and-transitive-closure">Reflexive and transitive closure</h2><p>A single step is only part of the story. In general, we wish to repeatedly step a closed term until it reduces to a value. We do this by defining the reflexive and transitive closure <code class="language-plaintext highlighter-rouge">â€”â† </code> of the step relation <code class="language-plaintext highlighter-rouge">â€”â†’</code>.</p><p>We define reflexive and transitive closure as a sequence of zero or more steps of the underlying relation, along lines similar to that for reasoning about chains of equalities in Chapter <a href="/20.07/Equality/">Equality</a>:</p><pre class="Agda"><a id="23334" class="Keyword">infix</a>  <a id="23341" class="Number">2</a> <a id="23343" href="/20.07/Lambda/#23399" class="Datatype Operator">_â€”â† _</a>
<a id="23348" class="Keyword">infix</a>  <a id="23355" class="Number">1</a> <a id="23357" href="/20.07/Lambda/#23549" class="Function Operator">begin_</a>
<a id="23364" class="Keyword">infixr</a> <a id="23371" class="Number">2</a> <a id="23373" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">_â€”â†’âŸ¨_âŸ©_</a>
<a id="23381" class="Keyword">infix</a>  <a id="23388" class="Number">3</a> <a id="23390" href="/20.07/Lambda/#23432" class="InductiveConstructor Operator">_âˆ</a>

<a id="23394" class="Keyword">data</a> <a id="_â€”â† _"></a><a id="23399" href="/20.07/Lambda/#23399" class="Datatype Operator">_â€”â† _</a> <a id="23404" class="Symbol">:</a> <a id="23406" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="23411" class="Symbol">â†’</a> <a id="23413" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="23418" class="Symbol">â†’</a> <a id="23420" class="PrimitiveType">Set</a> <a id="23424" class="Keyword">where</a>
  <a id="_â€”â† _._âˆ"></a><a id="23432" href="/20.07/Lambda/#23432" class="InductiveConstructor Operator">_âˆ</a> <a id="23435" class="Symbol">:</a> <a id="23437" class="Symbol">âˆ€</a> <a id="23439" href="/20.07/Lambda/#23439" class="Bound">M</a>
      <a id="23447" class="Comment">---------</a>
    <a id="23461" class="Symbol">â†’</a> <a id="23463" href="/20.07/Lambda/#23439" class="Bound">M</a> <a id="23465" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="23468" href="/20.07/Lambda/#23439" class="Bound">M</a>

  <a id="_â€”â† _._â€”â†’âŸ¨_âŸ©_"></a><a id="23473" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">_â€”â†’âŸ¨_âŸ©_</a> <a id="23481" class="Symbol">:</a> <a id="23483" class="Symbol">âˆ€</a> <a id="23485" href="/20.07/Lambda/#23485" class="Bound">L</a> <a id="23487" class="Symbol">{</a><a id="23488" href="/20.07/Lambda/#23488" class="Bound">M</a> <a id="23490" href="/20.07/Lambda/#23490" class="Bound">N</a><a id="23491" class="Symbol">}</a>
    <a id="23497" class="Symbol">â†’</a> <a id="23499" href="/20.07/Lambda/#23485" class="Bound">L</a> <a id="23501" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="23504" href="/20.07/Lambda/#23488" class="Bound">M</a>
    <a id="23510" class="Symbol">â†’</a> <a id="23512" href="/20.07/Lambda/#23488" class="Bound">M</a> <a id="23514" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="23517" href="/20.07/Lambda/#23490" class="Bound">N</a>
      <a id="23525" class="Comment">---------</a>
    <a id="23539" class="Symbol">â†’</a> <a id="23541" href="/20.07/Lambda/#23485" class="Bound">L</a> <a id="23543" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="23546" href="/20.07/Lambda/#23490" class="Bound">N</a>

<a id="begin_"></a><a id="23549" href="/20.07/Lambda/#23549" class="Function Operator">begin_</a> <a id="23556" class="Symbol">:</a> <a id="23558" class="Symbol">âˆ€</a> <a id="23560" class="Symbol">{</a><a id="23561" href="/20.07/Lambda/#23561" class="Bound">M</a> <a id="23563" href="/20.07/Lambda/#23563" class="Bound">N</a><a id="23564" class="Symbol">}</a>
  <a id="23568" class="Symbol">â†’</a> <a id="23570" href="/20.07/Lambda/#23561" class="Bound">M</a> <a id="23572" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="23575" href="/20.07/Lambda/#23563" class="Bound">N</a>
    <a id="23581" class="Comment">------</a>
  <a id="23590" class="Symbol">â†’</a> <a id="23592" href="/20.07/Lambda/#23561" class="Bound">M</a> <a id="23594" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="23597" href="/20.07/Lambda/#23563" class="Bound">N</a>
<a id="23599" href="/20.07/Lambda/#23549" class="Function Operator">begin</a> <a id="23605" href="/20.07/Lambda/#23605" class="Bound">Mâ€”â† N</a> <a id="23610" class="Symbol">=</a> <a id="23612" href="/20.07/Lambda/#23605" class="Bound">Mâ€”â† N</a>
</pre><p>We can read this as follows:</p><ul><li><p>From term <code class="language-plaintext highlighter-rouge">M</code>, we can take no steps, giving a step of type <code class="language-plaintext highlighter-rouge">M â€”â†  M</code>. It is written <code class="language-plaintext highlighter-rouge">M âˆ</code>.</p></li><li><p>From term <code class="language-plaintext highlighter-rouge">L</code> we can take a single step of type <code class="language-plaintext highlighter-rouge">L â€”â†’ M</code> followed by zero or more steps of type <code class="language-plaintext highlighter-rouge">M â€”â†  N</code>, giving a step of type <code class="language-plaintext highlighter-rouge">L â€”â†  N</code>. It is written <code class="language-plaintext highlighter-rouge">L â€”â†’âŸ¨ Lâ€”â†’M âŸ© Mâ€”â† N</code>, where <code class="language-plaintext highlighter-rouge">Lâ€”â†’M</code> and <code class="language-plaintext highlighter-rouge">Mâ€”â† N</code> are steps of the appropriate type.</p></li></ul><p>The notation is chosen to allow us to lay out example reductions in an appealing way, as we will see in the next section.</p><p>An alternative is to define reflexive and transitive closure directly, as the smallest relation that includes <code class="language-plaintext highlighter-rouge">â€”â†’</code> and is also reflexive and transitive. We could do so as follows:</p><pre class="Agda"><a id="24295" class="Keyword">data</a> <a id="_â€”â† â€²_"></a><a id="24300" href="/20.07/Lambda/#24300" class="Datatype Operator">_â€”â† â€²_</a> <a id="24306" class="Symbol">:</a> <a id="24308" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="24313" class="Symbol">â†’</a> <a id="24315" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="24320" class="Symbol">â†’</a> <a id="24322" class="PrimitiveType">Set</a> <a id="24326" class="Keyword">where</a>

  <a id="_â€”â† â€²_.stepâ€²"></a><a id="24335" href="/20.07/Lambda/#24335" class="InductiveConstructor">stepâ€²</a> <a id="24341" class="Symbol">:</a> <a id="24343" class="Symbol">âˆ€</a> <a id="24345" class="Symbol">{</a><a id="24346" href="/20.07/Lambda/#24346" class="Bound">M</a> <a id="24348" href="/20.07/Lambda/#24348" class="Bound">N</a><a id="24349" class="Symbol">}</a>
    <a id="24355" class="Symbol">â†’</a> <a id="24357" href="/20.07/Lambda/#24346" class="Bound">M</a> <a id="24359" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="24362" href="/20.07/Lambda/#24348" class="Bound">N</a>
      <a id="24370" class="Comment">-------</a>
    <a id="24382" class="Symbol">â†’</a> <a id="24384" href="/20.07/Lambda/#24346" class="Bound">M</a> <a id="24386" href="/20.07/Lambda/#24300" class="Datatype Operator">â€”â† â€²</a> <a id="24390" href="/20.07/Lambda/#24348" class="Bound">N</a>

  <a id="_â€”â† â€²_.reflâ€²"></a><a id="24395" href="/20.07/Lambda/#24395" class="InductiveConstructor">reflâ€²</a> <a id="24401" class="Symbol">:</a> <a id="24403" class="Symbol">âˆ€</a> <a id="24405" class="Symbol">{</a><a id="24406" href="/20.07/Lambda/#24406" class="Bound">M</a><a id="24407" class="Symbol">}</a>
      <a id="24415" class="Comment">-------</a>
    <a id="24427" class="Symbol">â†’</a> <a id="24429" href="/20.07/Lambda/#24406" class="Bound">M</a> <a id="24431" href="/20.07/Lambda/#24300" class="Datatype Operator">â€”â† â€²</a> <a id="24435" href="/20.07/Lambda/#24406" class="Bound">M</a>

  <a id="_â€”â† â€²_.transâ€²"></a><a id="24440" href="/20.07/Lambda/#24440" class="InductiveConstructor">transâ€²</a> <a id="24447" class="Symbol">:</a> <a id="24449" class="Symbol">âˆ€</a> <a id="24451" class="Symbol">{</a><a id="24452" href="/20.07/Lambda/#24452" class="Bound">L</a> <a id="24454" href="/20.07/Lambda/#24454" class="Bound">M</a> <a id="24456" href="/20.07/Lambda/#24456" class="Bound">N</a><a id="24457" class="Symbol">}</a>
    <a id="24463" class="Symbol">â†’</a> <a id="24465" href="/20.07/Lambda/#24452" class="Bound">L</a> <a id="24467" href="/20.07/Lambda/#24300" class="Datatype Operator">â€”â† â€²</a> <a id="24471" href="/20.07/Lambda/#24454" class="Bound">M</a>
    <a id="24477" class="Symbol">â†’</a> <a id="24479" href="/20.07/Lambda/#24454" class="Bound">M</a> <a id="24481" href="/20.07/Lambda/#24300" class="Datatype Operator">â€”â† â€²</a> <a id="24485" href="/20.07/Lambda/#24456" class="Bound">N</a>
      <a id="24493" class="Comment">-------</a>
    <a id="24505" class="Symbol">â†’</a> <a id="24507" href="/20.07/Lambda/#24452" class="Bound">L</a> <a id="24509" href="/20.07/Lambda/#24300" class="Datatype Operator">â€”â† â€²</a> <a id="24513" href="/20.07/Lambda/#24456" class="Bound">N</a>
</pre><p>The three constructors specify, respectively, that <code class="language-plaintext highlighter-rouge">â€”â† â€²</code> includes <code class="language-plaintext highlighter-rouge">â€”â†’</code> and is reflexive and transitive. A good exercise is to show that the two definitions are equivalent (indeed, one embeds in the other).</p><h4 id="exercise--practice">Exercise <code class="language-plaintext highlighter-rouge">â€”â† â‰²â€”â† â€²</code> (practice)</h4><p>Show that the first notion of reflexive and transitive closure above embeds into the second. Why are they not isomorphic?</p><pre class="Agda"><a id="24889" class="Comment">-- Your code goes here</a>
</pre><h2 id="confluence">Confluence</h2><p>One important property a reduction relation might satisfy is to be <em>confluent</em>. If term <code class="language-plaintext highlighter-rouge">L</code> reduces to two other terms, <code class="language-plaintext highlighter-rouge">M</code> and <code class="language-plaintext highlighter-rouge">N</code>, then both of these reduce to a common term <code class="language-plaintext highlighter-rouge">P</code>. It can be illustrated as follows:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           L
          / \
         /   \
        /     \
       M       N
        \     /
         \   /
          \ /
           P
</code></pre></div></div><p>Here <code class="language-plaintext highlighter-rouge">L</code>, <code class="language-plaintext highlighter-rouge">M</code>, <code class="language-plaintext highlighter-rouge">N</code> are universally quantified while <code class="language-plaintext highlighter-rouge">P</code> is existentially quantified. If each line stands for zero or more reduction steps, this is called confluence, while if the top two lines stand for a single reduction step and the bottom two stand for zero or more reduction steps it is called the diamond property. In symbols:</p><pre class="Agda"><a id="25657" class="Keyword">postulate</a>
  <a id="confluence"></a><a id="25669" href="/20.07/Lambda/#25669" class="Postulate">confluence</a> <a id="25680" class="Symbol">:</a> <a id="25682" class="Symbol">âˆ€</a> <a id="25684" class="Symbol">{</a><a id="25685" href="/20.07/Lambda/#25685" class="Bound">L</a> <a id="25687" href="/20.07/Lambda/#25687" class="Bound">M</a> <a id="25689" href="/20.07/Lambda/#25689" class="Bound">N</a><a id="25690" class="Symbol">}</a>
    <a id="25696" class="Symbol">â†’</a> <a id="25698" class="Symbol">((</a><a id="25700" href="/20.07/Lambda/#25685" class="Bound">L</a> <a id="25702" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="25705" href="/20.07/Lambda/#25687" class="Bound">M</a><a id="25706" class="Symbol">)</a> <a id="25708" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">Ã—</a> <a id="25710" class="Symbol">(</a><a id="25711" href="/20.07/Lambda/#25685" class="Bound">L</a> <a id="25713" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="25716" href="/20.07/Lambda/#25689" class="Bound">N</a><a id="25717" class="Symbol">))</a>
      <a id="25726" class="Comment">--------------------</a>
    <a id="25751" class="Symbol">â†’</a> <a id="25753" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">âˆƒ[</a> <a id="25756" href="/20.07/Lambda/#25756" class="Bound">P</a> <a id="25758" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">]</a> <a id="25760" class="Symbol">((</a><a id="25762" href="/20.07/Lambda/#25687" class="Bound">M</a> <a id="25764" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="25767" href="/20.07/Lambda/#25756" class="Bound">P</a><a id="25768" class="Symbol">)</a> <a id="25770" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">Ã—</a> <a id="25772" class="Symbol">(</a><a id="25773" href="/20.07/Lambda/#25689" class="Bound">N</a> <a id="25775" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="25778" href="/20.07/Lambda/#25756" class="Bound">P</a><a id="25779" class="Symbol">))</a>

  <a id="diamond"></a><a id="25785" href="/20.07/Lambda/#25785" class="Postulate">diamond</a> <a id="25793" class="Symbol">:</a> <a id="25795" class="Symbol">âˆ€</a> <a id="25797" class="Symbol">{</a><a id="25798" href="/20.07/Lambda/#25798" class="Bound">L</a> <a id="25800" href="/20.07/Lambda/#25800" class="Bound">M</a> <a id="25802" href="/20.07/Lambda/#25802" class="Bound">N</a><a id="25803" class="Symbol">}</a>
    <a id="25809" class="Symbol">â†’</a> <a id="25811" class="Symbol">((</a><a id="25813" href="/20.07/Lambda/#25798" class="Bound">L</a> <a id="25815" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="25818" href="/20.07/Lambda/#25800" class="Bound">M</a><a id="25819" class="Symbol">)</a> <a id="25821" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">Ã—</a> <a id="25823" class="Symbol">(</a><a id="25824" href="/20.07/Lambda/#25798" class="Bound">L</a> <a id="25826" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="25829" href="/20.07/Lambda/#25802" class="Bound">N</a><a id="25830" class="Symbol">))</a>
      <a id="25839" class="Comment">--------------------</a>
    <a id="25864" class="Symbol">â†’</a> <a id="25866" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">âˆƒ[</a> <a id="25869" href="/20.07/Lambda/#25869" class="Bound">P</a> <a id="25871" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1783" class="Function">]</a> <a id="25873" class="Symbol">((</a><a id="25875" href="/20.07/Lambda/#25800" class="Bound">M</a> <a id="25877" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="25880" href="/20.07/Lambda/#25869" class="Bound">P</a><a id="25881" class="Symbol">)</a> <a id="25883" href="https://agda.github.io/agda-stdlib/v1.1/Data.Product.html#1162" class="Function Operator">Ã—</a> <a id="25885" class="Symbol">(</a><a id="25886" href="/20.07/Lambda/#25802" class="Bound">N</a> <a id="25888" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="25891" href="/20.07/Lambda/#25869" class="Bound">P</a><a id="25892" class="Symbol">))</a>
</pre><p>The reduction system studied in this chapter is deterministic. In symbols:</p><pre class="Agda"><a id="25980" class="Keyword">postulate</a>
  <a id="deterministic"></a><a id="25992" href="/20.07/Lambda/#25992" class="Postulate">deterministic</a> <a id="26006" class="Symbol">:</a> <a id="26008" class="Symbol">âˆ€</a> <a id="26010" class="Symbol">{</a><a id="26011" href="/20.07/Lambda/#26011" class="Bound">L</a> <a id="26013" href="/20.07/Lambda/#26013" class="Bound">M</a> <a id="26015" href="/20.07/Lambda/#26015" class="Bound">N</a><a id="26016" class="Symbol">}</a>
    <a id="26022" class="Symbol">â†’</a> <a id="26024" href="/20.07/Lambda/#26011" class="Bound">L</a> <a id="26026" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="26029" href="/20.07/Lambda/#26013" class="Bound">M</a>
    <a id="26035" class="Symbol">â†’</a> <a id="26037" href="/20.07/Lambda/#26011" class="Bound">L</a> <a id="26039" href="/20.07/Lambda/#20409" class="Datatype Operator">â€”â†’</a> <a id="26042" href="/20.07/Lambda/#26015" class="Bound">N</a>
      <a id="26050" class="Comment">------</a>
    <a id="26061" class="Symbol">â†’</a> <a id="26063" href="/20.07/Lambda/#26013" class="Bound">M</a> <a id="26065" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">â‰¡</a> <a id="26067" href="/20.07/Lambda/#26015" class="Bound">N</a>
</pre><p>It is easy to show that every deterministic relation satisfies the diamond and confluence properties. Hence, all the reduction systems studied in this text are trivially confluent.</p><h2 id="examples-1">Examples</h2><p>We start with a simple example. The Church numeral two applied to the successor function and zero yields the natural number two:</p><pre class="Agda"><a id="26403" href="/20.07/Lambda/#26403" class="Function">_</a> <a id="26405" class="Symbol">:</a> <a id="26407" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="26412" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26414" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="26419" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26421" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="26427" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="26430" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26435" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26440" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
<a id="26446" class="Symbol">_</a> <a id="26448" class="Symbol">=</a>
  <a id="26452" href="/20.07/Lambda/#23549" class="Function Operator">begin</a>
    <a id="26462" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="26467" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26469" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="26474" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26476" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
  <a id="26484" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="26488" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="26493" class="Symbol">(</a><a id="26494" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="26498" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a><a id="26501" class="Symbol">)</a> <a id="26503" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="26509" class="Symbol">(</a><a id="26510" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="26512" class="String">&quot;z&quot;</a> <a id="26516" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="26518" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="26523" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26525" class="Symbol">(</a><a id="26526" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="26531" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26533" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="26535" class="String">&quot;z&quot;</a><a id="26538" class="Symbol">))</a> <a id="26541" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26543" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
  <a id="26551" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="26555" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="26559" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a> <a id="26566" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="26572" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="26577" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26579" class="Symbol">(</a><a id="26580" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="26585" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26587" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="26592" class="Symbol">)</a>
  <a id="26596" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="26600" href="/20.07/Lambda/#20524" class="InductiveConstructor">Î¾-Â·â‚‚</a> <a id="26605" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a> <a id="26609" class="Symbol">(</a><a id="26610" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="26614" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="26620" class="Symbol">)</a> <a id="26622" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="26628" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="26633" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26635" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26640" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
  <a id="26648" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="26652" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="26656" class="Symbol">(</a><a id="26657" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="26663" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="26669" class="Symbol">)</a> <a id="26671" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="26677" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26682" class="Symbol">(</a><a id="26683" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26688" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="26693" class="Symbol">)</a>
  <a id="26697" href="/20.07/Lambda/#23432" class="InductiveConstructor Operator">âˆ</a>
</pre><p>Here is a sample reduction demonstrating that two plus two is four:</p><pre class="Agda"><a id="26776" href="/20.07/Lambda/#26776" class="Function">_</a> <a id="26778" class="Symbol">:</a> <a id="26780" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="26785" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26787" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="26791" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26793" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="26797" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="26800" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26805" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26810" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26815" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26820" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
<a id="26826" class="Symbol">_</a> <a id="26828" class="Symbol">=</a>
  <a id="26832" href="/20.07/Lambda/#23549" class="Function Operator">begin</a>
    <a id="26842" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="26847" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26849" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="26853" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26855" href="/20.07/Lambda/#4733" class="Function">two</a>
  <a id="26861" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="26865" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="26870" class="Symbol">(</a><a id="26871" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="26876" href="/20.07/Lambda/#21253" class="InductiveConstructor">Î²-Î¼</a><a id="26879" class="Symbol">)</a> <a id="26881" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="26887" class="Symbol">(</a><a id="26888" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="26890" class="String">&quot;m&quot;</a> <a id="26894" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="26896" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="26898" class="String">&quot;n&quot;</a> <a id="26902" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a>
      <a id="26910" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="26915" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="26917" class="String">&quot;m&quot;</a> <a id="26921" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="26928" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="26930" class="String">&quot;n&quot;</a> <a id="26934" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="26939" class="String">&quot;m&quot;</a> <a id="26943" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="26945" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="26950" class="Symbol">(</a><a id="26951" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="26956" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26958" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="26960" class="String">&quot;m&quot;</a> <a id="26964" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26966" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="26968" class="String">&quot;n&quot;</a><a id="26971" class="Symbol">)</a> <a id="26973" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="26974" class="Symbol">)</a>
        <a id="26984" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26986" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="26990" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="26992" href="/20.07/Lambda/#4733" class="Function">two</a>
  <a id="26998" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27002" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="27007" class="Symbol">(</a><a id="27008" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="27012" class="Symbol">(</a><a id="27013" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="27019" class="Symbol">(</a><a id="27020" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="27026" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="27032" class="Symbol">)))</a> <a id="27036" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="27042" class="Symbol">(</a><a id="27043" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="27045" class="String">&quot;n&quot;</a> <a id="27049" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a>
      <a id="27057" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="27062" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="27066" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="27073" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27075" class="String">&quot;n&quot;</a> <a id="27079" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="27084" class="String">&quot;m&quot;</a> <a id="27088" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="27090" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27095" class="Symbol">(</a><a id="27096" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="27101" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27103" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27105" class="String">&quot;m&quot;</a> <a id="27109" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27111" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27113" class="String">&quot;n&quot;</a><a id="27116" class="Symbol">)</a> <a id="27118" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="27119" class="Symbol">)</a>
         <a id="27130" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27132" href="/20.07/Lambda/#4733" class="Function">two</a>
  <a id="27138" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27142" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="27146" class="Symbol">(</a><a id="27147" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="27153" class="Symbol">(</a><a id="27154" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="27160" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="27166" class="Symbol">))</a> <a id="27169" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="27175" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="27180" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="27184" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="27191" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="27195" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="27200" class="String">&quot;m&quot;</a> <a id="27204" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="27206" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27211" class="Symbol">(</a><a id="27212" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="27217" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27219" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27221" class="String">&quot;m&quot;</a> <a id="27225" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27227" href="/20.07/Lambda/#4733" class="Function">two</a><a id="27230" class="Symbol">)</a> <a id="27232" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a>
  <a id="27236" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27240" href="/20.07/Lambda/#21102" class="InductiveConstructor">Î²-suc</a> <a id="27246" class="Symbol">(</a><a id="27247" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="27253" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="27259" class="Symbol">)</a> <a id="27261" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="27267" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27272" class="Symbol">(</a><a id="27273" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="27278" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27280" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27285" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="27291" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27293" href="/20.07/Lambda/#4733" class="Function">two</a><a id="27296" class="Symbol">)</a>
  <a id="27300" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27304" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="27310" class="Symbol">(</a><a id="27311" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="27316" class="Symbol">(</a><a id="27317" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="27322" href="/20.07/Lambda/#21253" class="InductiveConstructor">Î²-Î¼</a><a id="27325" class="Symbol">))</a> <a id="27328" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="27334" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27339" class="Symbol">((</a><a id="27341" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="27343" class="String">&quot;m&quot;</a> <a id="27347" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="27349" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="27351" class="String">&quot;n&quot;</a> <a id="27355" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a>
      <a id="27363" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="27368" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27370" class="String">&quot;m&quot;</a> <a id="27374" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="27381" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27383" class="String">&quot;n&quot;</a> <a id="27387" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="27392" class="String">&quot;m&quot;</a> <a id="27396" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="27398" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27403" class="Symbol">(</a><a id="27404" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="27409" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27411" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27413" class="String">&quot;m&quot;</a> <a id="27417" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27419" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27421" class="String">&quot;n&quot;</a><a id="27424" class="Symbol">)</a> <a id="27426" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="27427" class="Symbol">)</a>
        <a id="27437" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27439" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27444" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="27450" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27452" href="/20.07/Lambda/#4733" class="Function">two</a><a id="27455" class="Symbol">)</a>
  <a id="27459" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27463" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="27469" class="Symbol">(</a><a id="27470" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="27475" class="Symbol">(</a><a id="27476" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="27480" class="Symbol">(</a><a id="27481" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="27487" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="27493" class="Symbol">)))</a> <a id="27497" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="27503" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27508" class="Symbol">((</a><a id="27510" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="27512" class="String">&quot;n&quot;</a> <a id="27516" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a>
      <a id="27524" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="27529" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27534" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="27540" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="27547" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27549" class="String">&quot;n&quot;</a> <a id="27553" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="27558" class="String">&quot;m&quot;</a> <a id="27562" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="27564" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27569" class="Symbol">(</a><a id="27570" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="27575" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27577" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27579" class="String">&quot;m&quot;</a> <a id="27583" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27585" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27587" class="String">&quot;n&quot;</a><a id="27590" class="Symbol">)</a> <a id="27592" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="27593" class="Symbol">)</a>
        <a id="27603" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27605" href="/20.07/Lambda/#4733" class="Function">two</a><a id="27608" class="Symbol">)</a>
  <a id="27612" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27616" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="27622" class="Symbol">(</a><a id="27623" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="27627" class="Symbol">(</a><a id="27628" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="27634" class="Symbol">(</a><a id="27635" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="27641" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="27647" class="Symbol">)))</a> <a id="27651" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="27657" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27662" class="Symbol">(</a><a id="27663" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="27668" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27673" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="27679" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="27686" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="27690" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="27695" class="String">&quot;m&quot;</a> <a id="27699" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="27701" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27706" class="Symbol">(</a><a id="27707" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="27712" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27714" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27716" class="String">&quot;m&quot;</a> <a id="27720" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27722" href="/20.07/Lambda/#4733" class="Function">two</a><a id="27725" class="Symbol">)</a> <a id="27727" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="27728" class="Symbol">)</a>
  <a id="27732" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27736" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="27742" class="Symbol">(</a><a id="27743" href="/20.07/Lambda/#21102" class="InductiveConstructor">Î²-suc</a> <a id="27749" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="27755" class="Symbol">)</a> <a id="27757" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="27763" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27768" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27773" class="Symbol">(</a><a id="27774" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="27779" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27781" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="27787" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27789" href="/20.07/Lambda/#4733" class="Function">two</a><a id="27792" class="Symbol">)</a>
  <a id="27796" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27800" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="27806" class="Symbol">(</a><a id="27807" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="27813" class="Symbol">(</a><a id="27814" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="27819" class="Symbol">(</a><a id="27820" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="27825" href="/20.07/Lambda/#21253" class="InductiveConstructor">Î²-Î¼</a><a id="27828" class="Symbol">)))</a> <a id="27832" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="27838" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27843" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27848" class="Symbol">((</a><a id="27850" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="27852" class="String">&quot;m&quot;</a> <a id="27856" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="27858" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="27860" class="String">&quot;n&quot;</a> <a id="27864" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a>
      <a id="27872" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="27877" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27879" class="String">&quot;m&quot;</a> <a id="27883" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="27890" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27892" class="String">&quot;n&quot;</a> <a id="27896" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="27901" class="String">&quot;m&quot;</a> <a id="27905" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="27907" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="27912" class="Symbol">(</a><a id="27913" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="27918" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27920" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27922" class="String">&quot;m&quot;</a> <a id="27926" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27928" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="27930" class="String">&quot;n&quot;</a><a id="27933" class="Symbol">)</a> <a id="27935" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="27936" class="Symbol">)</a>
        <a id="27946" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27948" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="27954" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="27956" href="/20.07/Lambda/#4733" class="Function">two</a><a id="27959" class="Symbol">)</a>
  <a id="27963" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="27967" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="27973" class="Symbol">(</a><a id="27974" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="27980" class="Symbol">(</a><a id="27981" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="27986" class="Symbol">(</a><a id="27987" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="27991" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="27997" class="Symbol">)))</a> <a id="28001" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="28007" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28012" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28017" class="Symbol">((</a><a id="28019" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28021" class="String">&quot;n&quot;</a> <a id="28025" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a>
      <a id="28033" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="28038" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="28044" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="28051" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28053" class="String">&quot;n&quot;</a> <a id="28057" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="28062" class="String">&quot;m&quot;</a> <a id="28066" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="28068" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28073" class="Symbol">(</a><a id="28074" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="28079" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28081" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28083" class="String">&quot;m&quot;</a> <a id="28087" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28089" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28091" class="String">&quot;n&quot;</a><a id="28094" class="Symbol">)</a> <a id="28096" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="28097" class="Symbol">)</a>
        <a id="28107" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28109" href="/20.07/Lambda/#4733" class="Function">two</a><a id="28112" class="Symbol">)</a>
  <a id="28116" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="28120" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="28126" class="Symbol">(</a><a id="28127" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="28133" class="Symbol">(</a><a id="28134" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="28138" class="Symbol">(</a><a id="28139" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="28145" class="Symbol">(</a><a id="28146" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="28152" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="28158" class="Symbol">))))</a> <a id="28163" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="28169" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28174" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28179" class="Symbol">(</a><a id="28180" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="28185" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="28191" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="28198" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="28202" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="28207" class="String">&quot;m&quot;</a> <a id="28211" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="28213" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28218" class="Symbol">(</a><a id="28219" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="28224" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28226" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28228" class="String">&quot;m&quot;</a> <a id="28232" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28234" href="/20.07/Lambda/#4733" class="Function">two</a><a id="28237" class="Symbol">)</a> <a id="28239" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a><a id="28240" class="Symbol">)</a>
  <a id="28244" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="28248" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="28254" class="Symbol">(</a><a id="28255" href="/20.07/Lambda/#20725" class="InductiveConstructor">Î¾-suc</a> <a id="28261" href="/20.07/Lambda/#20989" class="InductiveConstructor">Î²-zero</a><a id="28267" class="Symbol">)</a> <a id="28269" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="28275" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28280" class="Symbol">(</a><a id="28281" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28286" class="Symbol">(</a><a id="28287" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28292" class="Symbol">(</a><a id="28293" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28298" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="28303" class="Symbol">)))</a>
  <a id="28309" href="/20.07/Lambda/#23432" class="InductiveConstructor Operator">âˆ</a>
</pre><p>And here is a similar sample reduction for Church numerals:</p><pre class="Agda"><a id="28380" href="/20.07/Lambda/#28380" class="Function">_</a> <a id="28382" class="Symbol">:</a> <a id="28384" href="/20.07/Lambda/#6043" class="Function">plusá¶œ</a> <a id="28390" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28392" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28397" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28399" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28404" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28406" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28411" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28413" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="28419" href="/20.07/Lambda/#23399" class="Datatype Operator">â€”â† </a> <a id="28422" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28427" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28432" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28437" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="28442" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
<a id="28448" class="Symbol">_</a> <a id="28450" class="Symbol">=</a>
  <a id="28454" href="/20.07/Lambda/#23549" class="Function Operator">begin</a>
    <a id="28464" class="Symbol">(</a><a id="28465" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28467" class="String">&quot;m&quot;</a> <a id="28471" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28473" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28475" class="String">&quot;n&quot;</a> <a id="28479" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28481" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28483" class="String">&quot;s&quot;</a> <a id="28487" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28489" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28491" class="String">&quot;z&quot;</a> <a id="28495" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28497" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28499" class="String">&quot;m&quot;</a> <a id="28503" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28505" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28507" class="String">&quot;s&quot;</a> <a id="28511" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28513" class="Symbol">(</a><a id="28514" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28516" class="String">&quot;n&quot;</a> <a id="28520" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28522" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28524" class="String">&quot;s&quot;</a> <a id="28528" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28530" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28532" class="String">&quot;z&quot;</a><a id="28535" class="Symbol">))</a>
      <a id="28544" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28546" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28551" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28553" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28558" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28560" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28565" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28567" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
  <a id="28575" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="28579" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="28584" class="Symbol">(</a><a id="28585" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="28590" class="Symbol">(</a><a id="28591" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="28596" class="Symbol">(</a><a id="28597" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="28601" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a><a id="28604" class="Symbol">)))</a> <a id="28608" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="28614" class="Symbol">(</a><a id="28615" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28617" class="String">&quot;n&quot;</a> <a id="28621" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28623" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28625" class="String">&quot;s&quot;</a> <a id="28629" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28631" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28633" class="String">&quot;z&quot;</a> <a id="28637" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28639" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28644" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28646" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28648" class="String">&quot;s&quot;</a> <a id="28652" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28654" class="Symbol">(</a><a id="28655" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28657" class="String">&quot;n&quot;</a> <a id="28661" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28663" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28665" class="String">&quot;s&quot;</a> <a id="28669" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28671" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28673" class="String">&quot;z&quot;</a><a id="28676" class="Symbol">))</a>
      <a id="28685" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28687" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28692" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28694" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28699" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28701" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
  <a id="28709" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="28713" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="28718" class="Symbol">(</a><a id="28719" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="28724" class="Symbol">(</a><a id="28725" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="28729" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a><a id="28732" class="Symbol">))</a> <a id="28735" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="28741" class="Symbol">(</a><a id="28742" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28744" class="String">&quot;s&quot;</a> <a id="28748" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28750" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28752" class="String">&quot;z&quot;</a> <a id="28756" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28758" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28763" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28765" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28767" class="String">&quot;s&quot;</a> <a id="28771" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28773" class="Symbol">(</a><a id="28774" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28779" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28781" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28783" class="String">&quot;s&quot;</a> <a id="28787" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28789" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28791" class="String">&quot;z&quot;</a><a id="28794" class="Symbol">))</a> <a id="28797" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28799" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28804" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28806" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
  <a id="28814" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="28818" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="28823" class="Symbol">(</a><a id="28824" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="28828" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a><a id="28831" class="Symbol">)</a> <a id="28833" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="28839" class="Symbol">(</a><a id="28840" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28842" class="String">&quot;z&quot;</a> <a id="28846" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28848" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28853" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28855" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28860" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28862" class="Symbol">(</a><a id="28863" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28868" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28870" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28875" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28877" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="28879" class="String">&quot;z&quot;</a><a id="28882" class="Symbol">))</a> <a id="28885" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28887" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a>
  <a id="28895" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="28899" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="28903" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a> <a id="28910" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="28916" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28921" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28923" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28928" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28930" class="Symbol">(</a><a id="28931" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="28936" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28938" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28943" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28945" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="28950" class="Symbol">)</a>
  <a id="28954" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="28958" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="28963" class="Symbol">(</a><a id="28964" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="28968" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a><a id="28971" class="Symbol">)</a> <a id="28973" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="28979" class="Symbol">(</a><a id="28980" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="28982" class="String">&quot;z&quot;</a> <a id="28986" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="28988" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="28993" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="28995" class="Symbol">(</a><a id="28996" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29001" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29003" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="29005" class="String">&quot;z&quot;</a><a id="29008" class="Symbol">))</a> <a id="29011" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29013" class="Symbol">(</a><a id="29014" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="29019" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29021" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29026" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29028" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="29033" class="Symbol">)</a>
  <a id="29037" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="29041" href="/20.07/Lambda/#20524" class="InductiveConstructor">Î¾-Â·â‚‚</a> <a id="29046" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a> <a id="29050" class="Symbol">(</a><a id="29051" href="/20.07/Lambda/#20443" class="InductiveConstructor">Î¾-Â·â‚</a> <a id="29056" class="Symbol">(</a><a id="29057" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="29061" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a><a id="29064" class="Symbol">))</a> <a id="29067" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="29073" class="Symbol">(</a><a id="29074" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="29076" class="String">&quot;z&quot;</a> <a id="29080" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="29082" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29087" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29089" class="Symbol">(</a><a id="29090" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29095" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29097" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="29099" class="String">&quot;z&quot;</a><a id="29102" class="Symbol">))</a> <a id="29105" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29107" class="Symbol">((</a><a id="29109" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="29111" class="String">&quot;z&quot;</a> <a id="29115" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="29117" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29122" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29124" class="Symbol">(</a><a id="29125" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29130" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29132" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="29134" class="String">&quot;z&quot;</a><a id="29137" class="Symbol">))</a> <a id="29140" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29142" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="29147" class="Symbol">)</a>
  <a id="29151" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="29155" href="/20.07/Lambda/#20524" class="InductiveConstructor">Î¾-Â·â‚‚</a> <a id="29160" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a> <a id="29164" class="Symbol">(</a><a id="29165" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="29169" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="29175" class="Symbol">)</a> <a id="29177" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="29183" class="Symbol">(</a><a id="29184" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="29186" class="String">&quot;z&quot;</a> <a id="29190" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="29192" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29197" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29199" class="Symbol">(</a><a id="29200" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29205" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29207" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="29209" class="String">&quot;z&quot;</a><a id="29212" class="Symbol">))</a> <a id="29215" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29217" class="Symbol">(</a><a id="29218" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29223" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29225" class="Symbol">(</a><a id="29226" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29231" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29233" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="29238" class="Symbol">))</a>
  <a id="29243" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="29247" href="/20.07/Lambda/#20524" class="InductiveConstructor">Î¾-Â·â‚‚</a> <a id="29252" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a> <a id="29256" class="Symbol">(</a><a id="29257" href="/20.07/Lambda/#20524" class="InductiveConstructor">Î¾-Â·â‚‚</a> <a id="29262" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a> <a id="29266" class="Symbol">(</a><a id="29267" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="29271" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="29277" class="Symbol">))</a> <a id="29280" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="29286" class="Symbol">(</a><a id="29287" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="29289" class="String">&quot;z&quot;</a> <a id="29293" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="29295" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29300" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29302" class="Symbol">(</a><a id="29303" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29308" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29310" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="29312" class="String">&quot;z&quot;</a><a id="29315" class="Symbol">))</a> <a id="29318" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29320" class="Symbol">(</a><a id="29321" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29326" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29328" class="Symbol">(</a><a id="29329" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29334" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="29339" class="Symbol">))</a>
  <a id="29344" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="29348" href="/20.07/Lambda/#20524" class="InductiveConstructor">Î¾-Â·â‚‚</a> <a id="29353" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a> <a id="29357" class="Symbol">(</a><a id="29358" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="29362" class="Symbol">(</a><a id="29363" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="29369" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="29375" class="Symbol">))</a> <a id="29378" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="29384" class="Symbol">(</a><a id="29385" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="29387" class="String">&quot;z&quot;</a> <a id="29391" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="29393" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29398" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29400" class="Symbol">(</a><a id="29401" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29406" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29408" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="29410" class="String">&quot;z&quot;</a><a id="29413" class="Symbol">))</a> <a id="29416" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29418" class="Symbol">(</a><a id="29419" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29424" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29429" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="29434" class="Symbol">)</a>
  <a id="29438" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="29442" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="29446" class="Symbol">(</a><a id="29447" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="29453" class="Symbol">(</a><a id="29454" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="29460" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="29466" class="Symbol">))</a> <a id="29469" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="29475" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29480" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29482" class="Symbol">(</a><a id="29483" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29488" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29490" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29495" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29500" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="29505" class="Symbol">)</a>
  <a id="29509" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="29513" href="/20.07/Lambda/#20524" class="InductiveConstructor">Î¾-Â·â‚‚</a> <a id="29518" href="/20.07/Lambda/#12412" class="InductiveConstructor">V-Æ›</a> <a id="29522" class="Symbol">(</a><a id="29523" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="29527" class="Symbol">(</a><a id="29528" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="29534" class="Symbol">(</a><a id="29535" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="29541" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="29547" class="Symbol">)))</a> <a id="29551" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
    <a id="29557" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="29562" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="29564" class="Symbol">(</a><a id="29565" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29570" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29575" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29580" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="29585" class="Symbol">)</a>
  <a id="29589" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">â€”â†’âŸ¨</a> <a id="29593" href="/20.07/Lambda/#20619" class="InductiveConstructor">Î²-Æ›</a> <a id="29597" class="Symbol">(</a><a id="29598" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="29604" class="Symbol">(</a><a id="29605" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="29611" class="Symbol">(</a><a id="29612" href="/20.07/Lambda/#12521" class="InductiveConstructor">V-suc</a> <a id="29618" href="/20.07/Lambda/#12473" class="InductiveConstructor">V-zero</a><a id="29624" class="Symbol">)))</a> <a id="29628" href="/20.07/Lambda/#23473" class="InductiveConstructor Operator">âŸ©</a>
   <a id="29633" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29638" class="Symbol">(</a><a id="29639" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29644" class="Symbol">(</a><a id="29645" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29650" class="Symbol">(</a><a id="29651" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="29656" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a><a id="29661" class="Symbol">)))</a>
  <a id="29667" href="/20.07/Lambda/#23432" class="InductiveConstructor Operator">âˆ</a>
</pre><p>In the next chapter, we will see how to compute such reduction sequences.</p><h4 id="exercise-plus-example-practice">Exercise <code class="language-plaintext highlighter-rouge">plus-example</code> (practice)</h4><p>Write out the reduction sequence demonstrating that one plus one is two.</p><pre class="Agda"><a id="29869" class="Comment">-- Your code goes here</a>
</pre><h2 id="syntax-of-types">Syntax of types</h2><p>We have just two types:</p><ul><li>Functions, <code class="language-plaintext highlighter-rouge">A â‡’ B</code></li><li>Naturals, <code class="language-plaintext highlighter-rouge">`â„•</code></li></ul><p>As before, to avoid overlap we use variants of the names used by Agda.</p><p>Here is the syntax of types in BNF:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>A, B, C  ::=  A â‡’ B | `â„•
</code></pre></div></div><p>And here it is formalised in Agda:</p><pre class="Agda"><a id="30169" class="Keyword">infixr</a> <a id="30176" class="Number">7</a> <a id="30178" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">_â‡’_</a>

<a id="30183" class="Keyword">data</a> <a id="Type"></a><a id="30188" href="/20.07/Lambda/#30188" class="Datatype">Type</a> <a id="30193" class="Symbol">:</a> <a id="30195" class="PrimitiveType">Set</a> <a id="30199" class="Keyword">where</a>
  <a id="Type._â‡’_"></a><a id="30207" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">_â‡’_</a> <a id="30211" class="Symbol">:</a> <a id="30213" href="/20.07/Lambda/#30188" class="Datatype">Type</a> <a id="30218" class="Symbol">â†’</a> <a id="30220" href="/20.07/Lambda/#30188" class="Datatype">Type</a> <a id="30225" class="Symbol">â†’</a> <a id="30227" href="/20.07/Lambda/#30188" class="Datatype">Type</a>
  <a id="Type.`â„•"></a><a id="30234" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="30237" class="Symbol">:</a> <a id="30239" href="/20.07/Lambda/#30188" class="Datatype">Type</a>
</pre><h3 id="precedence">Precedence</h3><p>As in Agda, functions of two or more arguments are represented via currying. This is made more convenient by declaring <code class="language-plaintext highlighter-rouge">_â‡’_</code> to associate to the right and <code class="language-plaintext highlighter-rouge">_Â·_</code> to associate to the left. Thus:</p><ul><li><code class="language-plaintext highlighter-rouge">(`â„• â‡’ `â„•) â‡’ `â„• â‡’ `â„•</code> stands for <code class="language-plaintext highlighter-rouge">((`â„• â‡’ `â„•) â‡’ (`â„• â‡’ `â„•))</code>.</li><li><code class="language-plaintext highlighter-rouge">plus Â· two Â· two</code> stands for <code class="language-plaintext highlighter-rouge">(plus Â· two) Â· two</code>.</li></ul><h3 id="quiz-2">Quiz</h3><ul><li><p>What is the type of the following term?</p><p><code class="language-plaintext highlighter-rouge">Æ› "s" â‡’ ` "s" Â· (` "s" Â· `zero)</code></p><ol><li><code class="language-plaintext highlighter-rouge">(`â„• â‡’ `â„•) â‡’ (`â„• â‡’ `â„•)</code></li><li><code class="language-plaintext highlighter-rouge">(`â„• â‡’ `â„•) â‡’ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">`â„• â‡’ (`â„• â‡’ `â„•)</code></li><li><code class="language-plaintext highlighter-rouge">`â„• â‡’ `â„• â‡’ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">`â„• â‡’ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">`â„•</code></li></ol><p>Give more than one answer if appropriate.</p></li><li><p>What is the type of the following term?</p><p><code class="language-plaintext highlighter-rouge">(Æ› "s" â‡’ ` "s" Â· (` "s" Â· `zero)) Â· sucá¶œ</code></p><ol><li><code class="language-plaintext highlighter-rouge">(`â„• â‡’ `â„•) â‡’ (`â„• â‡’ `â„•)</code></li><li><code class="language-plaintext highlighter-rouge">(`â„• â‡’ `â„•) â‡’ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">`â„• â‡’ (`â„• â‡’ `â„•)</code></li><li><code class="language-plaintext highlighter-rouge">`â„• â‡’ `â„• â‡’ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">`â„• â‡’ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">`â„•</code></li></ol><p>Give more than one answer if appropriate.</p></li></ul><h2 id="typing">Typing</h2><h3 id="contexts">Contexts</h3><p>While reduction considers only closed terms, typing must consider terms with free variables. To type a term, we must first type its subterms, and in particular in the body of an abstraction its bound variable may appear free.</p><p>A <em>context</em> associates variables with types. We let <code class="language-plaintext highlighter-rouge">Î“</code> and <code class="language-plaintext highlighter-rouge">Î”</code> range over contexts. We write <code class="language-plaintext highlighter-rouge">âˆ…</code> for the empty context, and <code class="language-plaintext highlighter-rouge">Î“ , x â¦‚ A</code> for the context that extends <code class="language-plaintext highlighter-rouge">Î“</code> by mapping variable <code class="language-plaintext highlighter-rouge">x</code> to type <code class="language-plaintext highlighter-rouge">A</code>. For example,</p><ul><li><code class="language-plaintext highlighter-rouge">âˆ… , "s" â¦‚ `â„• â‡’ `â„• , "z" â¦‚ `â„•</code></li></ul><p>is the context that associates variable <code class="language-plaintext highlighter-rouge">"s"</code> with type <code class="language-plaintext highlighter-rouge">`â„• â‡’ `â„•</code>, and variable <code class="language-plaintext highlighter-rouge">"z"</code> with type <code class="language-plaintext highlighter-rouge">`â„•</code>.</p><p>Contexts are formalised as follows:</p><pre class="Agda"><a id="31824" class="Keyword">infixl</a> <a id="31831" class="Number">5</a>  <a id="31834" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">_,_â¦‚_</a>

<a id="31841" class="Keyword">data</a> <a id="Context"></a><a id="31846" href="/20.07/Lambda/#31846" class="Datatype">Context</a> <a id="31854" class="Symbol">:</a> <a id="31856" class="PrimitiveType">Set</a> <a id="31860" class="Keyword">where</a>
  <a id="Context.âˆ…"></a><a id="31868" href="/20.07/Lambda/#31868" class="InductiveConstructor">âˆ…</a>     <a id="31874" class="Symbol">:</a> <a id="31876" href="/20.07/Lambda/#31846" class="Datatype">Context</a>
  <a id="Context._,_â¦‚_"></a><a id="31886" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">_,_â¦‚_</a> <a id="31892" class="Symbol">:</a> <a id="31894" href="/20.07/Lambda/#31846" class="Datatype">Context</a> <a id="31902" class="Symbol">â†’</a> <a id="31904" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="31907" class="Symbol">â†’</a> <a id="31909" href="/20.07/Lambda/#30188" class="Datatype">Type</a> <a id="31914" class="Symbol">â†’</a> <a id="31916" href="/20.07/Lambda/#31846" class="Datatype">Context</a>
</pre><h4 id="exercise-context--practice">Exercise <code class="language-plaintext highlighter-rouge">Context-â‰ƒ</code> (practice)</h4><p>Show that <code class="language-plaintext highlighter-rouge">Context</code> is isomorphic to <code class="language-plaintext highlighter-rouge">List (Id Ã— Type)</code>. For instance, the isomorphism relates the context</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âˆ… , "s" â¦‚ `â„• â‡’ `â„• , "z" â¦‚ `â„•
</code></pre></div></div><p>to the list</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[ âŸ¨ "z" , `â„• âŸ© , âŸ¨ "s" , `â„• â‡’ `â„• âŸ© ]
</code></pre></div></div><pre class="Agda"><a id="32169" class="Comment">-- Your code goes here</a>
</pre><h3 id="lookup-judgment">Lookup judgment</h3><p>We have two forms of <em>judgment</em>. The first is written</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Î“ âˆ‹ x â¦‚ A
</code></pre></div></div><p>and indicates in context <code class="language-plaintext highlighter-rouge">Î“</code> that variable <code class="language-plaintext highlighter-rouge">x</code> has type <code class="language-plaintext highlighter-rouge">A</code>. It is called <em>lookup</em>. For example,</p><ul><li><code class="language-plaintext highlighter-rouge">âˆ… , "s" â¦‚ `â„• â‡’ `â„• , "z" â¦‚ `â„• âˆ‹ "z" â¦‚ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… , "s" â¦‚ `â„• â‡’ `â„• , "z" â¦‚ `â„• âˆ‹ "s" â¦‚ `â„• â‡’ `â„•</code></li></ul><p>give us the types associated with variables <code class="language-plaintext highlighter-rouge">"z"</code> and <code class="language-plaintext highlighter-rouge">"s"</code>, respectively. The symbol <code class="language-plaintext highlighter-rouge">âˆ‹</code> (pronounced â€œniâ€, for â€œinâ€ backwards) is chosen because checking that <code class="language-plaintext highlighter-rouge">Î“ âˆ‹ x â¦‚ A</code> is analogous to checking whether <code class="language-plaintext highlighter-rouge">x â¦‚ A</code> appears in a list corresponding to <code class="language-plaintext highlighter-rouge">Î“</code>.</p><p>If two variables in a context have the same name, then lookup should return the most recently bound variable, which <em>shadows</em> the other variables. For example,</p><ul><li><code class="language-plaintext highlighter-rouge">âˆ… , "x" â¦‚ `â„• â‡’ `â„• , "x" â¦‚ `â„• âˆ‹ "x" â¦‚ `â„•</code>.</li></ul><p>Here <code class="language-plaintext highlighter-rouge">"x" â¦‚ `â„• â‡’ `â„•</code> is shadowed by <code class="language-plaintext highlighter-rouge">"x" â¦‚ `â„•</code>.</p><p>Lookup is formalised as follows:</p><pre class="Agda"><a id="33058" class="Keyword">infix</a>  <a id="33065" class="Number">4</a>  <a id="33068" href="/20.07/Lambda/#33080" class="Datatype Operator">_âˆ‹_â¦‚_</a>

<a id="33075" class="Keyword">data</a> <a id="_âˆ‹_â¦‚_"></a><a id="33080" href="/20.07/Lambda/#33080" class="Datatype Operator">_âˆ‹_â¦‚_</a> <a id="33086" class="Symbol">:</a> <a id="33088" href="/20.07/Lambda/#31846" class="Datatype">Context</a> <a id="33096" class="Symbol">â†’</a> <a id="33098" href="/20.07/Lambda/#3904" class="Function">Id</a> <a id="33101" class="Symbol">â†’</a> <a id="33103" href="/20.07/Lambda/#30188" class="Datatype">Type</a> <a id="33108" class="Symbol">â†’</a> <a id="33110" class="PrimitiveType">Set</a> <a id="33114" class="Keyword">where</a>

  <a id="_âˆ‹_â¦‚_.Z"></a><a id="33123" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a> <a id="33125" class="Symbol">:</a> <a id="33127" class="Symbol">âˆ€</a> <a id="33129" class="Symbol">{</a><a id="33130" href="/20.07/Lambda/#33130" class="Bound">Î“</a> <a id="33132" href="/20.07/Lambda/#33132" class="Bound">x</a> <a id="33134" href="/20.07/Lambda/#33134" class="Bound">A</a><a id="33135" class="Symbol">}</a>
      <a id="33143" class="Comment">------------------</a>
    <a id="33166" class="Symbol">â†’</a> <a id="33168" href="/20.07/Lambda/#33130" class="Bound">Î“</a> <a id="33170" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="33172" href="/20.07/Lambda/#33132" class="Bound">x</a> <a id="33174" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="33176" href="/20.07/Lambda/#33134" class="Bound">A</a> <a id="33178" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="33180" href="/20.07/Lambda/#33132" class="Bound">x</a> <a id="33182" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="33184" href="/20.07/Lambda/#33134" class="Bound">A</a>

  <a id="_âˆ‹_â¦‚_.S"></a><a id="33189" href="/20.07/Lambda/#33189" class="InductiveConstructor">S</a> <a id="33191" class="Symbol">:</a> <a id="33193" class="Symbol">âˆ€</a> <a id="33195" class="Symbol">{</a><a id="33196" href="/20.07/Lambda/#33196" class="Bound">Î“</a> <a id="33198" href="/20.07/Lambda/#33198" class="Bound">x</a> <a id="33200" href="/20.07/Lambda/#33200" class="Bound">y</a> <a id="33202" href="/20.07/Lambda/#33202" class="Bound">A</a> <a id="33204" href="/20.07/Lambda/#33204" class="Bound">B</a><a id="33205" class="Symbol">}</a>
    <a id="33211" class="Symbol">â†’</a> <a id="33213" href="/20.07/Lambda/#33198" class="Bound">x</a> <a id="33215" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#799" class="Function Operator">â‰¢</a> <a id="33217" href="/20.07/Lambda/#33200" class="Bound">y</a>
    <a id="33223" class="Symbol">â†’</a> <a id="33225" href="/20.07/Lambda/#33196" class="Bound">Î“</a> <a id="33227" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="33229" href="/20.07/Lambda/#33198" class="Bound">x</a> <a id="33231" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="33233" href="/20.07/Lambda/#33202" class="Bound">A</a>
      <a id="33241" class="Comment">------------------</a>
    <a id="33264" class="Symbol">â†’</a> <a id="33266" href="/20.07/Lambda/#33196" class="Bound">Î“</a> <a id="33268" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="33270" href="/20.07/Lambda/#33200" class="Bound">y</a> <a id="33272" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="33274" href="/20.07/Lambda/#33204" class="Bound">B</a> <a id="33276" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="33278" href="/20.07/Lambda/#33198" class="Bound">x</a> <a id="33280" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="33282" href="/20.07/Lambda/#33202" class="Bound">A</a>
</pre><p>The constructors <code class="language-plaintext highlighter-rouge">Z</code> and <code class="language-plaintext highlighter-rouge">S</code> correspond roughly to the constructors <code class="language-plaintext highlighter-rouge">here</code> and <code class="language-plaintext highlighter-rouge">there</code> for the element-of relation <code class="language-plaintext highlighter-rouge">_âˆˆ_</code> on lists. Constructor <code class="language-plaintext highlighter-rouge">S</code> takes an additional parameter, which ensures that when we look up a variable that it is not <em>shadowed</em> by another variable with the same name to its left in the list.</p><p>It can be rather tedious to use the <code class="language-plaintext highlighter-rouge">S</code> constructor, as you have to provide proofs that <code class="language-plaintext highlighter-rouge">x â‰¢ y</code> each time. For example:</p><pre class="Agda"><a id="33729" href="/20.07/Lambda/#33729" class="Function">_</a> <a id="33731" class="Symbol">:</a> <a id="33733" href="/20.07/Lambda/#31868" class="InductiveConstructor">âˆ…</a> <a id="33735" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="33737" class="String">&quot;x&quot;</a> <a id="33741" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="33743" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="33746" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="33748" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="33751" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="33753" class="String">&quot;y&quot;</a> <a id="33757" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="33759" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="33762" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="33764" class="String">&quot;z&quot;</a> <a id="33768" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="33770" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="33773" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="33775" class="String">&quot;x&quot;</a> <a id="33779" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="33781" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="33784" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="33786" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>
<a id="33789" class="Symbol">_</a> <a id="33791" class="Symbol">=</a> <a id="33793" href="/20.07/Lambda/#33189" class="InductiveConstructor">S</a> <a id="33795" class="Symbol">(Î»())</a> <a id="33801" class="Symbol">(</a><a id="33802" href="/20.07/Lambda/#33189" class="InductiveConstructor">S</a> <a id="33804" class="Symbol">(Î»())</a> <a id="33810" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a><a id="33811" class="Symbol">)</a>
</pre><p>Instead, weâ€™ll use a â€œsmart constructorâ€, which uses <a href="/20.07/Decidable/#proof-by-reflection">proof by reflection</a> to check the inequality while type checking:</p><pre class="Agda"><a id="Sâ€²"></a><a id="33994" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="33997" class="Symbol">:</a> <a id="33999" class="Symbol">âˆ€</a> <a id="34001" class="Symbol">{</a><a id="34002" href="/20.07/Lambda/#34002" class="Bound">Î“</a> <a id="34004" href="/20.07/Lambda/#34004" class="Bound">x</a> <a id="34006" href="/20.07/Lambda/#34006" class="Bound">y</a> <a id="34008" href="/20.07/Lambda/#34008" class="Bound">A</a> <a id="34010" href="/20.07/Lambda/#34010" class="Bound">B</a><a id="34011" class="Symbol">}</a>
   <a id="34016" class="Symbol">â†’</a> <a id="34018" class="Symbol">{</a><a id="34019" href="/20.07/Lambda/#34019" class="Bound">xâ‰¢y</a> <a id="34023" class="Symbol">:</a> <a id="34025" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.Decidable.Core.html#845" class="Function">False</a> <a id="34031" class="Symbol">(</a><a id="34032" href="/20.07/Lambda/#34004" class="Bound">x</a> <a id="34034" href="https://agda.github.io/agda-stdlib/v1.1/Data.String.Properties.html#2569" class="Function Operator">â‰Ÿ</a> <a id="34036" href="/20.07/Lambda/#34006" class="Bound">y</a><a id="34037" class="Symbol">)}</a>
   <a id="34043" class="Symbol">â†’</a> <a id="34045" href="/20.07/Lambda/#34002" class="Bound">Î“</a> <a id="34047" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="34049" href="/20.07/Lambda/#34004" class="Bound">x</a> <a id="34051" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="34053" href="/20.07/Lambda/#34008" class="Bound">A</a>
     <a id="34060" class="Comment">------------------</a>
   <a id="34082" class="Symbol">â†’</a> <a id="34084" href="/20.07/Lambda/#34002" class="Bound">Î“</a> <a id="34086" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="34088" href="/20.07/Lambda/#34006" class="Bound">y</a> <a id="34090" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="34092" href="/20.07/Lambda/#34010" class="Bound">B</a> <a id="34094" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="34096" href="/20.07/Lambda/#34004" class="Bound">x</a> <a id="34098" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="34100" href="/20.07/Lambda/#34008" class="Bound">A</a>

<a id="34103" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="34106" class="Symbol">{</a><a id="34107" class="Argument">xâ‰¢y</a> <a id="34111" class="Symbol">=</a> <a id="34113" href="/20.07/Lambda/#34113" class="Bound">xâ‰¢y</a><a id="34116" class="Symbol">}</a> <a id="34118" href="/20.07/Lambda/#34118" class="Bound">x</a> <a id="34120" class="Symbol">=</a> <a id="34122" href="/20.07/Lambda/#33189" class="InductiveConstructor">S</a> <a id="34124" class="Symbol">(</a><a id="34125" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.Decidable.Core.html#1189" class="Function">toWitnessFalse</a> <a id="34140" href="/20.07/Lambda/#34113" class="Bound">xâ‰¢y</a><a id="34143" class="Symbol">)</a> <a id="34145" href="/20.07/Lambda/#34118" class="Bound">x</a>
</pre><h3 id="typing-judgment">Typing judgment</h3><p>The second judgment is written</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Î“ âŠ¢ M â¦‚ A
</code></pre></div></div><p>and indicates in context <code class="language-plaintext highlighter-rouge">Î“</code> that term <code class="language-plaintext highlighter-rouge">M</code> has type <code class="language-plaintext highlighter-rouge">A</code>. Context <code class="language-plaintext highlighter-rouge">Î“</code> provides types for all the free variables in <code class="language-plaintext highlighter-rouge">M</code>. For example:</p><ul><li><code class="language-plaintext highlighter-rouge">âˆ… , "s" â¦‚ `â„• â‡’ `â„• , "z" â¦‚ `â„• âŠ¢ ` "z" â¦‚ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… , "s" â¦‚ `â„• â‡’ `â„• , "z" â¦‚ `â„• âŠ¢ ` "s" â¦‚ `â„• â‡’ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… , "s" â¦‚ `â„• â‡’ `â„• , "z" â¦‚ `â„• âŠ¢ ` "s" Â· ` "z" â¦‚ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… , "s" â¦‚ `â„• â‡’ `â„• , "z" â¦‚ `â„• âŠ¢ ` "s" Â· (` "s" Â· ` "z") â¦‚ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… , "s" â¦‚ `â„• â‡’ `â„• âŠ¢ Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z") â¦‚ `â„• â‡’ `â„•</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… âŠ¢ Æ› "s" â‡’ Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z") â¦‚ (`â„• â‡’ `â„•) â‡’ `â„• â‡’ `â„•</code></li></ul><p>Typing is formalised as follows:</p><pre class="Agda"><a id="34770" class="Keyword">infix</a>  <a id="34777" class="Number">4</a>  <a id="34780" href="/20.07/Lambda/#34792" class="Datatype Operator">_âŠ¢_â¦‚_</a>

<a id="34787" class="Keyword">data</a> <a id="_âŠ¢_â¦‚_"></a><a id="34792" href="/20.07/Lambda/#34792" class="Datatype Operator">_âŠ¢_â¦‚_</a> <a id="34798" class="Symbol">:</a> <a id="34800" href="/20.07/Lambda/#31846" class="Datatype">Context</a> <a id="34808" class="Symbol">â†’</a> <a id="34810" href="/20.07/Lambda/#4005" class="Datatype">Term</a> <a id="34815" class="Symbol">â†’</a> <a id="34817" href="/20.07/Lambda/#30188" class="Datatype">Type</a> <a id="34822" class="Symbol">â†’</a> <a id="34824" class="PrimitiveType">Set</a> <a id="34828" class="Keyword">where</a>

  <a id="34837" class="Comment">-- Axiom</a>
  <a id="_âŠ¢_â¦‚_.âŠ¢`"></a><a id="34848" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="34851" class="Symbol">:</a> <a id="34853" class="Symbol">âˆ€</a> <a id="34855" class="Symbol">{</a><a id="34856" href="/20.07/Lambda/#34856" class="Bound">Î“</a> <a id="34858" href="/20.07/Lambda/#34858" class="Bound">x</a> <a id="34860" href="/20.07/Lambda/#34860" class="Bound">A</a><a id="34861" class="Symbol">}</a>
    <a id="34867" class="Symbol">â†’</a> <a id="34869" href="/20.07/Lambda/#34856" class="Bound">Î“</a> <a id="34871" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="34873" href="/20.07/Lambda/#34858" class="Bound">x</a> <a id="34875" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="34877" href="/20.07/Lambda/#34860" class="Bound">A</a>
      <a id="34885" class="Comment">-----------</a>
    <a id="34901" class="Symbol">â†’</a> <a id="34903" href="/20.07/Lambda/#34856" class="Bound">Î“</a> <a id="34905" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="34907" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="34909" href="/20.07/Lambda/#34858" class="Bound">x</a> <a id="34911" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="34913" href="/20.07/Lambda/#34860" class="Bound">A</a>

  <a id="34918" class="Comment">-- â‡’-I</a>
  <a id="_âŠ¢_â¦‚_.âŠ¢Æ›"></a><a id="34927" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="34930" class="Symbol">:</a> <a id="34932" class="Symbol">âˆ€</a> <a id="34934" class="Symbol">{</a><a id="34935" href="/20.07/Lambda/#34935" class="Bound">Î“</a> <a id="34937" href="/20.07/Lambda/#34937" class="Bound">x</a> <a id="34939" href="/20.07/Lambda/#34939" class="Bound">N</a> <a id="34941" href="/20.07/Lambda/#34941" class="Bound">A</a> <a id="34943" href="/20.07/Lambda/#34943" class="Bound">B</a><a id="34944" class="Symbol">}</a>
    <a id="34950" class="Symbol">â†’</a> <a id="34952" href="/20.07/Lambda/#34935" class="Bound">Î“</a> <a id="34954" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="34956" href="/20.07/Lambda/#34937" class="Bound">x</a> <a id="34958" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="34960" href="/20.07/Lambda/#34941" class="Bound">A</a> <a id="34962" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="34964" href="/20.07/Lambda/#34939" class="Bound">N</a> <a id="34966" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="34968" href="/20.07/Lambda/#34943" class="Bound">B</a>
      <a id="34976" class="Comment">-------------------</a>
    <a id="35000" class="Symbol">â†’</a> <a id="35002" href="/20.07/Lambda/#34935" class="Bound">Î“</a> <a id="35004" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35006" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="35008" href="/20.07/Lambda/#34937" class="Bound">x</a> <a id="35010" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="35012" href="/20.07/Lambda/#34939" class="Bound">N</a> <a id="35014" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35016" href="/20.07/Lambda/#34941" class="Bound">A</a> <a id="35018" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="35020" href="/20.07/Lambda/#34943" class="Bound">B</a>

  <a id="35025" class="Comment">-- â‡’-E</a>
  <a id="_âŠ¢_â¦‚_._Â·_"></a><a id="35034" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">_Â·_</a> <a id="35038" class="Symbol">:</a> <a id="35040" class="Symbol">âˆ€</a> <a id="35042" class="Symbol">{</a><a id="35043" href="/20.07/Lambda/#35043" class="Bound">Î“</a> <a id="35045" href="/20.07/Lambda/#35045" class="Bound">L</a> <a id="35047" href="/20.07/Lambda/#35047" class="Bound">M</a> <a id="35049" href="/20.07/Lambda/#35049" class="Bound">A</a> <a id="35051" href="/20.07/Lambda/#35051" class="Bound">B</a><a id="35052" class="Symbol">}</a>
    <a id="35058" class="Symbol">â†’</a> <a id="35060" href="/20.07/Lambda/#35043" class="Bound">Î“</a> <a id="35062" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35064" href="/20.07/Lambda/#35045" class="Bound">L</a> <a id="35066" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35068" href="/20.07/Lambda/#35049" class="Bound">A</a> <a id="35070" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="35072" href="/20.07/Lambda/#35051" class="Bound">B</a>
    <a id="35078" class="Symbol">â†’</a> <a id="35080" href="/20.07/Lambda/#35043" class="Bound">Î“</a> <a id="35082" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35084" href="/20.07/Lambda/#35047" class="Bound">M</a> <a id="35086" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35088" href="/20.07/Lambda/#35049" class="Bound">A</a>
      <a id="35096" class="Comment">-------------</a>
    <a id="35114" class="Symbol">â†’</a> <a id="35116" href="/20.07/Lambda/#35043" class="Bound">Î“</a> <a id="35118" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35120" href="/20.07/Lambda/#35045" class="Bound">L</a> <a id="35122" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="35124" href="/20.07/Lambda/#35047" class="Bound">M</a> <a id="35126" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35128" href="/20.07/Lambda/#35051" class="Bound">B</a>

  <a id="35133" class="Comment">-- â„•-Iâ‚</a>
  <a id="_âŠ¢_â¦‚_.âŠ¢zero"></a><a id="35143" href="/20.07/Lambda/#35143" class="InductiveConstructor">âŠ¢zero</a> <a id="35149" class="Symbol">:</a> <a id="35151" class="Symbol">âˆ€</a> <a id="35153" class="Symbol">{</a><a id="35154" href="/20.07/Lambda/#35154" class="Bound">Î“</a><a id="35155" class="Symbol">}</a>
      <a id="35163" class="Comment">--------------</a>
    <a id="35182" class="Symbol">â†’</a> <a id="35184" href="/20.07/Lambda/#35154" class="Bound">Î“</a> <a id="35186" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35188" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="35194" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35196" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>

  <a id="35202" class="Comment">-- â„•-Iâ‚‚</a>
  <a id="_âŠ¢_â¦‚_.âŠ¢suc"></a><a id="35212" href="/20.07/Lambda/#35212" class="InductiveConstructor">âŠ¢suc</a> <a id="35217" class="Symbol">:</a> <a id="35219" class="Symbol">âˆ€</a> <a id="35221" class="Symbol">{</a><a id="35222" href="/20.07/Lambda/#35222" class="Bound">Î“</a> <a id="35224" href="/20.07/Lambda/#35224" class="Bound">M</a><a id="35225" class="Symbol">}</a>
    <a id="35231" class="Symbol">â†’</a> <a id="35233" href="/20.07/Lambda/#35222" class="Bound">Î“</a> <a id="35235" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35237" href="/20.07/Lambda/#35224" class="Bound">M</a> <a id="35239" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35241" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>
      <a id="35250" class="Comment">---------------</a>
    <a id="35270" class="Symbol">â†’</a> <a id="35272" href="/20.07/Lambda/#35222" class="Bound">Î“</a> <a id="35274" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35276" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="35281" href="/20.07/Lambda/#35224" class="Bound">M</a> <a id="35283" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35285" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>

  <a id="35291" class="Comment">-- â„•-E</a>
  <a id="_âŠ¢_â¦‚_.âŠ¢case"></a><a id="35300" href="/20.07/Lambda/#35300" class="InductiveConstructor">âŠ¢case</a> <a id="35306" class="Symbol">:</a> <a id="35308" class="Symbol">âˆ€</a> <a id="35310" class="Symbol">{</a><a id="35311" href="/20.07/Lambda/#35311" class="Bound">Î“</a> <a id="35313" href="/20.07/Lambda/#35313" class="Bound">L</a> <a id="35315" href="/20.07/Lambda/#35315" class="Bound">M</a> <a id="35317" href="/20.07/Lambda/#35317" class="Bound">x</a> <a id="35319" href="/20.07/Lambda/#35319" class="Bound">N</a> <a id="35321" href="/20.07/Lambda/#35321" class="Bound">A</a><a id="35322" class="Symbol">}</a>
    <a id="35328" class="Symbol">â†’</a> <a id="35330" href="/20.07/Lambda/#35311" class="Bound">Î“</a> <a id="35332" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35334" href="/20.07/Lambda/#35313" class="Bound">L</a> <a id="35336" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35338" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>
    <a id="35345" class="Symbol">â†’</a> <a id="35347" href="/20.07/Lambda/#35311" class="Bound">Î“</a> <a id="35349" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35351" href="/20.07/Lambda/#35315" class="Bound">M</a> <a id="35353" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35355" href="/20.07/Lambda/#35321" class="Bound">A</a>
    <a id="35361" class="Symbol">â†’</a> <a id="35363" href="/20.07/Lambda/#35311" class="Bound">Î“</a> <a id="35365" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="35367" href="/20.07/Lambda/#35317" class="Bound">x</a> <a id="35369" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="35371" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="35374" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35376" href="/20.07/Lambda/#35319" class="Bound">N</a> <a id="35378" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35380" href="/20.07/Lambda/#35321" class="Bound">A</a>
      <a id="35388" class="Comment">-------------------------------------</a>
    <a id="35430" class="Symbol">â†’</a> <a id="35432" href="/20.07/Lambda/#35311" class="Bound">Î“</a> <a id="35434" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35436" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">case</a> <a id="35441" href="/20.07/Lambda/#35313" class="Bound">L</a> <a id="35443" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">[zeroâ‡’</a> <a id="35450" href="/20.07/Lambda/#35315" class="Bound">M</a> <a id="35452" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">|suc</a> <a id="35457" href="/20.07/Lambda/#35317" class="Bound">x</a> <a id="35459" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">â‡’</a> <a id="35461" href="/20.07/Lambda/#35319" class="Bound">N</a> <a id="35463" href="/20.07/Lambda/#4232" class="InductiveConstructor Operator">]</a> <a id="35465" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35467" href="/20.07/Lambda/#35321" class="Bound">A</a>

  <a id="_âŠ¢_â¦‚_.âŠ¢Î¼"></a><a id="35472" href="/20.07/Lambda/#35472" class="InductiveConstructor">âŠ¢Î¼</a> <a id="35475" class="Symbol">:</a> <a id="35477" class="Symbol">âˆ€</a> <a id="35479" class="Symbol">{</a><a id="35480" href="/20.07/Lambda/#35480" class="Bound">Î“</a> <a id="35482" href="/20.07/Lambda/#35482" class="Bound">x</a> <a id="35484" href="/20.07/Lambda/#35484" class="Bound">M</a> <a id="35486" href="/20.07/Lambda/#35486" class="Bound">A</a><a id="35487" class="Symbol">}</a>
    <a id="35493" class="Symbol">â†’</a> <a id="35495" href="/20.07/Lambda/#35480" class="Bound">Î“</a> <a id="35497" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">,</a> <a id="35499" href="/20.07/Lambda/#35482" class="Bound">x</a> <a id="35501" href="/20.07/Lambda/#31886" class="InductiveConstructor Operator">â¦‚</a> <a id="35503" href="/20.07/Lambda/#35486" class="Bound">A</a> <a id="35505" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35507" href="/20.07/Lambda/#35484" class="Bound">M</a> <a id="35509" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35511" href="/20.07/Lambda/#35486" class="Bound">A</a>
      <a id="35519" class="Comment">-----------------</a>
    <a id="35541" class="Symbol">â†’</a> <a id="35543" href="/20.07/Lambda/#35480" class="Bound">Î“</a> <a id="35545" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="35547" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">Î¼</a> <a id="35549" href="/20.07/Lambda/#35482" class="Bound">x</a> <a id="35551" href="/20.07/Lambda/#4292" class="InductiveConstructor Operator">â‡’</a> <a id="35553" href="/20.07/Lambda/#35484" class="Bound">M</a> <a id="35555" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="35557" href="/20.07/Lambda/#35486" class="Bound">A</a>
</pre><p>Each type rule is named after the constructor for the corresponding term.</p><p>Most of the rules have a second name, derived from a convention in logic, whereby the rule is named after the type connective that it concerns; rules to introduce and to eliminate each connective are labeled <code class="language-plaintext highlighter-rouge">-I</code> and <code class="language-plaintext highlighter-rouge">-E</code>, respectively. As we read the rules from top to bottom, introduction and elimination rules do what they say on the tin: the first <em>introduces</em> a formula for the connective, which appears in the conclusion but not in the premises; while the second <em>eliminates</em> a formula for the connective, which appears in a premise but not in the conclusion. An introduction rule describes how to construct a value of the type (abstractions yield functions, successor and zero yield naturals), while an elimination rule describes how to deconstruct a value of the given type (applications use functions, case expressions use naturals).</p><p>Note also the three places (in <code class="language-plaintext highlighter-rouge">âŠ¢Æ›</code>, <code class="language-plaintext highlighter-rouge">âŠ¢case</code>, and <code class="language-plaintext highlighter-rouge">âŠ¢Î¼</code>) where the context is extended with <code class="language-plaintext highlighter-rouge">x</code> and an appropriate type, corresponding to the three places where a bound variable is introduced.</p><p>The rules are deterministic, in that at most one rule applies to every term.</p><h3 id="derivation">Example type derivations</h3><p>Type derivations correspond to trees. In informal notation, here is a type derivation for the Church numeral two,</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                        âˆ‹s                     âˆ‹z
                        ------------------ âŠ¢`  -------------- âŠ¢`
âˆ‹s                      Î“â‚‚ âŠ¢ ` "s" â¦‚ A â‡’ A     Î“â‚‚ âŠ¢ ` "z" â¦‚ A
------------------ âŠ¢`   ------------------------------------- _Â·_
Î“â‚‚ âŠ¢ ` "s" â¦‚ A â‡’ A      Î“â‚‚ âŠ¢ ` "s" Â· ` "z" â¦‚ A
---------------------------------------------- _Â·_
Î“â‚‚ âŠ¢ ` "s" Â· (` "s" Â· ` "z") â¦‚ A
-------------------------------------------- âŠ¢Æ›
Î“â‚ âŠ¢ Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z") â¦‚ A â‡’ A
------------------------------------------------------------- âŠ¢Æ›
Î“ âŠ¢ Æ› "s" â‡’ Æ› "z" â‡’ ` "s" Â· (` "s" Â· ` "z") â¦‚ (A â‡’ A) â‡’ A â‡’ A
</code></pre></div></div><p>where <code class="language-plaintext highlighter-rouge">âˆ‹s</code> and <code class="language-plaintext highlighter-rouge">âˆ‹z</code> abbreviate the two derivations,</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>             ---------------- Z
"s" â‰¢ "z"    Î“â‚ âˆ‹ "s" â¦‚ A â‡’ A
----------------------------- S       ------------- Z
Î“â‚‚ âˆ‹ "s" â¦‚ A â‡’ A                       Î“â‚‚ âˆ‹ "z" â¦‚ A
</code></pre></div></div><p>and where <code class="language-plaintext highlighter-rouge">Î“â‚ = Î“ , "s" â¦‚ A â‡’ A</code> and <code class="language-plaintext highlighter-rouge">Î“â‚‚ = Î“ , "s" â¦‚ A â‡’ A , "z" â¦‚ A</code>. The typing derivation is valid for any <code class="language-plaintext highlighter-rouge">Î“</code> and <code class="language-plaintext highlighter-rouge">A</code>, for instance, we might take <code class="language-plaintext highlighter-rouge">Î“</code> to be <code class="language-plaintext highlighter-rouge">âˆ…</code> and <code class="language-plaintext highlighter-rouge">A</code> to be <code class="language-plaintext highlighter-rouge">`â„•</code>.</p><p>Here is the above typing derivation formalised in Agda:</p><pre class="Agda"><a id="Ch"></a><a id="38041" href="/20.07/Lambda/#38041" class="Function">Ch</a> <a id="38044" class="Symbol">:</a> <a id="38046" href="/20.07/Lambda/#30188" class="Datatype">Type</a> <a id="38051" class="Symbol">â†’</a> <a id="38053" href="/20.07/Lambda/#30188" class="Datatype">Type</a>
<a id="38058" href="/20.07/Lambda/#38041" class="Function">Ch</a> <a id="38061" href="/20.07/Lambda/#38061" class="Bound">A</a> <a id="38063" class="Symbol">=</a> <a id="38065" class="Symbol">(</a><a id="38066" href="/20.07/Lambda/#38061" class="Bound">A</a> <a id="38068" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="38070" href="/20.07/Lambda/#38061" class="Bound">A</a><a id="38071" class="Symbol">)</a> <a id="38073" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="38075" href="/20.07/Lambda/#38061" class="Bound">A</a> <a id="38077" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="38079" href="/20.07/Lambda/#38061" class="Bound">A</a>

<a id="âŠ¢twoá¶œ"></a><a id="38082" href="/20.07/Lambda/#38082" class="Function">âŠ¢twoá¶œ</a> <a id="38088" class="Symbol">:</a> <a id="38090" class="Symbol">âˆ€</a> <a id="38092" class="Symbol">{</a><a id="38093" href="/20.07/Lambda/#38093" class="Bound">Î“</a> <a id="38095" href="/20.07/Lambda/#38095" class="Bound">A</a><a id="38096" class="Symbol">}</a> <a id="38098" class="Symbol">â†’</a> <a id="38100" href="/20.07/Lambda/#38093" class="Bound">Î“</a> <a id="38102" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="38104" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="38109" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="38111" href="/20.07/Lambda/#38041" class="Function">Ch</a> <a id="38114" href="/20.07/Lambda/#38095" class="Bound">A</a>
<a id="38116" href="/20.07/Lambda/#38082" class="Function">âŠ¢twoá¶œ</a> <a id="38122" class="Symbol">=</a> <a id="38124" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="38127" class="Symbol">(</a><a id="38128" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="38131" class="Symbol">(</a><a id="38132" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="38135" href="/20.07/Lambda/#38168" class="Function">âˆ‹s</a> <a id="38138" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="38140" class="Symbol">(</a><a id="38141" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="38144" href="/20.07/Lambda/#38168" class="Function">âˆ‹s</a> <a id="38147" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="38149" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="38152" href="/20.07/Lambda/#38180" class="Function">âˆ‹z</a><a id="38154" class="Symbol">)))</a>
  <a id="38160" class="Keyword">where</a>
  <a id="38168" href="/20.07/Lambda/#38168" class="Function">âˆ‹s</a> <a id="38171" class="Symbol">=</a> <a id="38173" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="38176" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>
  <a id="38180" href="/20.07/Lambda/#38180" class="Function">âˆ‹z</a> <a id="38183" class="Symbol">=</a> <a id="38185" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>
</pre><p>Here are the typings corresponding to computing two plus two:</p><pre class="Agda"><a id="âŠ¢two"></a><a id="38258" href="/20.07/Lambda/#38258" class="Function">âŠ¢two</a> <a id="38263" class="Symbol">:</a> <a id="38265" class="Symbol">âˆ€</a> <a id="38267" class="Symbol">{</a><a id="38268" href="/20.07/Lambda/#38268" class="Bound">Î“</a><a id="38269" class="Symbol">}</a> <a id="38271" class="Symbol">â†’</a> <a id="38273" href="/20.07/Lambda/#38268" class="Bound">Î“</a> <a id="38275" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="38277" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="38281" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="38283" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>
<a id="38286" href="/20.07/Lambda/#38258" class="Function">âŠ¢two</a> <a id="38291" class="Symbol">=</a> <a id="38293" href="/20.07/Lambda/#35212" class="InductiveConstructor">âŠ¢suc</a> <a id="38298" class="Symbol">(</a><a id="38299" href="/20.07/Lambda/#35212" class="InductiveConstructor">âŠ¢suc</a> <a id="38304" href="/20.07/Lambda/#35143" class="InductiveConstructor">âŠ¢zero</a><a id="38309" class="Symbol">)</a>

<a id="âŠ¢plus"></a><a id="38312" href="/20.07/Lambda/#38312" class="Function">âŠ¢plus</a> <a id="38318" class="Symbol">:</a> <a id="38320" class="Symbol">âˆ€</a> <a id="38322" class="Symbol">{</a><a id="38323" href="/20.07/Lambda/#38323" class="Bound">Î“</a><a id="38324" class="Symbol">}</a> <a id="38326" class="Symbol">â†’</a> <a id="38328" href="/20.07/Lambda/#38323" class="Bound">Î“</a> <a id="38330" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="38332" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="38337" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="38339" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="38342" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="38344" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="38347" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="38349" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>
<a id="38352" href="/20.07/Lambda/#38312" class="Function">âŠ¢plus</a> <a id="38358" class="Symbol">=</a> <a id="38360" href="/20.07/Lambda/#35472" class="InductiveConstructor">âŠ¢Î¼</a> <a id="38363" class="Symbol">(</a><a id="38364" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="38367" class="Symbol">(</a><a id="38368" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="38371" class="Symbol">(</a><a id="38372" href="/20.07/Lambda/#35300" class="InductiveConstructor">âŠ¢case</a> <a id="38378" class="Symbol">(</a><a id="38379" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="38382" href="/20.07/Lambda/#38472" class="Function">âˆ‹m</a><a id="38384" class="Symbol">)</a> <a id="38386" class="Symbol">(</a><a id="38387" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="38390" href="/20.07/Lambda/#38485" class="Function">âˆ‹n</a><a id="38392" class="Symbol">)</a>
         <a id="38403" class="Symbol">(</a><a id="38404" href="/20.07/Lambda/#35212" class="InductiveConstructor">âŠ¢suc</a> <a id="38409" class="Symbol">(</a><a id="38410" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="38413" href="/20.07/Lambda/#38449" class="Function">âˆ‹+</a> <a id="38416" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="38418" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="38421" href="/20.07/Lambda/#38495" class="Function">âˆ‹mâ€²</a> <a id="38425" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="38427" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="38430" href="/20.07/Lambda/#38505" class="Function">âˆ‹nâ€²</a><a id="38433" class="Symbol">)))))</a>
  <a id="38441" class="Keyword">where</a>
  <a id="38449" href="/20.07/Lambda/#38449" class="Function">âˆ‹+</a>  <a id="38453" class="Symbol">=</a> <a id="38455" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="38458" class="Symbol">(</a><a id="38459" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="38462" class="Symbol">(</a><a id="38463" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="38466" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a><a id="38467" class="Symbol">))</a>
  <a id="38472" href="/20.07/Lambda/#38472" class="Function">âˆ‹m</a>  <a id="38476" class="Symbol">=</a> <a id="38478" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="38481" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>
  <a id="38485" href="/20.07/Lambda/#38485" class="Function">âˆ‹n</a>  <a id="38489" class="Symbol">=</a> <a id="38491" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>
  <a id="38495" href="/20.07/Lambda/#38495" class="Function">âˆ‹mâ€²</a> <a id="38499" class="Symbol">=</a> <a id="38501" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>
  <a id="38505" href="/20.07/Lambda/#38505" class="Function">âˆ‹nâ€²</a> <a id="38509" class="Symbol">=</a> <a id="38511" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="38514" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>

<a id="âŠ¢2+2"></a><a id="38517" href="/20.07/Lambda/#38517" class="Function">âŠ¢2+2</a> <a id="38522" class="Symbol">:</a> <a id="38524" href="/20.07/Lambda/#31868" class="InductiveConstructor">âˆ…</a> <a id="38526" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="38528" href="/20.07/Lambda/#4767" class="Function">plus</a> <a id="38533" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="38535" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="38539" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="38541" href="/20.07/Lambda/#4733" class="Function">two</a> <a id="38545" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="38547" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>
<a id="38550" href="/20.07/Lambda/#38517" class="Function">âŠ¢2+2</a> <a id="38555" class="Symbol">=</a> <a id="38557" href="/20.07/Lambda/#38312" class="Function">âŠ¢plus</a> <a id="38563" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="38565" href="/20.07/Lambda/#38258" class="Function">âŠ¢two</a> <a id="38570" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="38572" href="/20.07/Lambda/#38258" class="Function">âŠ¢two</a>
</pre><p>In contrast to our earlier examples, here we have typed <code class="language-plaintext highlighter-rouge">two</code> and <code class="language-plaintext highlighter-rouge">plus</code> in an arbitrary context rather than the empty context; this makes it easy to use them inside other binding contexts as well as at the top level. Here the two lookup judgments <code class="language-plaintext highlighter-rouge">âˆ‹m</code> and <code class="language-plaintext highlighter-rouge">âˆ‹mâ€²</code> refer to two different bindings of variables named <code class="language-plaintext highlighter-rouge">"m"</code>. In contrast, the two judgments <code class="language-plaintext highlighter-rouge">âˆ‹n</code> and <code class="language-plaintext highlighter-rouge">âˆ‹nâ€²</code> both refer to the same binding of <code class="language-plaintext highlighter-rouge">"n"</code> but accessed in different contexts, the first where <code class="language-plaintext highlighter-rouge">"n"</code> is the last binding in the context, and the second after <code class="language-plaintext highlighter-rouge">"m"</code> is bound in the successor branch of the case.</p><p>And here are typings for the remainder of the Church example:</p><pre class="Agda"><a id="âŠ¢plusá¶œ"></a><a id="39223" href="/20.07/Lambda/#39223" class="Function">âŠ¢plusá¶œ</a> <a id="39230" class="Symbol">:</a> <a id="39232" class="Symbol">âˆ€</a> <a id="39234" class="Symbol">{</a><a id="39235" href="/20.07/Lambda/#39235" class="Bound">Î“</a> <a id="39237" href="/20.07/Lambda/#39237" class="Bound">A</a><a id="39238" class="Symbol">}</a> <a id="39240" class="Symbol">â†’</a> <a id="39242" href="/20.07/Lambda/#39235" class="Bound">Î“</a>  <a id="39245" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="39247" href="/20.07/Lambda/#6043" class="Function">plusá¶œ</a> <a id="39253" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="39255" href="/20.07/Lambda/#38041" class="Function">Ch</a> <a id="39258" href="/20.07/Lambda/#39237" class="Bound">A</a> <a id="39260" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="39262" href="/20.07/Lambda/#38041" class="Function">Ch</a> <a id="39265" href="/20.07/Lambda/#39237" class="Bound">A</a> <a id="39267" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="39269" href="/20.07/Lambda/#38041" class="Function">Ch</a> <a id="39272" href="/20.07/Lambda/#39237" class="Bound">A</a>
<a id="39274" href="/20.07/Lambda/#39223" class="Function">âŠ¢plusá¶œ</a> <a id="39281" class="Symbol">=</a> <a id="39283" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="39286" class="Symbol">(</a><a id="39287" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="39290" class="Symbol">(</a><a id="39291" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="39294" class="Symbol">(</a><a id="39295" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="39298" class="Symbol">(</a><a id="39299" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="39302" href="/20.07/Lambda/#39353" class="Function">âˆ‹m</a> <a id="39305" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="39307" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="39310" href="/20.07/Lambda/#39392" class="Function">âˆ‹s</a> <a id="39313" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="39315" class="Symbol">(</a><a id="39316" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="39319" href="/20.07/Lambda/#39375" class="Function">âˆ‹n</a> <a id="39322" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="39324" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="39327" href="/20.07/Lambda/#39392" class="Function">âˆ‹s</a> <a id="39330" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="39332" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="39335" href="/20.07/Lambda/#39404" class="Function">âˆ‹z</a><a id="39337" class="Symbol">)))))</a>
  <a id="39345" class="Keyword">where</a>
  <a id="39353" href="/20.07/Lambda/#39353" class="Function">âˆ‹m</a> <a id="39356" class="Symbol">=</a> <a id="39358" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="39361" class="Symbol">(</a><a id="39362" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="39365" class="Symbol">(</a><a id="39366" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="39369" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a><a id="39370" class="Symbol">))</a>
  <a id="39375" href="/20.07/Lambda/#39375" class="Function">âˆ‹n</a> <a id="39378" class="Symbol">=</a> <a id="39380" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="39383" class="Symbol">(</a><a id="39384" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="39387" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a><a id="39388" class="Symbol">)</a>
  <a id="39392" href="/20.07/Lambda/#39392" class="Function">âˆ‹s</a> <a id="39395" class="Symbol">=</a> <a id="39397" href="/20.07/Lambda/#33994" class="Function">Sâ€²</a> <a id="39400" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>
  <a id="39404" href="/20.07/Lambda/#39404" class="Function">âˆ‹z</a> <a id="39407" class="Symbol">=</a> <a id="39409" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>

<a id="âŠ¢sucá¶œ"></a><a id="39412" href="/20.07/Lambda/#39412" class="Function">âŠ¢sucá¶œ</a> <a id="39418" class="Symbol">:</a> <a id="39420" class="Symbol">âˆ€</a> <a id="39422" class="Symbol">{</a><a id="39423" href="/20.07/Lambda/#39423" class="Bound">Î“</a><a id="39424" class="Symbol">}</a> <a id="39426" class="Symbol">â†’</a> <a id="39428" href="/20.07/Lambda/#39423" class="Bound">Î“</a> <a id="39430" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="39432" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="39437" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="39439" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a> <a id="39442" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="39444" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>
<a id="39447" href="/20.07/Lambda/#39412" class="Function">âŠ¢sucá¶œ</a> <a id="39453" class="Symbol">=</a> <a id="39455" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="39458" class="Symbol">(</a><a id="39459" href="/20.07/Lambda/#35212" class="InductiveConstructor">âŠ¢suc</a> <a id="39464" class="Symbol">(</a><a id="39465" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="39468" href="/20.07/Lambda/#39483" class="Function">âˆ‹n</a><a id="39470" class="Symbol">))</a>
  <a id="39475" class="Keyword">where</a>
  <a id="39483" href="/20.07/Lambda/#39483" class="Function">âˆ‹n</a> <a id="39486" class="Symbol">=</a> <a id="39488" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>

<a id="âŠ¢2+2á¶œ"></a><a id="39491" href="/20.07/Lambda/#39491" class="Function">âŠ¢2+2á¶œ</a> <a id="39497" class="Symbol">:</a> <a id="39499" href="/20.07/Lambda/#31868" class="InductiveConstructor">âˆ…</a> <a id="39501" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="39503" href="/20.07/Lambda/#6043" class="Function">plusá¶œ</a> <a id="39509" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="39511" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="39516" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="39518" href="/20.07/Lambda/#5982" class="Function">twoá¶œ</a> <a id="39523" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="39525" href="/20.07/Lambda/#6147" class="Function">sucá¶œ</a> <a id="39530" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="39532" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="39538" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="39540" href="/20.07/Lambda/#30234" class="InductiveConstructor">`â„•</a>
<a id="39543" href="/20.07/Lambda/#39491" class="Function">âŠ¢2+2á¶œ</a> <a id="39549" class="Symbol">=</a> <a id="39551" href="/20.07/Lambda/#39223" class="Function">âŠ¢plusá¶œ</a> <a id="39558" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="39560" href="/20.07/Lambda/#38082" class="Function">âŠ¢twoá¶œ</a> <a id="39566" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="39568" href="/20.07/Lambda/#38082" class="Function">âŠ¢twoá¶œ</a> <a id="39574" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="39576" href="/20.07/Lambda/#39412" class="Function">âŠ¢sucá¶œ</a> <a id="39582" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="39584" href="/20.07/Lambda/#35143" class="InductiveConstructor">âŠ¢zero</a>
</pre><h3 id="interaction-with-agda">Interaction with Agda</h3><p>Construction of a type derivation may be done interactively. Start with the declaration:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âŠ¢sucá¶œ : âˆ… âŠ¢ sucá¶œ â¦‚ `â„• â‡’ `â„•
âŠ¢sucá¶œ = ?
</code></pre></div></div><p>Typing C-c C-l causes Agda to create a hole and tell us its expected type:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âŠ¢sucá¶œ = { }0
?0 : âˆ… âŠ¢ sucá¶œ â¦‚ `â„• â‡’ `â„•
</code></pre></div></div><p>Now we fill in the hole by typing C-c C-r. Agda observes that the outermost term in <code class="language-plaintext highlighter-rouge">sucá¶œ</code> is <code class="language-plaintext highlighter-rouge">Æ›</code>, which is typed using <code class="language-plaintext highlighter-rouge">âŠ¢Æ›</code>. The <code class="language-plaintext highlighter-rouge">âŠ¢Æ›</code> rule in turn takes one argument, which Agda leaves as a hole:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âŠ¢sucá¶œ = âŠ¢Æ› { }1
?1 : âˆ… , "n" â¦‚ `â„• âŠ¢ `suc ` "n" â¦‚ `â„•
</code></pre></div></div><p>We can fill in the hole by typing C-c C-r again:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âŠ¢sucá¶œ = âŠ¢Æ› (âŠ¢suc { }2)
?2 : âˆ… , "n" â¦‚ `â„• âŠ¢ ` "n" â¦‚ `â„•
</code></pre></div></div><p>And again:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âŠ¢sucâ€² = âŠ¢Æ› (âŠ¢suc (âŠ¢` { }3))
?3 : âˆ… , "n" â¦‚ `â„• âˆ‹ "n" â¦‚ `â„•
</code></pre></div></div><p>A further attempt with C-c C-r yields the message:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Don't know which constructor to introduce of Z or S
</code></pre></div></div><p>We can fill in <code class="language-plaintext highlighter-rouge">Z</code> by hand. If we type C-c C-space, Agda will confirm we are done:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>âŠ¢sucâ€² = âŠ¢Æ› (âŠ¢suc (âŠ¢` Z))
</code></pre></div></div><p>The entire process can be automated using Agsy, invoked with C-c C-a.</p><p>Chapter <a href="/20.07/Inference/">Inference</a> will show how to use Agda to compute type derivations directly.</p><h3 id="lookup-is-injective">Lookup is injective</h3><p>The lookup relation <code class="language-plaintext highlighter-rouge">Î“ âˆ‹ x â¦‚ A</code> is injective, in that for each <code class="language-plaintext highlighter-rouge">Î“</code> and <code class="language-plaintext highlighter-rouge">x</code> there is at most one <code class="language-plaintext highlighter-rouge">A</code> such that the judgment holds:</p><pre class="Agda"><a id="âˆ‹-injective"></a><a id="40900" href="/20.07/Lambda/#40900" class="Function">âˆ‹-injective</a> <a id="40912" class="Symbol">:</a> <a id="40914" class="Symbol">âˆ€</a> <a id="40916" class="Symbol">{</a><a id="40917" href="/20.07/Lambda/#40917" class="Bound">Î“</a> <a id="40919" href="/20.07/Lambda/#40919" class="Bound">x</a> <a id="40921" href="/20.07/Lambda/#40921" class="Bound">A</a> <a id="40923" href="/20.07/Lambda/#40923" class="Bound">B</a><a id="40924" class="Symbol">}</a> <a id="40926" class="Symbol">â†’</a> <a id="40928" href="/20.07/Lambda/#40917" class="Bound">Î“</a> <a id="40930" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="40932" href="/20.07/Lambda/#40919" class="Bound">x</a> <a id="40934" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="40936" href="/20.07/Lambda/#40921" class="Bound">A</a> <a id="40938" class="Symbol">â†’</a> <a id="40940" href="/20.07/Lambda/#40917" class="Bound">Î“</a> <a id="40942" href="/20.07/Lambda/#33080" class="Datatype Operator">âˆ‹</a> <a id="40944" href="/20.07/Lambda/#40919" class="Bound">x</a> <a id="40946" href="/20.07/Lambda/#33080" class="Datatype Operator">â¦‚</a> <a id="40948" href="/20.07/Lambda/#40923" class="Bound">B</a> <a id="40950" class="Symbol">â†’</a> <a id="40952" href="/20.07/Lambda/#40921" class="Bound">A</a> <a id="40954" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">â‰¡</a> <a id="40956" href="/20.07/Lambda/#40923" class="Bound">B</a>
<a id="40958" href="/20.07/Lambda/#40900" class="Function">âˆ‹-injective</a> <a id="40970" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>        <a id="40979" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>          <a id="40990" class="Symbol">=</a>  <a id="40993" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
<a id="40998" href="/20.07/Lambda/#40900" class="Function">âˆ‹-injective</a> <a id="41010" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>        <a id="41019" class="Symbol">(</a><a id="41020" href="/20.07/Lambda/#33189" class="InductiveConstructor">S</a> <a id="41022" href="/20.07/Lambda/#41022" class="Bound">xâ‰¢</a> <a id="41025" class="Symbol">_)</a>   <a id="41030" class="Symbol">=</a>  <a id="41033" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#294" class="Function">âŠ¥-elim</a> <a id="41040" class="Symbol">(</a><a id="41041" href="/20.07/Lambda/#41022" class="Bound">xâ‰¢</a> <a id="41044" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="41048" class="Symbol">)</a>
<a id="41050" href="/20.07/Lambda/#40900" class="Function">âˆ‹-injective</a> <a id="41062" class="Symbol">(</a><a id="41063" href="/20.07/Lambda/#33189" class="InductiveConstructor">S</a> <a id="41065" href="/20.07/Lambda/#41065" class="Bound">xâ‰¢</a> <a id="41068" class="Symbol">_)</a> <a id="41071" href="/20.07/Lambda/#33123" class="InductiveConstructor">Z</a>          <a id="41082" class="Symbol">=</a>  <a id="41085" href="https://agda.github.io/agda-stdlib/v1.1/Data.Empty.html#294" class="Function">âŠ¥-elim</a> <a id="41092" class="Symbol">(</a><a id="41093" href="/20.07/Lambda/#41065" class="Bound">xâ‰¢</a> <a id="41096" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="41100" class="Symbol">)</a>
<a id="41102" href="/20.07/Lambda/#40900" class="Function">âˆ‹-injective</a> <a id="41114" class="Symbol">(</a><a id="41115" href="/20.07/Lambda/#33189" class="InductiveConstructor">S</a> <a id="41117" class="Symbol">_</a> <a id="41119" href="/20.07/Lambda/#41119" class="Bound">âˆ‹x</a><a id="41121" class="Symbol">)</a> <a id="41123" class="Symbol">(</a><a id="41124" href="/20.07/Lambda/#33189" class="InductiveConstructor">S</a> <a id="41126" class="Symbol">_</a> <a id="41128" href="/20.07/Lambda/#41128" class="Bound">âˆ‹xâ€²</a><a id="41131" class="Symbol">)</a>  <a id="41134" class="Symbol">=</a>  <a id="41137" href="/20.07/Lambda/#40900" class="Function">âˆ‹-injective</a> <a id="41149" href="/20.07/Lambda/#41119" class="Bound">âˆ‹x</a> <a id="41152" href="/20.07/Lambda/#41128" class="Bound">âˆ‹xâ€²</a>
</pre><p>The typing relation <code class="language-plaintext highlighter-rouge">Î“ âŠ¢ M â¦‚ A</code> is not injective. For example, in any <code class="language-plaintext highlighter-rouge">Î“</code> the term <code class="language-plaintext highlighter-rouge">Æ› "x" â‡’ ` "x"</code> has type <code class="language-plaintext highlighter-rouge">A â‡’ A</code> for any type <code class="language-plaintext highlighter-rouge">A</code>.</p><h3 id="non-examples">Non-examples</h3><p>We can also show that terms are <em>not</em> typeable. For example, here is a formal proof that it is not possible to type the term <code class="language-plaintext highlighter-rouge">`zero Â· `suc `zero</code>. It cannot be typed, because doing so requires that the first term in the application is both a natural and a function:</p><pre class="Agda"><a id="nopeâ‚"></a><a id="41595" href="/20.07/Lambda/#41595" class="Function">nopeâ‚</a> <a id="41601" class="Symbol">:</a> <a id="41603" class="Symbol">âˆ€</a> <a id="41605" class="Symbol">{</a><a id="41606" href="/20.07/Lambda/#41606" class="Bound">A</a><a id="41607" class="Symbol">}</a> <a id="41609" class="Symbol">â†’</a> <a id="41611" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#535" class="Function Operator">Â¬</a> <a id="41613" class="Symbol">(</a><a id="41614" href="/20.07/Lambda/#31868" class="InductiveConstructor">âˆ…</a> <a id="41616" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="41618" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="41624" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="41626" href="/20.07/Lambda/#4191" class="InductiveConstructor Operator">`suc</a> <a id="41631" href="/20.07/Lambda/#4157" class="InductiveConstructor">`zero</a> <a id="41637" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="41639" href="/20.07/Lambda/#41606" class="Bound">A</a><a id="41640" class="Symbol">)</a>
<a id="41642" href="/20.07/Lambda/#41595" class="Function">nopeâ‚</a> <a id="41648" class="Symbol">(()</a> <a id="41652" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="41654" class="Symbol">_)</a>
</pre><p>As a second example, here is a formal proof that it is not possible to type <code class="language-plaintext highlighter-rouge">Æ› "x" â‡’ ` "x" Â· ` "x"</code>. It cannot be typed, because doing so requires types <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code> such that <code class="language-plaintext highlighter-rouge">A â‡’ B â‰¡ A</code>:</p><pre class="Agda"><a id="nopeâ‚‚"></a><a id="41859" href="/20.07/Lambda/#41859" class="Function">nopeâ‚‚</a> <a id="41865" class="Symbol">:</a> <a id="41867" class="Symbol">âˆ€</a> <a id="41869" class="Symbol">{</a><a id="41870" href="/20.07/Lambda/#41870" class="Bound">A</a><a id="41871" class="Symbol">}</a> <a id="41873" class="Symbol">â†’</a> <a id="41875" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#535" class="Function Operator">Â¬</a> <a id="41877" class="Symbol">(</a><a id="41878" href="/20.07/Lambda/#31868" class="InductiveConstructor">âˆ…</a> <a id="41880" href="/20.07/Lambda/#34792" class="Datatype Operator">âŠ¢</a> <a id="41882" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">Æ›</a> <a id="41884" class="String">&quot;x&quot;</a> <a id="41888" href="/20.07/Lambda/#4063" class="InductiveConstructor Operator">â‡’</a> <a id="41890" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="41892" class="String">&quot;x&quot;</a> <a id="41896" href="/20.07/Lambda/#4109" class="InductiveConstructor Operator">Â·</a> <a id="41898" href="/20.07/Lambda/#4024" class="InductiveConstructor Operator">`</a> <a id="41900" class="String">&quot;x&quot;</a> <a id="41904" href="/20.07/Lambda/#34792" class="Datatype Operator">â¦‚</a> <a id="41906" href="/20.07/Lambda/#41870" class="Bound">A</a><a id="41907" class="Symbol">)</a>
<a id="41909" href="/20.07/Lambda/#41859" class="Function">nopeâ‚‚</a> <a id="41915" class="Symbol">(</a><a id="41916" href="/20.07/Lambda/#34927" class="InductiveConstructor">âŠ¢Æ›</a> <a id="41919" class="Symbol">(</a><a id="41920" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="41923" href="/20.07/Lambda/#41923" class="Bound">âˆ‹x</a> <a id="41926" href="/20.07/Lambda/#35034" class="InductiveConstructor Operator">Â·</a> <a id="41928" href="/20.07/Lambda/#34848" class="InductiveConstructor">âŠ¢`</a> <a id="41931" href="/20.07/Lambda/#41931" class="Bound">âˆ‹xâ€²</a><a id="41934" class="Symbol">))</a>  <a id="41938" class="Symbol">=</a>  <a id="41941" href="/20.07/Lambda/#41986" class="Function">contradiction</a> <a id="41955" class="Symbol">(</a><a id="41956" href="/20.07/Lambda/#40900" class="Function">âˆ‹-injective</a> <a id="41968" href="/20.07/Lambda/#41923" class="Bound">âˆ‹x</a> <a id="41971" href="/20.07/Lambda/#41931" class="Bound">âˆ‹xâ€²</a><a id="41974" class="Symbol">)</a>
  <a id="41978" class="Keyword">where</a>
  <a id="41986" href="/20.07/Lambda/#41986" class="Function">contradiction</a> <a id="42000" class="Symbol">:</a> <a id="42002" class="Symbol">âˆ€</a> <a id="42004" class="Symbol">{</a><a id="42005" href="/20.07/Lambda/#42005" class="Bound">A</a> <a id="42007" href="/20.07/Lambda/#42007" class="Bound">B</a><a id="42008" class="Symbol">}</a> <a id="42010" class="Symbol">â†’</a> <a id="42012" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Nullary.html#535" class="Function Operator">Â¬</a> <a id="42014" class="Symbol">(</a><a id="42015" href="/20.07/Lambda/#42005" class="Bound">A</a> <a id="42017" href="/20.07/Lambda/#30207" class="InductiveConstructor Operator">â‡’</a> <a id="42019" href="/20.07/Lambda/#42007" class="Bound">B</a> <a id="42021" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">â‰¡</a> <a id="42023" href="/20.07/Lambda/#42005" class="Bound">A</a><a id="42024" class="Symbol">)</a>
  <a id="42028" href="/20.07/Lambda/#41986" class="Function">contradiction</a> <a id="42042" class="Symbol">()</a>
</pre><h4 id="quiz-3">Quiz</h4><p>For each of the following, give a type <code class="language-plaintext highlighter-rouge">A</code> for which it is derivable, or explain why there is no such <code class="language-plaintext highlighter-rouge">A</code>.</p><ol><li><code class="language-plaintext highlighter-rouge">âˆ… , "y" â¦‚ `â„• â‡’ `â„• , "x" â¦‚ `â„• âŠ¢ ` "y" Â· ` "x" â¦‚ A</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… , "y" â¦‚ `â„• â‡’ `â„• , "x" â¦‚ `â„• âŠ¢ ` "x" Â· ` "y" â¦‚ A</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… , "y" â¦‚ `â„• â‡’ `â„• âŠ¢ Æ› "x" â‡’ ` "y" Â· ` "x" â¦‚ A</code></li></ol><p>For each of the following, give types <code class="language-plaintext highlighter-rouge">A</code>, <code class="language-plaintext highlighter-rouge">B</code>, and <code class="language-plaintext highlighter-rouge">C</code> for which it is derivable, or explain why there are no such types.</p><ol><li><code class="language-plaintext highlighter-rouge">âˆ… , "x" â¦‚ A âŠ¢ ` "x" Â· ` "x" â¦‚ B</code></li><li><code class="language-plaintext highlighter-rouge">âˆ… , "x" â¦‚ A , "y" â¦‚ B âŠ¢ Æ› "z" â‡’ ` "x" Â· (` "y" Â· ` "z") â¦‚ C</code></li></ol><h4 id="exercise-mul-recommended-1">Exercise <code class="language-plaintext highlighter-rouge">âŠ¢mul</code> (recommended)</h4><p>Using the term <code class="language-plaintext highlighter-rouge">mul</code> you defined earlier, write out the derivation showing that it is well typed.</p><pre class="Agda"><a id="42717" class="Comment">-- Your code goes here</a>
</pre><h4 id="exercise-mulá¶œ-practice-1">Exercise <code class="language-plaintext highlighter-rouge">âŠ¢mulá¶œ</code> (practice)</h4><p>Using the term <code class="language-plaintext highlighter-rouge">mulá¶œ</code> you defined earlier, write out the derivation showing that it is well typed.</p><pre class="Agda"><a id="42884" class="Comment">-- Your code goes here</a>
</pre><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>â‡’  U+21D2  RIGHTWARDS DOUBLE ARROW (\=&gt;)
Æ›  U+019B  LATIN SMALL LETTER LAMBDA WITH STROKE (\Gl-)
Â·  U+00B7  MIDDLE DOT (\cdot)
â€”  U+2014  EM DASH (\em)
â†   U+21A0  RIGHTWARDS TWO HEADED ARROW (\rr-)
Î¾  U+03BE  GREEK SMALL LETTER XI (\Gx or \xi)
Î²  U+03B2  GREEK SMALL LETTER BETA (\Gb or \beta)
Î“  U+0393  GREEK CAPITAL LETTER GAMMA (\GG or \Gamma)
â‰   U+2260  NOT EQUAL TO (\=n or \ne)
âˆ‹  U+220B  CONTAINS AS MEMBER (\ni)
âˆ…  U+2205  EMPTY SET (\0)
âŠ¢  U+22A2  RIGHT TACK (\vdash or \|-)
â¦‚  U+2982  Z NOTATION TYPE COLON (\:)
ğŸ˜‡  U+1F607  SMILING FACE WITH HALO
ğŸ˜ˆ  U+1F608  SMILING FACE WITH HORNS
</code></pre></div></div><p>We compose reduction <code class="language-plaintext highlighter-rouge">â€”â†’</code> from an em dash <code class="language-plaintext highlighter-rouge">â€”</code> and an arrow <code class="language-plaintext highlighter-rouge">â†’</code>. Similarly for reflexive and transitive closure <code class="language-plaintext highlighter-rouge">â€”â† </code>.</p></div><p style="text-align:center"><a alt="Previous chapter" href="/20.07/Lists/">Prev</a> &bullet; <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev-20.07/src/plfa/part2/Lambda.lagda.md">Source</a> &bullet; <a alt="Next chapter" href="/20.07/Properties/">Next</a></p></article></div></main><footer class="site-footer h-card"><data class="u-url" href="/20.07/"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jsiek"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jsiek</span></a></li><li><a href="https://www.twitter.com/jeremysiek"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jeremysiek</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer><script type="text/javascript" src="/20.07/assets/jquery.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha256-E4RlfxwyJVmkkk0szw7LYJxuPlp6evtPSBDlWHsYYL8=" crossorigin="anonymous"></script><script type="text/javascript">anchors.add()</script><script type="text/javascript">$(".menu-icon").click(function(){$(".trigger").toggle()}),$("div.foldable pre").each(function(){var i=$(this).height(),t=parseFloat($(this).css("line-height")),h=$("<div></div>"),e=$("<div></div>"),o=$("<div></div>");$(this).prepend(h),h.css({position:"relative",float:"right",right:"-"+(.5*t-1.5)+"px",width:t,height:t}),o.css({position:"relative",height:t,width:"3px","background-color":"#C1E0FF"}),e.css({position:"relative",top:"-"+(.5*t+1.5)+"px",left:"-"+(.5*t-1.5)+"px",height:"3px",width:t,"background-color":"#C1E0FF"}),h.append(o),h.append(e),$(this).height(2*t),$(this).css("overflow","hidden"),$(this).click(function(){$(this).height()==i?($(this).height(2*t),h.show()):($(this).height("auto"),h.hide())})})</script><script type="text/javascript" src="/20.07/assets/katex.js"></script><script type="text/javascript">$("script[type='math/tex']").replaceWith(function(){var t=$(this).text();return'<span class="inline-equation">'+katex.renderToString(t)+"</span>"}),$("script[type='math/tex; mode=display']").replaceWith(function(){var t=$(this).text().replace(/%.*?(\n|$)/g,"");return'<div class="equation">'+katex.renderToString("\\displaystyle "+t)+"</div>"})</script></body></html>