<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Naturals: Natural numbers | Programming Language Foundations in Agda</title><meta name="generator" content="Jekyll v3.9.0"><meta property="og:title" content="Naturals: Natural numbers"><meta property="og:locale" content="en_US"><meta name="description" content="Programming Language Foundations in Agda"><meta property="og:description" content="Programming Language Foundations in Agda"><link rel="canonical" href="https://plfa.github.io/20.07/Naturals/"><meta property="og:url" content="https://plfa.github.io/20.07/Naturals/"><meta property="og:site_name" content="Programming Language Foundations in Agda"><script type="application/ld+json">{"url":"https://plfa.github.io/20.07/Naturals/","headline":"Naturals: Natural numbers","description":"Programming Language Foundations in Agda","@type":"WebPage","@context":"https://schema.org"}</script><link rel="stylesheet" href="/20.07/assets/main.css"></head><body><header class="site-header" role="banner"><div class="wrapper"><a class="site-title" href="/20.07/">Programming Language Foundations in Agda</a><nav class="site-nav"><span class="menu-icon"><svg viewBox="0 0 18 15" width="18px" height="15px"><path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/><path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/><path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/></svg></span><div class="trigger"><a class="page-link" href="/20.07/">The Book</a> <a class="page-link" href="/20.07/Announcements/">Announcements</a> <a class="page-link" href="/20.07/GettingStarted/">Getting Started</a> <a class="page-link" href="/20.07/Citing/">Citing</a> <a class="page-link" href="https://agda-zh.github.io/PLFA-zh/">中文</a></div></nav></div></header><main class="page-content" aria-label="Content"><div class="wrapper"><article class="post"><header class="post-header"><h1 class="post-title">Naturals: Natural numbers</h1></header><p style="text-align:center"><a alt="Previous chapter" href="/20.07/Preface/">Prev</a> &bullet; <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev-20.07/src/plfa/part1/Naturals.lagda.md">Source</a> &bullet; <a alt="Next chapter" href="/20.07/Induction/">Next</a></p><div class="post-content"><pre class="Agda"><a id="140" class="Keyword">module</a> <a id="147" href="/20.07/Naturals/" class="Module">plfa.part1.Naturals</a> <a id="167" class="Keyword">where</a>
</pre><p>The night sky holds more stars than I can count, though fewer than five thousand are visible to the naked eye. The observable universe contains about seventy sextillion stars.</p><p>But the number of stars is finite, while natural numbers are infinite. Count all the stars, and you will still have as many natural numbers left over as you started with.</p><h2 id="the-naturals-are-an-inductive-datatype">The naturals are an inductive datatype</h2><p>Everyone is familiar with the natural numbers</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0
1
2
3
...
</code></pre></div></div><p>and so on. We write <code class="language-plaintext highlighter-rouge">ℕ</code> for the <em>type</em> of natural numbers, and say that <code class="language-plaintext highlighter-rouge">0</code>, <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">2</code>, <code class="language-plaintext highlighter-rouge">3</code>, and so on are <em>values</em> of type <code class="language-plaintext highlighter-rouge">ℕ</code>, indicated by writing <code class="language-plaintext highlighter-rouge">0 : ℕ</code>, <code class="language-plaintext highlighter-rouge">1 : ℕ</code>, <code class="language-plaintext highlighter-rouge">2 : ℕ</code>, <code class="language-plaintext highlighter-rouge">3 : ℕ</code>, and so on.</p><p>The set of natural numbers is infinite, yet we can write down its definition in just a few lines. Here is the definition as a pair of inference rules:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>--------
zero : ℕ

m : ℕ
---------
suc m : ℕ
</code></pre></div></div><p>And here is the definition in Agda:</p><pre class="Agda"><a id="1108" class="Keyword">data</a> <a id="ℕ"></a><a id="1113" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="1115" class="Symbol">:</a> <a id="1117" class="PrimitiveType">Set</a> <a id="1121" class="Keyword">where</a>
  <a id="ℕ.zero"></a><a id="1129" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a> <a id="1134" class="Symbol">:</a> <a id="1136" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a>
  <a id="ℕ.suc"></a><a id="1140" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a>  <a id="1145" class="Symbol">:</a> <a id="1147" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="1149" class="Symbol">→</a> <a id="1151" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a>
</pre><p>Here <code class="language-plaintext highlighter-rouge">ℕ</code> is the name of the <em>datatype</em> we are defining, and <code class="language-plaintext highlighter-rouge">zero</code> and <code class="language-plaintext highlighter-rouge">suc</code> (short for <em>successor</em>) are the <em>constructors</em> of the datatype.</p><p>Both definitions above tell us the same two things:</p><ul><li><em>Base case</em>: <code class="language-plaintext highlighter-rouge">zero</code> is a natural number.</li><li><em>Inductive case</em>: if <code class="language-plaintext highlighter-rouge">m</code> is a natural number, then <code class="language-plaintext highlighter-rouge">suc m</code> is also a natural number.</li></ul><p>Further, these two rules give the <em>only</em> ways of creating natural numbers. Hence, the possible natural numbers are:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zero
suc zero
suc (suc zero)
suc (suc (suc zero))
...
</code></pre></div></div><p>We write <code class="language-plaintext highlighter-rouge">0</code> as shorthand for <code class="language-plaintext highlighter-rouge">zero</code>; and <code class="language-plaintext highlighter-rouge">1</code> is shorthand for <code class="language-plaintext highlighter-rouge">suc zero</code>, the successor of zero, that is, the natural that comes after zero; and <code class="language-plaintext highlighter-rouge">2</code> is shorthand for <code class="language-plaintext highlighter-rouge">suc (suc zero)</code>, which is the same as <code class="language-plaintext highlighter-rouge">suc 1</code>, the successor of one; and <code class="language-plaintext highlighter-rouge">3</code> is shorthand for the successor of two; and so on.</p><h4 id="seven">Exercise <code class="language-plaintext highlighter-rouge">seven</code> (practice)</h4><p>Write out <code class="language-plaintext highlighter-rouge">7</code> in longhand.</p><pre class="Agda"><a id="2049" class="Comment">-- Your code goes here</a>
</pre><h2 id="unpacking-the-inference-rules">Unpacking the inference rules</h2><p>Let’s unpack the inference rules. Each inference rule consists of zero or more <em>judgments</em> written above a horizontal line, called the <em>hypotheses</em>, and a single judgment written below, called the <em>conclusion</em>. The first rule is the base case. It has no hypotheses, and the conclusion asserts that <code class="language-plaintext highlighter-rouge">zero</code> is a natural. The second rule is the inductive case. It has one hypothesis, which assumes that <code class="language-plaintext highlighter-rouge">m</code> is a natural, and the conclusion asserts that <code class="language-plaintext highlighter-rouge">suc m</code> is a also a natural.</p><h2 id="unpacking-the-agda-definition">Unpacking the Agda definition</h2><p>Let’s unpack the Agda definition. The keyword <code class="language-plaintext highlighter-rouge">data</code> tells us this is an inductive definition, that is, that we are defining a new datatype with constructors. The phrase</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ℕ : Set
</code></pre></div></div><p>tells us that <code class="language-plaintext highlighter-rouge">ℕ</code> is the name of the new datatype, and that it is a <code class="language-plaintext highlighter-rouge">Set</code>, which is the way in Agda of saying that it is a type. The keyword <code class="language-plaintext highlighter-rouge">where</code> separates the declaration of the datatype from the declaration of its constructors. Each constructor is declared on a separate line, which is indented to indicate that it belongs to the corresponding <code class="language-plaintext highlighter-rouge">data</code> declaration. The lines</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zero : ℕ
suc  : ℕ → ℕ
</code></pre></div></div><p>give <em>signatures</em> specifying the types of the constructors <code class="language-plaintext highlighter-rouge">zero</code> and <code class="language-plaintext highlighter-rouge">suc</code>. They tell us that <code class="language-plaintext highlighter-rouge">zero</code> is a natural number and that <code class="language-plaintext highlighter-rouge">suc</code> takes a natural number as argument and returns a natural number.</p><p>You may have noticed that <code class="language-plaintext highlighter-rouge">ℕ</code> and <code class="language-plaintext highlighter-rouge">→</code> don’t appear on your keyboard. They are symbols in <em>unicode</em>. At the end of each chapter is a list of all unicode symbols introduced in the chapter, including instructions on how to type them in the Emacs text editor. Here <em>type</em> refers to typing with fingers as opposed to data types!</p><h2 id="the-story-of-creation">The story of creation</h2><p>Let’s look again at the rules that define the natural numbers:</p><ul><li><em>Base case</em>: <code class="language-plaintext highlighter-rouge">zero</code> is a natural number.</li><li><em>Inductive case</em>: if <code class="language-plaintext highlighter-rouge">m</code> is a natural number, then <code class="language-plaintext highlighter-rouge">suc m</code> is also a natural number.</li></ul><p>Hold on! The second line defines natural numbers in terms of natural numbers. How can that possibly be allowed? Isn’t this as useless a definition as “Brexit means Brexit”?</p><p>In fact, it is possible to assign our definition a meaning without resorting to unpermitted circularities. Furthermore, we can do so while only working with <em>finite</em> sets and never referring to the <em>infinite</em> set of natural numbers.</p><p>We will think of it as a creation story. To start with, we know about no natural numbers at all:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- In the beginning, there are no natural numbers.
</code></pre></div></div><p>Now, we apply the rules to all the natural numbers we know about. The base case tells us that <code class="language-plaintext highlighter-rouge">zero</code> is a natural number, so we add it to the set of known natural numbers. The inductive case tells us that if <code class="language-plaintext highlighter-rouge">m</code> is a natural number (on the day before today) then <code class="language-plaintext highlighter-rouge">suc m</code> is also a natural number (today). We didn’t know about any natural numbers before today, so the inductive case doesn’t apply:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the first day, there is one natural number.
zero : ℕ
</code></pre></div></div><p>Then we repeat the process. On the next day we know about all the numbers from the day before, plus any numbers added by the rules. The base case tells us that <code class="language-plaintext highlighter-rouge">zero</code> is a natural number, but we already knew that. But now the inductive case tells us that since <code class="language-plaintext highlighter-rouge">zero</code> was a natural number yesterday, then <code class="language-plaintext highlighter-rouge">suc zero</code> is a natural number today:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the second day, there are two natural numbers.
zero : ℕ
suc zero : ℕ
</code></pre></div></div><p>And we repeat the process again. Now the inductive case tells us that since <code class="language-plaintext highlighter-rouge">zero</code> and <code class="language-plaintext highlighter-rouge">suc zero</code> are both natural numbers, then <code class="language-plaintext highlighter-rouge">suc zero</code> and <code class="language-plaintext highlighter-rouge">suc (suc zero)</code> are natural numbers. We already knew about the first of these, but the second is new:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the third day, there are three natural numbers.
zero : ℕ
suc zero : ℕ
suc (suc zero) : ℕ
</code></pre></div></div><p>You’ve got the hang of it by now:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the fourth day, there are four natural numbers.
zero : ℕ
suc zero : ℕ
suc (suc zero) : ℕ
suc (suc (suc zero)) : ℕ
</code></pre></div></div><p>The process continues. On the <em>n</em>‘th day there will be <em>n</em> distinct natural numbers. Every natural number will appear on some given day. In particular, the number <em>n</em> first appears on day <em>n+1</em>. And we never actually define the set of numbers in terms of itself. Instead, we define the set of numbers on day <em>n+1</em> in terms of the set of numbers on day <em>n</em>.</p><p>A process like this one is called <em>inductive</em>. We start with nothing, and build up a potentially infinite set by applying rules that convert one finite set into another finite set.</p><p>The rule defining zero is called a <em>base case</em>, because it introduces a natural number even when we know no other natural numbers. The rule defining successor is called an <em>inductive case</em>, because it introduces more natural numbers once we already know some. Note the crucial role of the base case. If we only had inductive rules, then we would have no numbers in the beginning, and still no numbers on the second day, and on the third, and so on. An inductive definition lacking a base case is useless, as in the phrase “Brexit means Brexit”.</p><h2 id="philosophy-and-history">Philosophy and history</h2><p>A philosopher might observe that our reference to the first day, second day, and so on, implicitly involves an understanding of natural numbers. In this sense, our definition might indeed be regarded as in some sense circular, but we need not let this disturb us. Everyone possesses a good informal understanding of the natural numbers, which we may take as a foundation for their formal description.</p><p>While the natural numbers have been understood for as long as people can count, the inductive definition of the natural numbers is relatively recent. It can be traced back to Richard Dedekind’s paper “<em>Was sind und was sollen die Zahlen?</em>” (What are and what should be the numbers?), published in 1888, and Giuseppe Peano’s book “<em>Arithmetices principia, nova methodo exposita</em>” (The principles of arithmetic presented by a new method), published the following year.</p><h2 id="a-pragma">A pragma</h2><p>In Agda, any text following <code class="language-plaintext highlighter-rouge">--</code> or enclosed between <code class="language-plaintext highlighter-rouge">{-</code> and <code class="language-plaintext highlighter-rouge">-}</code> is considered a <em>comment</em>. Comments have no effect on the code, with the exception of one special kind of comment, called a <em>pragma</em>, which is enclosed between <code class="language-plaintext highlighter-rouge">{-#</code> and <code class="language-plaintext highlighter-rouge">#-}</code>.</p><p>Including the line</p><pre class="Agda"><a id="8259" class="Symbol">{-#</a> <a id="8263" class="Keyword">BUILTIN</a> <a id="8271" class="Pragma">NATURAL</a> <a id="8279" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="8281" class="Symbol">#-}</a>
</pre><p>tells Agda that <code class="language-plaintext highlighter-rouge">ℕ</code> corresponds to the natural numbers, and hence one is permitted to type <code class="language-plaintext highlighter-rouge">0</code> as shorthand for <code class="language-plaintext highlighter-rouge">zero</code>, <code class="language-plaintext highlighter-rouge">1</code> as shorthand for <code class="language-plaintext highlighter-rouge">suc zero</code>, <code class="language-plaintext highlighter-rouge">2</code> as shorthand for <code class="language-plaintext highlighter-rouge">suc (suc zero)</code>, and so on. The pragma must be given a previously declared type (in this case <code class="language-plaintext highlighter-rouge">ℕ</code>) with precisely two constructors, one with no arguments (in this case <code class="language-plaintext highlighter-rouge">zero</code>), and one with a single argument of the given type (in this case <code class="language-plaintext highlighter-rouge">suc</code>).</p><p>As well as enabling the above shorthand, the pragma also enables a more efficient internal representation of naturals using the Haskell type for arbitrary-precision integers. Representing the natural <em>n</em> with <code class="language-plaintext highlighter-rouge">zero</code> and <code class="language-plaintext highlighter-rouge">suc</code> requires space proportional to <em>n</em>, whereas representing it as an arbitrary-precision integer in Haskell only requires space proportional to the logarithm of <em>n</em>.</p><h2 id="imports">Imports</h2><p>Shortly we will want to write some equations that hold between terms involving natural numbers. To support doing so, we import the definition of equality and notations for reasoning about it from the Agda standard library:</p><pre class="Agda"><a id="9346" class="Keyword">import</a> <a id="9353" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a> <a id="9391" class="Symbol">as</a> <a id="9394" class="Module">Eq</a>
<a id="9397" class="Keyword">open</a> <a id="9402" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.html" class="Module">Eq</a> <a id="9405" class="Keyword">using</a> <a id="9411" class="Symbol">(</a><a id="9412" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">_≡_</a><a id="9415" class="Symbol">;</a> <a id="9417" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a><a id="9421" class="Symbol">)</a>
<a id="9423" class="Keyword">open</a> <a id="9428" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2499" class="Module">Eq.≡-Reasoning</a> <a id="9443" class="Keyword">using</a> <a id="9449" class="Symbol">(</a><a id="9450" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin_</a><a id="9456" class="Symbol">;</a> <a id="9458" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">_≡⟨⟩_</a><a id="9463" class="Symbol">;</a> <a id="9465" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">_∎</a><a id="9467" class="Symbol">)</a>
</pre><p>The first line brings the standard library module that defines equality into scope and gives it the name <code class="language-plaintext highlighter-rouge">Eq</code>. The second line opens that module, that is, adds all the names specified in the <code class="language-plaintext highlighter-rouge">using</code> clause into the current scope. In this case the names added are <code class="language-plaintext highlighter-rouge">_≡_</code>, the equality operator, and <code class="language-plaintext highlighter-rouge">refl</code>, the name for evidence that two terms are equal. The third line takes a module that specifies operators to support reasoning about equivalence, and adds all the names specified in the <code class="language-plaintext highlighter-rouge">using</code> clause into the current scope. In this case, the names added are <code class="language-plaintext highlighter-rouge">begin_</code>, <code class="language-plaintext highlighter-rouge">_≡⟨⟩_</code>, and <code class="language-plaintext highlighter-rouge">_∎</code>. We will see how these are used below. We take these as givens for now, but will see how they are defined in Chapter <a href="/20.07/Equality/">Equality</a>.</p><p>Agda uses underbars to indicate where terms appear in infix or mixfix operators. Thus, <code class="language-plaintext highlighter-rouge">_≡_</code> and <code class="language-plaintext highlighter-rouge">_≡⟨⟩_</code> are infix (each operator is written between two terms), while <code class="language-plaintext highlighter-rouge">begin_</code> is prefix (it is written before a term), and <code class="language-plaintext highlighter-rouge">_∎</code> is postfix (it is written after a term).</p><p>Parentheses and semicolons are among the few characters that cannot appear in names, so we do not need extra spaces in the <code class="language-plaintext highlighter-rouge">using</code> list.</p><h2 id="plus">Operations on naturals are recursive functions</h2><p>Now that we have the natural numbers, what can we do with them? For instance, can we define arithmetic operations such as addition and multiplication?</p><p>As a child I spent much time memorising tables of addition and multiplication. At first the rules seemed tricky and I would often make mistakes. It came as a shock to me to discover <em>recursion</em>, a simple technique by which every one of the infinite possible instances of addition and multiplication can be specified in just a couple of lines.</p><p>Here is the definition of addition in Agda:</p><pre class="Agda"><a id="_+_"></a><a id="11238" href="/20.07/Naturals/#11238" class="Function Operator">_+_</a> <a id="11242" class="Symbol">:</a> <a id="11244" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="11246" class="Symbol">→</a> <a id="11248" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="11250" class="Symbol">→</a> <a id="11252" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a>
<a id="11254" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a> <a id="11259" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="11261" href="/20.07/Naturals/#11261" class="Bound">n</a> <a id="11263" class="Symbol">=</a> <a id="11265" href="/20.07/Naturals/#11261" class="Bound">n</a>
<a id="11267" class="Symbol">(</a><a id="11268" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="11272" href="/20.07/Naturals/#11272" class="Bound">m</a><a id="11273" class="Symbol">)</a> <a id="11275" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="11277" href="/20.07/Naturals/#11277" class="Bound">n</a> <a id="11279" class="Symbol">=</a> <a id="11281" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="11285" class="Symbol">(</a><a id="11286" href="/20.07/Naturals/#11272" class="Bound">m</a> <a id="11288" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="11290" href="/20.07/Naturals/#11277" class="Bound">n</a><a id="11291" class="Symbol">)</a>
</pre><p>Let’s unpack this definition. Addition is an infix operator. It is written with underbars where the arguments go, hence its name is <code class="language-plaintext highlighter-rouge">_+_</code>. The first line is a signature specifying the type of the operator. The type <code class="language-plaintext highlighter-rouge">ℕ → ℕ → ℕ</code>, indicates that addition accepts two naturals and returns a natural. Infix notation is just a shorthand for application; the terms <code class="language-plaintext highlighter-rouge">m + n</code> and <code class="language-plaintext highlighter-rouge">_+_ m n</code> are equivalent.</p><p>The definition has a base case and an inductive case, corresponding to those for the natural numbers. The base case says that adding zero to a number, <code class="language-plaintext highlighter-rouge">zero + n</code>, returns that number, <code class="language-plaintext highlighter-rouge">n</code>. The inductive case says that adding the successor of a number to another number, <code class="language-plaintext highlighter-rouge">(suc m) + n</code>, returns the successor of adding the two numbers, <code class="language-plaintext highlighter-rouge">suc (m + n)</code>. We say we use <em>pattern matching</em> when constructors appear on the left-hand side of an equation.</p><p>If we write <code class="language-plaintext highlighter-rouge">zero</code> as <code class="language-plaintext highlighter-rouge">0</code> and <code class="language-plaintext highlighter-rouge">suc m</code> as <code class="language-plaintext highlighter-rouge">1 + m</code>, the definition turns into two familiar equations:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 0       + n  ≡  n
 (1 + m) + n  ≡  1 + (m + n)
</code></pre></div></div><p>The first follows because zero is an identity for addition, and the second because addition is associative. In its most general form, associativity is written</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> (m + n) + p  ≡  m + (n + p)
</code></pre></div></div><p>meaning that the location of parentheses is irrelevant. We get the second equation from the third by taking <code class="language-plaintext highlighter-rouge">m</code> to be <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">n</code> to be <code class="language-plaintext highlighter-rouge">m</code>, and <code class="language-plaintext highlighter-rouge">p</code> to be <code class="language-plaintext highlighter-rouge">n</code>. We write <code class="language-plaintext highlighter-rouge">=</code> for definitions, while we write <code class="language-plaintext highlighter-rouge">≡</code> for assertions that two already defined things are the same.</p><p>The definition is <em>recursive</em>, in that the last line defines addition in terms of addition. As with the inductive definition of the naturals, the apparent circularity is not a problem. It works because addition of larger numbers is defined in terms of addition of smaller numbers. Such a definition is called <em>well founded</em>.</p><p>For example, let’s add two and three:</p><pre class="Agda"><a id="13141" href="/20.07/Naturals/#13141" class="Function">_</a> <a id="13143" class="Symbol">:</a> <a id="13145" class="Number">2</a> <a id="13147" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13149" class="Number">3</a> <a id="13151" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="13153" class="Number">5</a>
<a id="13155" class="Symbol">_</a> <a id="13157" class="Symbol">=</a>
  <a id="13161" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
    <a id="13171" class="Number">2</a> <a id="13173" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13175" class="Number">3</a>
  <a id="13179" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="13186" class="Comment">-- is shorthand for</a>
    <a id="13210" class="Symbol">(</a><a id="13211" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13215" class="Symbol">(</a><a id="13216" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13220" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a><a id="13224" class="Symbol">))</a> <a id="13227" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13229" class="Symbol">(</a><a id="13230" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13234" class="Symbol">(</a><a id="13235" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13239" class="Symbol">(</a><a id="13240" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13244" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a><a id="13248" class="Symbol">)))</a>
  <a id="13254" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="13261" class="Comment">-- inductive case</a>
    <a id="13283" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13287" class="Symbol">((</a><a id="13289" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13293" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a><a id="13297" class="Symbol">)</a> <a id="13299" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13301" class="Symbol">(</a><a id="13302" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13306" class="Symbol">(</a><a id="13307" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13311" class="Symbol">(</a><a id="13312" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13316" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a><a id="13320" class="Symbol">))))</a>
  <a id="13327" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="13334" class="Comment">-- inductive case</a>
    <a id="13356" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13360" class="Symbol">(</a><a id="13361" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13365" class="Symbol">(</a><a id="13366" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a> <a id="13371" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13373" class="Symbol">(</a><a id="13374" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13378" class="Symbol">(</a><a id="13379" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13383" class="Symbol">(</a><a id="13384" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13388" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a><a id="13392" class="Symbol">)))))</a>
  <a id="13400" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="13407" class="Comment">-- base case</a>
    <a id="13424" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13428" class="Symbol">(</a><a id="13429" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13433" class="Symbol">(</a><a id="13434" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13438" class="Symbol">(</a><a id="13439" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13443" class="Symbol">(</a><a id="13444" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13448" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a><a id="13452" class="Symbol">))))</a>
  <a id="13459" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="13466" class="Comment">-- is longhand for</a>
    <a id="13489" class="Number">5</a>
  <a id="13493" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre><p>We can write the same derivation more compactly by only expanding shorthand as needed:</p><pre class="Agda"><a id="13590" href="/20.07/Naturals/#13590" class="Function">_</a> <a id="13592" class="Symbol">:</a> <a id="13594" class="Number">2</a> <a id="13596" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13598" class="Number">3</a> <a id="13600" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="13602" class="Number">5</a>
<a id="13604" class="Symbol">_</a> <a id="13606" class="Symbol">=</a>
  <a id="13610" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
    <a id="13620" class="Number">2</a> <a id="13622" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13624" class="Number">3</a>
  <a id="13628" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="13636" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13640" class="Symbol">(</a><a id="13641" class="Number">1</a> <a id="13643" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13645" class="Number">3</a><a id="13646" class="Symbol">)</a>
  <a id="13650" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="13658" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13662" class="Symbol">(</a><a id="13663" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13667" class="Symbol">(</a><a id="13668" class="Number">0</a> <a id="13670" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="13672" class="Number">3</a><a id="13673" class="Symbol">))</a>
  <a id="13678" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="13686" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13690" class="Symbol">(</a><a id="13691" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="13695" class="Number">3</a><a id="13696" class="Symbol">)</a>
  <a id="13700" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="13708" class="Number">5</a>
  <a id="13712" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre><p>The first line matches the inductive case by taking <code class="language-plaintext highlighter-rouge">m = 1</code> and <code class="language-plaintext highlighter-rouge">n = 3</code>, the second line matches the inductive case by taking <code class="language-plaintext highlighter-rouge">m = 0</code> and <code class="language-plaintext highlighter-rouge">n = 3</code>, and the third line matches the base case by taking <code class="language-plaintext highlighter-rouge">n = 3</code>.</p><p>Both derivations consist of a signature (written with a colon, <code class="language-plaintext highlighter-rouge">:</code>), giving a type, and a binding (written with an equal sign, <code class="language-plaintext highlighter-rouge">=</code>), giving a term of the given type. Here we use the dummy name <code class="language-plaintext highlighter-rouge">_</code>. The dummy name can be reused, and is convenient for examples. Names other than <code class="language-plaintext highlighter-rouge">_</code> must be used only once in a module.</p><p>Here the type is <code class="language-plaintext highlighter-rouge">2 + 3 ≡ 5</code> and the term provides <em>evidence</em> for the corresponding equation, here written in tabular form as a chain of equations. The chain starts with <code class="language-plaintext highlighter-rouge">begin</code> and finishes with <code class="language-plaintext highlighter-rouge">∎</code> (pronounced “qed” or “tombstone”, the latter from its appearance), and consists of a series of terms separated by <code class="language-plaintext highlighter-rouge">≡⟨⟩</code>.</p><p>In fact, both proofs are longer than need be, and Agda is satisfied with the following:</p><pre class="Agda"><a id="14662" href="/20.07/Naturals/#14662" class="Function">_</a> <a id="14664" class="Symbol">:</a> <a id="14666" class="Number">2</a> <a id="14668" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="14670" class="Number">3</a> <a id="14672" href="Agda.Builtin.Equality.html#125" class="Datatype Operator">≡</a> <a id="14674" class="Number">5</a>
<a id="14676" class="Symbol">_</a> <a id="14678" class="Symbol">=</a> <a id="14680" href="Agda.Builtin.Equality.html#182" class="InductiveConstructor">refl</a>
</pre><p>Agda knows how to compute the value of <code class="language-plaintext highlighter-rouge">2 + 3</code>, and so can immediately check it is the same as <code class="language-plaintext highlighter-rouge">5</code>. A binary relation is said to be <em>reflexive</em> if every value relates to itself. Evidence that a value is equal to itself is written <code class="language-plaintext highlighter-rouge">refl</code>.</p><p>In the chains of equations, all Agda checks is that each term simplifies to the same value. If we jumble the equations, omit lines, or add extraneous lines it will still be accepted. It’s up to us to write the equations in an order that makes sense to the reader.</p><p>Here <code class="language-plaintext highlighter-rouge">2 + 3 ≡ 5</code> is a type, and the chains of equations (and also <code class="language-plaintext highlighter-rouge">refl</code>) are terms of the given type; alternatively, one can think of each term as <em>evidence</em> for the assertion <code class="language-plaintext highlighter-rouge">2 + 3 ≡ 5</code>. This duality of interpretation—of a type as a proposition, and of a term as evidence—is central to how we formalise concepts in Agda, and will be a running theme throughout this book.</p><p>Note that when we use the word <em>evidence</em> it is nothing equivocal. It is not like testimony in a court which must be weighed to determine whether the witness is trustworthy. Rather, it is ironclad. The other word for evidence, which we will use interchangeably, is <em>proof</em>.</p><h4 id="plus-example">Exercise <code class="language-plaintext highlighter-rouge">+-example</code> (practice)</h4><p>Compute <code class="language-plaintext highlighter-rouge">3 + 4</code>, writing out your reasoning as a chain of equations, using the equations for <code class="language-plaintext highlighter-rouge">+</code>.</p><pre class="Agda"><a id="16011" class="Comment">-- Your code goes here</a>
</pre><h2 id="multiplication">Multiplication</h2><p>Once we have defined addition, we can define multiplication as repeated addition:</p><pre class="Agda"><a id="_*_"></a><a id="16145" href="/20.07/Naturals/#16145" class="Function Operator">_*_</a> <a id="16149" class="Symbol">:</a> <a id="16151" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="16153" class="Symbol">→</a> <a id="16155" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="16157" class="Symbol">→</a> <a id="16159" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a>
<a id="16161" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a>    <a id="16169" href="/20.07/Naturals/#16145" class="Function Operator">*</a> <a id="16171" href="/20.07/Naturals/#16171" class="Bound">n</a>  <a id="16174" class="Symbol">=</a>  <a id="16177" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a>
<a id="16182" class="Symbol">(</a><a id="16183" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="16187" href="/20.07/Naturals/#16187" class="Bound">m</a><a id="16188" class="Symbol">)</a> <a id="16190" href="/20.07/Naturals/#16145" class="Function Operator">*</a> <a id="16192" href="/20.07/Naturals/#16192" class="Bound">n</a>  <a id="16195" class="Symbol">=</a>  <a id="16198" href="/20.07/Naturals/#16192" class="Bound">n</a> <a id="16200" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="16202" class="Symbol">(</a><a id="16203" href="/20.07/Naturals/#16187" class="Bound">m</a> <a id="16205" href="/20.07/Naturals/#16145" class="Function Operator">*</a> <a id="16207" href="/20.07/Naturals/#16192" class="Bound">n</a><a id="16208" class="Symbol">)</a>
</pre><p>Computing <code class="language-plaintext highlighter-rouge">m * n</code> returns the sum of <code class="language-plaintext highlighter-rouge">m</code> copies of <code class="language-plaintext highlighter-rouge">n</code>.</p><p>Again, rewriting turns the definition into two familiar equations:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0       * n  ≡  0
(1 + m) * n  ≡  n + (m * n)
</code></pre></div></div><p>The first follows because zero times anything is zero, and the second follows because multiplication distributes over addition. In its most general form, distribution of multiplication over addition is written</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(m + n) * p  ≡  (m * p) + (n * p)
</code></pre></div></div><p>We get the second equation from the third by taking <code class="language-plaintext highlighter-rouge">m</code> to be <code class="language-plaintext highlighter-rouge">1</code>, <code class="language-plaintext highlighter-rouge">n</code> to be <code class="language-plaintext highlighter-rouge">m</code>, and <code class="language-plaintext highlighter-rouge">p</code> to be <code class="language-plaintext highlighter-rouge">n</code>, and then using the fact that one is an identity for multiplication, so <code class="language-plaintext highlighter-rouge">1 * n ≡ n</code>.</p><p>Again, the definition is well founded in that multiplication of larger numbers is defined in terms of multiplication of smaller numbers.</p><p>For example, let’s multiply two and three:</p><pre class="Agda"><a id="17015" href="/20.07/Naturals/#17015" class="Function">_</a> <a id="17017" class="Symbol">=</a>
  <a id="17021" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
    <a id="17031" class="Number">2</a> <a id="17033" href="/20.07/Naturals/#16145" class="Function Operator">*</a> <a id="17035" class="Number">3</a>
  <a id="17039" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="17046" class="Comment">-- inductive case</a>
    <a id="17068" class="Number">3</a> <a id="17070" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="17072" class="Symbol">(</a><a id="17073" class="Number">1</a> <a id="17075" href="/20.07/Naturals/#16145" class="Function Operator">*</a> <a id="17077" class="Number">3</a><a id="17078" class="Symbol">)</a>
  <a id="17082" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="17089" class="Comment">-- inductive case</a>
    <a id="17111" class="Number">3</a> <a id="17113" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="17115" class="Symbol">(</a><a id="17116" class="Number">3</a> <a id="17118" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="17120" class="Symbol">(</a><a id="17121" class="Number">0</a> <a id="17123" href="/20.07/Naturals/#16145" class="Function Operator">*</a> <a id="17125" class="Number">3</a><a id="17126" class="Symbol">))</a>
  <a id="17131" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="17138" class="Comment">-- base case</a>
    <a id="17155" class="Number">3</a> <a id="17157" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="17159" class="Symbol">(</a><a id="17160" class="Number">3</a> <a id="17162" href="/20.07/Naturals/#11238" class="Function Operator">+</a> <a id="17164" class="Number">0</a><a id="17165" class="Symbol">)</a>
  <a id="17169" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>    <a id="17176" class="Comment">-- simplify</a>
    <a id="17192" class="Number">6</a>
  <a id="17196" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre><p>The first line matches the inductive case by taking <code class="language-plaintext highlighter-rouge">m = 1</code> and <code class="language-plaintext highlighter-rouge">n = 3</code>, The second line matches the inductive case by taking <code class="language-plaintext highlighter-rouge">m = 0</code> and <code class="language-plaintext highlighter-rouge">n = 3</code>, and the third line matches the base case by taking <code class="language-plaintext highlighter-rouge">n = 3</code>. Here we have omitted the signature declaring <code class="language-plaintext highlighter-rouge">_ : 2 * 3 ≡ 6</code>, since it can easily be inferred from the corresponding term.</p><h4 id="times-example">Exercise <code class="language-plaintext highlighter-rouge">*-example</code> (practice)</h4><p>Compute <code class="language-plaintext highlighter-rouge">3 * 4</code>, writing out your reasoning as a chain of equations, using the equations for <code class="language-plaintext highlighter-rouge">*</code>. (You do not need to step through the evaluation of <code class="language-plaintext highlighter-rouge">+</code>.)</p><pre class="Agda"><a id="17749" class="Comment">-- Your code goes here</a>
</pre><h4 id="power">Exercise <code class="language-plaintext highlighter-rouge">_^_</code> (recommended)</h4><p>Define exponentiation, which is given by the following equations:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>m ^ 0        =  1
m ^ (1 + n)  =  m * (m ^ n)
</code></pre></div></div><p>Check that <code class="language-plaintext highlighter-rouge">3 ^ 4</code> is <code class="language-plaintext highlighter-rouge">81</code>.</p><pre class="Agda"><a id="17977" class="Comment">-- Your code goes here</a>
</pre><h2 id="monus">Monus</h2><p>We can also define subtraction. Since there are no negative natural numbers, if we subtract a larger number from a smaller number we will take the result to be zero. This adaption of subtraction to naturals is called <em>monus</em> (a twist on <em>minus</em>).</p><p>Monus is our first use of a definition that uses pattern matching against both arguments:</p><pre class="Agda"><a id="_∸_"></a><a id="18361" href="/20.07/Naturals/#18361" class="Function Operator">_∸_</a> <a id="18365" class="Symbol">:</a> <a id="18367" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="18369" class="Symbol">→</a> <a id="18371" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a> <a id="18373" class="Symbol">→</a> <a id="18375" href="/20.07/Naturals/#1113" class="Datatype">ℕ</a>
<a id="18377" href="/20.07/Naturals/#18377" class="Bound">m</a>     <a id="18383" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="18385" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a>   <a id="18392" class="Symbol">=</a>  <a id="18395" href="/20.07/Naturals/#18377" class="Bound">m</a>
<a id="18397" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a>  <a id="18403" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="18405" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="18409" href="/20.07/Naturals/#18409" class="Bound">n</a>  <a id="18412" class="Symbol">=</a>  <a id="18415" href="/20.07/Naturals/#1129" class="InductiveConstructor">zero</a>
<a id="18420" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="18424" href="/20.07/Naturals/#18424" class="Bound">m</a> <a id="18426" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="18428" href="/20.07/Naturals/#1140" class="InductiveConstructor">suc</a> <a id="18432" href="/20.07/Naturals/#18432" class="Bound">n</a>  <a id="18435" class="Symbol">=</a>  <a id="18438" href="/20.07/Naturals/#18424" class="Bound">m</a> <a id="18440" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="18442" href="/20.07/Naturals/#18432" class="Bound">n</a>
</pre><p>We can do a simple analysis to show that all the cases are covered.</p><ul><li>Consider the second argument.<ul><li>If it is <code class="language-plaintext highlighter-rouge">zero</code>, then the first equation applies.</li><li>If it is <code class="language-plaintext highlighter-rouge">suc n</code>, then consider the first argument.<ul><li>If it is <code class="language-plaintext highlighter-rouge">zero</code>, then the second equation applies.</li><li>If it is <code class="language-plaintext highlighter-rouge">suc m</code>, then the third equation applies.</li></ul></li></ul></li></ul><p>Again, the recursive definition is well founded because monus on bigger numbers is defined in terms of monus on smaller numbers.</p><p>For example, let’s subtract two from three:</p><pre class="Agda"><a id="18962" href="/20.07/Naturals/#18962" class="Function">_</a> <a id="18964" class="Symbol">=</a>
  <a id="18968" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
    <a id="18978" class="Number">3</a> <a id="18980" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="18982" class="Number">2</a>
  <a id="18986" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="18994" class="Number">2</a> <a id="18996" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="18998" class="Number">1</a>
  <a id="19002" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="19010" class="Number">1</a> <a id="19012" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="19014" class="Number">0</a>
  <a id="19018" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="19026" class="Number">1</a>
  <a id="19030" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre><p>We did not use the second equation at all, but it will be required if we try to subtract a larger number from a smaller one:</p><pre class="Agda"><a id="19165" href="/20.07/Naturals/#19165" class="Function">_</a> <a id="19167" class="Symbol">=</a>
  <a id="19171" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2597" class="Function Operator">begin</a>
    <a id="19181" class="Number">2</a> <a id="19183" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="19185" class="Number">3</a>
  <a id="19189" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="19197" class="Number">1</a> <a id="19199" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="19201" class="Number">2</a>
  <a id="19205" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="19213" class="Number">0</a> <a id="19215" href="/20.07/Naturals/#18361" class="Function Operator">∸</a> <a id="19217" class="Number">1</a>
  <a id="19221" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2655" class="Function Operator">≡⟨⟩</a>
    <a id="19229" class="Number">0</a>
  <a id="19233" href="https://agda.github.io/agda-stdlib/v1.1/Relation.Binary.PropositionalEquality.Core.html#2892" class="Function Operator">∎</a>
</pre><h4 id="monus-examples">Exercise <code class="language-plaintext highlighter-rouge">∸-example₁</code> and <code class="language-plaintext highlighter-rouge">∸-example₂</code> (recommended)</h4><p>Compute <code class="language-plaintext highlighter-rouge">5 ∸ 3</code> and <code class="language-plaintext highlighter-rouge">3 ∸ 5</code>, writing out your reasoning as a chain of equations.</p><pre class="Agda"><a id="19403" class="Comment">-- Your code goes here</a>
</pre><h2 id="precedence">Precedence</h2><p>We often use <em>precedence</em> to avoid writing too many parentheses. Application <em>binds more tightly than</em> (or <em>has precedence over</em>) any operator, and so we may write <code class="language-plaintext highlighter-rouge">suc m + n</code> to mean <code class="language-plaintext highlighter-rouge">(suc m) + n</code>. As another example, we say that multiplication binds more tightly than addition, and so write <code class="language-plaintext highlighter-rouge">n + m * n</code> to mean <code class="language-plaintext highlighter-rouge">n + (m * n)</code>. We also sometimes say that addition <em>associates to the left</em>, and so write <code class="language-plaintext highlighter-rouge">m + n + p</code> to mean <code class="language-plaintext highlighter-rouge">(m + n) + p</code>.</p><p>In Agda the precedence and associativity of infix operators needs to be declared:</p><pre class="Agda"><a id="19972" class="Keyword">infixl</a> <a id="19979" class="Number">6</a>  <a id="19982" href="/20.07/Naturals/#11238" class="Primitive Operator">_+_</a>  <a id="19987" href="/20.07/Naturals/#18361" class="Primitive Operator">_∸_</a>
<a id="19991" class="Keyword">infixl</a> <a id="19998" class="Number">7</a>  <a id="20001" href="/20.07/Naturals/#16145" class="Primitive Operator">_*_</a>
</pre><p>This states operators <code class="language-plaintext highlighter-rouge">_+_</code> and <code class="language-plaintext highlighter-rouge">_∸_</code> have precedence level 6, and operator <code class="language-plaintext highlighter-rouge">_*_</code> has precedence level 7. Addition and monus bind less tightly than multiplication because they have lower precedence. Writing <code class="language-plaintext highlighter-rouge">infixl</code> indicates that all three operators associate to the left. One can also write <code class="language-plaintext highlighter-rouge">infixr</code> to indicate that an operator associates to the right, or just <code class="language-plaintext highlighter-rouge">infix</code> to indicate that parentheses are always required to disambiguate.</p><h2 id="currying">Currying</h2><p>We have chosen to represent a function of two arguments in terms of a function of the first argument that returns a function of the second argument. This trick goes by the name <em>currying</em>.</p><p>Agda, like other functional languages such as Haskell and ML, is designed to make currying easy to use. Function arrows associate to the right and application associates to the left</p><p><code class="language-plaintext highlighter-rouge">ℕ → ℕ → ℕ</code> stands for <code class="language-plaintext highlighter-rouge">ℕ → (ℕ → ℕ)</code></p><p>and</p><p><code class="language-plaintext highlighter-rouge">_+_ 2 3</code> stands for <code class="language-plaintext highlighter-rouge">(_+_ 2) 3</code>.</p><p>The term <code class="language-plaintext highlighter-rouge">_+_ 2</code> by itself stands for the function that adds two to its argument, hence applying it to three yields five.</p><p>Currying is named for Haskell Curry, after whom the programming language Haskell is also named. Curry’s work dates to the 1930’s. When I first learned about currying, I was told it was misattributed, since the same idea was previously proposed by Moses Schönfinkel in the 1920’s. I was told a joke: “It should be called schönfinkeling, but currying is tastier”. Only later did I learn that the explanation of the misattribution was itself a misattribution. The idea actually appears in the <em>Begriffsschrift</em> of Gottlob Frege, published in 1879.</p><h2 id="the-story-of-creation-revisited">The story of creation, revisited</h2><p>Just as our inductive definition defines the naturals in terms of the naturals, so does our recursive definition define addition in terms of addition.</p><p>Again, it is possible to assign our definition a meaning without resorting to unpermitted circularities. We do so by reducing our definition to equivalent inference rules for judgments about equality:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n : ℕ
--------------
zero + n  =  n

m + n  =  p
---------------------
(suc m) + n  =  suc p
</code></pre></div></div><p>Here we assume we have already defined the infinite set of natural numbers, specifying the meaning of the judgment <code class="language-plaintext highlighter-rouge">n : ℕ</code>. The first inference rule is the base case. It asserts that if <code class="language-plaintext highlighter-rouge">n</code> is a natural number then adding zero to it gives <code class="language-plaintext highlighter-rouge">n</code>. The second inference rule is the inductive case. It asserts that if adding <code class="language-plaintext highlighter-rouge">m</code> and <code class="language-plaintext highlighter-rouge">n</code> gives <code class="language-plaintext highlighter-rouge">p</code>, then adding <code class="language-plaintext highlighter-rouge">suc m</code> and <code class="language-plaintext highlighter-rouge">n</code> gives <code class="language-plaintext highlighter-rouge">suc p</code>.</p><p>Again we resort to a creation story, where this time we are concerned with judgments about addition:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- In the beginning, we know nothing about addition.
</code></pre></div></div><p>Now, we apply the rules to all the judgment we know about. The base case tells us that <code class="language-plaintext highlighter-rouge">zero + n = n</code> for every natural <code class="language-plaintext highlighter-rouge">n</code>, so we add all those equations. The inductive case tells us that if <code class="language-plaintext highlighter-rouge">m + n = p</code> (on the day before today) then <code class="language-plaintext highlighter-rouge">suc m + n = suc p</code> (today). We didn’t know any equations about addition before today, so that rule doesn’t give us any new equations:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the first day, we know about addition of 0.
0 + 0 = 0     0 + 1 = 1    0 + 2 = 2     ...
</code></pre></div></div><p>Then we repeat the process, so on the next day we know about all the equations from the day before, plus any equations added by the rules. The base case tells us nothing new, but now the inductive case adds more equations:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the second day, we know about addition of 0 and 1.
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
</code></pre></div></div><p>And we repeat the process again:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the third day, we know about addition of 0, 1, and 2.
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...
</code></pre></div></div><p>You’ve got the hang of it by now:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the fourth day, we know about addition of 0, 1, 2, and 3.
0 + 0 = 0     0 + 1 = 1     0 + 2 = 2     0 + 3 = 3     ...
1 + 0 = 1     1 + 1 = 2     1 + 2 = 3     1 + 3 = 4     ...
2 + 0 = 2     2 + 1 = 3     2 + 2 = 4     2 + 3 = 5     ...
3 + 0 = 3     3 + 1 = 4     3 + 2 = 5     3 + 3 = 6     ...
</code></pre></div></div><p>The process continues. On the <em>m</em>‘th day we will know all the equations where the first number is less than <em>m</em>.</p><p>As we can see, the reasoning that justifies inductive and recursive definitions is quite similar. They might be considered two sides of the same coin.</p><h2 id="finite-creation">The story of creation, finitely</h2><p>The above story was told in a stratified way. First, we create the infinite set of naturals. We take that set as given when creating instances of addition, so even on day one we have an infinite set of instances.</p><p>Instead, we could choose to create both the naturals and the instances of addition at the same time. Then on any day there would be only a finite set of instances:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- In the beginning, we know nothing.
</code></pre></div></div><p>Now, we apply the rules to all the judgment we know about. Only the base case for naturals applies:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the first day, we know zero.
0 : ℕ
</code></pre></div></div><p>Again, we apply all the rules we know. This gives us a new natural, and our first equation about addition.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the second day, we know one and all sums that yield zero.
0 : ℕ
1 : ℕ    0 + 0 = 0
</code></pre></div></div><p>Then we repeat the process. We get one more equation about addition from the base case, and also get an equation from the inductive case, applied to equation of the previous day:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the third day, we know two and all sums that yield one.
0 : ℕ
1 : ℕ    0 + 0 = 0
2 : ℕ    0 + 1 = 1   1 + 0 = 1
</code></pre></div></div><p>You’ve got the hang of it by now:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>-- On the fourth day, we know three and all sums that yield two.
0 : ℕ
1 : ℕ    0 + 0 = 0
2 : ℕ    0 + 1 = 1   1 + 0 = 1
3 : ℕ    0 + 2 = 2   1 + 1 = 2    2 + 0 = 2
</code></pre></div></div><p>On the <em>n</em>‘th day there will be <em>n</em> distinct natural numbers, and <em>n × (n-1) / 2</em> equations about addition. The number <em>n</em> and all equations for addition of numbers less than <em>n</em> first appear by day <em>n+1</em>. This gives an entirely finitist view of infinite sets of data and equations relating the data.</p><h2 id="writing-definitions-interactively">Writing definitions interactively</h2><p>Agda is designed to be used with the Emacs text editor, and the two in combination provide features that help to create definitions and proofs interactively.</p><p>Begin by typing:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+_ : ℕ → ℕ → ℕ
m + n = ?
</code></pre></div></div><p>The question mark indicates that you would like Agda to help with filling in that part of the code. If you type <code class="language-plaintext highlighter-rouge">C-c C-l</code> (pressing the control key while hitting the <code class="language-plaintext highlighter-rouge">c</code> key followed by the <code class="language-plaintext highlighter-rouge">l</code> key) the question mark will be replaced:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+_ : ℕ → ℕ → ℕ
m + n = { }0
</code></pre></div></div><p>The empty braces are called a <em>hole</em>, and 0 is a number used for referring to the hole. The hole will display highlighted in green. Emacs will also create a window displaying the text</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?0 : ℕ
</code></pre></div></div><p>to indicate that hole 0 is to be filled in with a term of type <code class="language-plaintext highlighter-rouge">ℕ</code>. Typing <code class="language-plaintext highlighter-rouge">C-c C-f</code> will move you into the next hole.</p><p>We wish to define addition by recursion on the first argument. Move the cursor into the hole and type <code class="language-plaintext highlighter-rouge">C-c C-c</code>. You will be given the prompt:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pattern variables to case (empty for split on result):
</code></pre></div></div><p>Typing <code class="language-plaintext highlighter-rouge">m</code> will cause a split on that variable, resulting in an update to the code:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+_ : ℕ → ℕ → ℕ
zero + n = { }0
suc m + n = { }1
</code></pre></div></div><p>There are now two holes, and the window at the bottom tells you the required type of each:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>?0 : ℕ
?1 : ℕ
</code></pre></div></div><p>Going into hole 0 and type <code class="language-plaintext highlighter-rouge">C-c C-,</code> will display information on the required type of the hole, and what free variables are available:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
</code></pre></div></div><p>This strongly suggests filling the hole with <code class="language-plaintext highlighter-rouge">n</code>. After the hole is filled, you can type <code class="language-plaintext highlighter-rouge">C-c C-space</code>, which will remove the hole:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = { }1
</code></pre></div></div><p>Again, going into hole 1 and type <code class="language-plaintext highlighter-rouge">C-c C-,</code> will display information on the required type of the hole, and what free variables are available:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
m : ℕ
</code></pre></div></div><p>Going into the hole and type <code class="language-plaintext highlighter-rouge">C-c C-r</code> will fill it in with a constructor (if there is a unique choice) or tell you what constructors you might use, if there is a choice. In this case, it displays the following:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Don't know which constructor to introduce of zero or suc
</code></pre></div></div><p>Filling the hole with <code class="language-plaintext highlighter-rouge">suc ?</code> and typing <code class="language-plaintext highlighter-rouge">C-c C-space</code> results in the following:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = suc { }1
</code></pre></div></div><p>Going into the new hole and typing <code class="language-plaintext highlighter-rouge">C-c C-,</code> gives similar information to before:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Goal: ℕ
————————————————————————————————————————————————————————————
n : ℕ
m : ℕ
</code></pre></div></div><p>We can fill the hole with <code class="language-plaintext highlighter-rouge">m + n</code> and type <code class="language-plaintext highlighter-rouge">C-c C-space</code> to complete the program:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>_+_ : ℕ → ℕ → ℕ
zero + n = n
suc m + n = suc (m + n)
</code></pre></div></div><p>Exploiting interaction to this degree is probably not helpful for a program this simple, but the same techniques can help with more complex programs. Even for a program this simple, using <code class="language-plaintext highlighter-rouge">C-c C-c</code> to split cases can be helpful.</p><h2 id="more-pragmas">More pragmas</h2><p>Including the lines</p><pre class="Agda"><a id="29133" class="Symbol">{-#</a> <a id="29137" class="Keyword">BUILTIN</a> <a id="29145" class="Pragma">NATPLUS</a> <a id="29153" href="/20.07/Naturals/#11238" class="Primitive Operator">_+_</a> <a id="29157" class="Symbol">#-}</a>
<a id="29161" class="Symbol">{-#</a> <a id="29165" class="Keyword">BUILTIN</a> <a id="29173" class="Pragma">NATTIMES</a> <a id="29182" href="/20.07/Naturals/#16145" class="Primitive Operator">_*_</a> <a id="29186" class="Symbol">#-}</a>
<a id="29190" class="Symbol">{-#</a> <a id="29194" class="Keyword">BUILTIN</a> <a id="29202" class="Pragma">NATMINUS</a> <a id="29211" href="/20.07/Naturals/#18361" class="Primitive Operator">_∸_</a> <a id="29215" class="Symbol">#-}</a>
</pre><p>tells Agda that these three operators correspond to the usual ones, and enables it to perform these computations using the corresponding Haskell operators on the arbitrary-precision integer type. Representing naturals with <code class="language-plaintext highlighter-rouge">zero</code> and <code class="language-plaintext highlighter-rouge">suc</code> requires time proportional to <em>m</em> to add <em>m</em> and <em>n</em>, whereas representing naturals as integers in Haskell requires time proportional to the larger of the logarithms of <em>m</em> and <em>n</em>. Similarly, representing naturals with <code class="language-plaintext highlighter-rouge">zero</code> and <code class="language-plaintext highlighter-rouge">suc</code> requires time proportional to the product of <em>m</em> and <em>n</em> to multiply <em>m</em> and <em>n</em>, whereas representing naturals as integers in Haskell requires time proportional to the sum of the logarithms of <em>m</em> and <em>n</em>.</p><h4 id="Bin">Exercise <code class="language-plaintext highlighter-rouge">Bin</code> (stretch)</h4><p>A more efficient representation of natural numbers uses a binary rather than a unary system. We represent a number as a bitstring:</p><pre class="Agda"><a id="30084" class="Keyword">data</a> <a id="Bin"></a><a id="30089" href="/20.07/Naturals/#30089" class="Datatype">Bin</a> <a id="30093" class="Symbol">:</a> <a id="30095" class="PrimitiveType">Set</a> <a id="30099" class="Keyword">where</a>
  <a id="Bin.⟨⟩"></a><a id="30107" href="/20.07/Naturals/#30107" class="InductiveConstructor">⟨⟩</a> <a id="30110" class="Symbol">:</a> <a id="30112" href="/20.07/Naturals/#30089" class="Datatype">Bin</a>
  <a id="Bin._O"></a><a id="30118" href="/20.07/Naturals/#30118" class="InductiveConstructor Operator">_O</a> <a id="30121" class="Symbol">:</a> <a id="30123" href="/20.07/Naturals/#30089" class="Datatype">Bin</a> <a id="30127" class="Symbol">→</a> <a id="30129" href="/20.07/Naturals/#30089" class="Datatype">Bin</a>
  <a id="Bin._I"></a><a id="30135" href="/20.07/Naturals/#30135" class="InductiveConstructor Operator">_I</a> <a id="30138" class="Symbol">:</a> <a id="30140" href="/20.07/Naturals/#30089" class="Datatype">Bin</a> <a id="30144" class="Symbol">→</a> <a id="30146" href="/20.07/Naturals/#30089" class="Datatype">Bin</a>
</pre><p>For instance, the bitstring</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1011
</code></pre></div></div><p>standing for the number eleven is encoded as</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟨⟩ I O I I
</code></pre></div></div><p>Representations are not unique due to leading zeros. Hence, eleven is also represented by <code class="language-plaintext highlighter-rouge">001011</code>, encoded as:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>⟨⟩ O I O I I
</code></pre></div></div><p>Define a function</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inc : Bin → Bin
</code></pre></div></div><p>that converts a bitstring to the bitstring for the next higher number. For example, since <code class="language-plaintext highlighter-rouge">1100</code> encodes twelve, we should have:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>inc (⟨⟩ I O I I) ≡ ⟨⟩ I I O O
</code></pre></div></div><p>Confirm that this gives the correct answer for the bitstrings encoding zero through four.</p><p>Using the above, define a pair of functions to convert between the two representations.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>to   : ℕ → Bin
from : Bin → ℕ
</code></pre></div></div><p>For the former, choose the bitstring to have no leading zeros if it represents a positive natural, and represent zero by <code class="language-plaintext highlighter-rouge">⟨⟩ O</code>. Confirm that these both give the correct answer for zero through four.</p><pre class="Agda"><a id="31016" class="Comment">-- Your code goes here</a>
</pre><h2 id="standard-library">Standard library</h2><p>At the end of each chapter, we will show where to find relevant definitions in the standard library. The naturals, constructors for them, and basic operators upon them, are defined in the standard library module <code class="language-plaintext highlighter-rouge">Data.Nat</code>:</p><pre class="Agda"><a id="31296" class="Comment">-- import Data.Nat using (ℕ; zero; suc; _+_; _*_; _^_; _∸_)</a>
</pre><p>Normally, we will show an import as running code, so Agda will complain if we attempt to import a definition that is not available. This time, however, we have only shown the import as a comment. Both this chapter and the standard library invoke the <code class="language-plaintext highlighter-rouge">NATURAL</code> pragma, the former on <code class="language-plaintext highlighter-rouge">ℕ</code>, and the latter on the equivalent type <code class="language-plaintext highlighter-rouge">Data.Nat.ℕ</code>. Such a pragma can only be invoked once, as invoking it twice would raise confusion as to whether <code class="language-plaintext highlighter-rouge">2</code> is a value of type <code class="language-plaintext highlighter-rouge">ℕ</code> or type <code class="language-plaintext highlighter-rouge">Data.Nat.ℕ</code>. Similar confusions arise if other pragmas are invoked twice. For this reason, we will usually avoid pragmas in future chapters. Information on pragmas can be found in the Agda documentation.</p><h2 id="unicode">Unicode</h2><p>This chapter uses the following unicode:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ℕ  U+2115  DOUBLE-STRUCK CAPITAL N (\bN)
→  U+2192  RIGHTWARDS ARROW (\to, \r, \-&gt;)
∸  U+2238  DOT MINUS (\.-)
≡  U+2261  IDENTICAL TO (\==)
⟨  U+27E8  MATHEMATICAL LEFT ANGLE BRACKET (\&lt;)
⟩  U+27E9  MATHEMATICAL RIGHT ANGLE BRACKET (\&gt;)
∎  U+220E  END OF PROOF (\qed)
</code></pre></div></div><p>Each line consists of the Unicode character (<code class="language-plaintext highlighter-rouge">ℕ</code>), the corresponding code point (<code class="language-plaintext highlighter-rouge">U+2115</code>), the name of the character (<code class="language-plaintext highlighter-rouge">DOUBLE-STRUCK CAPITAL N</code>), and the sequence to type into Emacs to generate the character (<code class="language-plaintext highlighter-rouge">\bN</code>).</p><p>The command <code class="language-plaintext highlighter-rouge">\r</code> gives access to a wide variety of rightward arrows. After typing <code class="language-plaintext highlighter-rouge">\r</code>, one can access the many available arrows by using the left, right, up, and down keys to navigate. The command remembers where you navigated to the last time, and starts with the same character next time. The command <code class="language-plaintext highlighter-rouge">\l</code> works similarly for left arrows. In place of left, right, up, and down keys, one may also use control characters:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C-b  left (backward one character)
C-f  right (forward one character)
C-p  up (to the previous line)
C-n  down (to the next line)
</code></pre></div></div><p>We write <code class="language-plaintext highlighter-rouge">C-b</code> to stand for control-b, and similarly. One can also navigate left and right by typing the digits that appear in the displayed list.</p><p>For a full list of supported characters, use <code class="language-plaintext highlighter-rouge">agda-input-show-translations</code> with:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x agda-input-show-translations
</code></pre></div></div><p>All the characters supported by <code class="language-plaintext highlighter-rouge">agda-mode</code> are shown. We write M-x to stand for typing <code class="language-plaintext highlighter-rouge">ESC</code> followed by <code class="language-plaintext highlighter-rouge">x</code>.</p><p>If you want to know how you input a specific Unicode character in an agda file, move the cursor onto the character and use <code class="language-plaintext highlighter-rouge">quail-show-key</code> with:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M-x quail-show-key
</code></pre></div></div><p>You’ll see a key sequence of the character in mini buffer. If you run <code class="language-plaintext highlighter-rouge">M-x quail-show-key</code> on say <code class="language-plaintext highlighter-rouge">∸</code>, you will see <code class="language-plaintext highlighter-rouge">\.-</code> for the character.</p></div><p style="text-align:center"><a alt="Previous chapter" href="/20.07/Preface/">Prev</a> &bullet; <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev-20.07/src/plfa/part1/Naturals.lagda.md">Source</a> &bullet; <a alt="Next chapter" href="/20.07/Induction/">Next</a></p></article></div></main><footer class="site-footer h-card"><data class="u-url" href="/20.07/"></data><div class="wrapper"><h2 class="footer-heading">Programming Language Foundations in Agda</h2><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Philip Wadler</li><li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Wen Kokke</li><li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div><div class="footer-col-wrapper"><div class="footer-col footer-col-1"><ul class="contact-list"><li class="p-name">Jeremy G. Siek</li><li><a class="u-email" href="mailto:jsiek@indiana.edu">jsiek@indiana.edu</a></li></ul></div><div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/jsiek"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#github"></use></svg> <span class="username">jsiek</span></a></li><li><a href="https://www.twitter.com/jeremysiek"><svg class="svg-icon"><use xlink:href="/20.07/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">jeremysiek</span></a></li></ul></div><div class="footer-col footer-col-3"></div></div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a></div></footer><script type="text/javascript" src="/20.07/assets/jquery.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/anchor-js/4.2.2/anchor.min.js" integrity="sha256-E4RlfxwyJVmkkk0szw7LYJxuPlp6evtPSBDlWHsYYL8=" crossorigin="anonymous"></script><script type="text/javascript">anchors.add()</script><script type="text/javascript">$(".menu-icon").click(function(){$(".trigger").toggle()}),$("div.foldable pre").each(function(){var i=$(this).height(),t=parseFloat($(this).css("line-height")),h=$("<div></div>"),e=$("<div></div>"),o=$("<div></div>");$(this).prepend(h),h.css({position:"relative",float:"right",right:"-"+(.5*t-1.5)+"px",width:t,height:t}),o.css({position:"relative",height:t,width:"3px","background-color":"#C1E0FF"}),e.css({position:"relative",top:"-"+(.5*t+1.5)+"px",left:"-"+(.5*t-1.5)+"px",height:"3px",width:t,"background-color":"#C1E0FF"}),h.append(o),h.append(e),$(this).height(2*t),$(this).css("overflow","hidden"),$(this).click(function(){$(this).height()==i?($(this).height(2*t),h.show()):($(this).height("auto"),h.hide())})})</script><script type="text/javascript" src="/20.07/assets/katex.js"></script><script type="text/javascript">$("script[type='math/tex']").replaceWith(function(){var t=$(this).text();return'<span class="inline-equation">'+katex.renderToString(t)+"</span>"}),$("script[type='math/tex; mode=display']").replaceWith(function(){var t=$(this).text().replace(/%.*?(\n|$)/g,"");return'<div class="equation">'+katex.renderToString("\\displaystyle "+t)+"</div>"})</script></body></html>